#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
json_to_inp.py
Конвертер RodX JSON -> CalculiX .inp (MVP для стержневых каркасов)
Базовая система INP: мм–Н–с–K
Авторский акцент: плоская рама (XY), UZ=RX=RY=0 для всех узлов.

Поддержка сечений:
- стандартные: RECT, CIRC, PIPE, I, BOX
- составные: L (уголок), U (швеллер) — моделируются как набор RECT с OFFSET и одинаковыми узлами

Нагрузки:
- узловые: CLOAD, DOF 1/2 (Fx/Fy), 6 (Mz)
- по элементу: равномерная по глобальной Y -> DLOAD P2
- гравитация: DLOAD GRAV (9810, 0,0,-1)

Примечания:
- Плотность ρ приводится к единицам N*s^2/mm^4 (динамически согласованным).
- Для составных профилей элемент разбивается на несколько «дублей» с теми же узлами; нагрузки по элементу делятся по площадям компонентов.
"""

import json
import math
from collections import defaultdict

# ----------------------------- единицы -----------------------------

def to_mm(val, unit):
    m = unit.lower()
    if m in ("mm",): return float(val)
    if m in ("cm",): return float(val) * 10.0
    if m in ("m",):  return float(val) * 1000.0
    raise ValueError(f"Unknown length unit: {unit}")

def to_force_N(val, unit):
    u = unit.lower()
    if u == "n":   return float(val)
    if u == "kn":  return float(val) * 1000.0
    if u == "kgf": return float(val) * 9.81
    raise ValueError(f"Unknown force unit: {unit}")

def to_moment_Nmm(val, unit):
    u = unit.lower()
    if u in ("n*mm", "nmm"):   return float(val)
    if u in ("n*m", "nm"):     return float(val) * 1000.0
    if u in ("kn*m", "knm"):   return float(val) * 1_000_000.0
    raise ValueError(f"Unknown moment unit: {unit}")

def to_pressure_MPa(val, unit):
    u = unit.lower()
    if u == "mpa": return float(val)
    if u == "gpa": return float(val) * 1000.0
    if u == "pa":  return float(val) * 1e-6
    if u == "kpa": return float(val) * 1e-3
    raise ValueError(f"Unknown pressure unit: {unit}")

def to_density_Ns2_per_mm4(val, unit):
    """
    Приводим к N*s^2/mm^4 (динамически согласованные единицы для мм–Н–с–K).
    1 kg/m^3 = 9.80665e-12 N*s^2/mm^4
    """
    u = unit.lower()
    if u in ("kg/m^3", "kg/m3"):
        return float(val) * 9.80665e-12
    if u in ("n*s^2/mm^4", "ns^2/mm^4"):
        return float(val)
    # (редко встречается т/мм^3): 1 т/мм^3 = 9.80665e6 N*s^2/mm^4
    if u in ("t/mm^3", "t/mm3", "ton/mm^3", "ton/mm3"):
        return float(val) * 9.80665e6
    raise ValueError(f"Unknown density unit: {unit}")

def to_area_mm2(val, unit):
    u = unit.lower()
    if u in ("mm^2", "mm2"): return float(val)
    if u in ("cm^2", "cm2"): return float(val) * 100.0
    if u in ("m^2", "m2"):   return float(val) * 1_000_000.0
    raise ValueError(f"Unknown area unit: {unit}")

def to_inertia_mm4(val, unit):
    u = unit.lower()
    if u in ("mm^4", "mm4"): return float(val)
    if u in ("cm^4", "cm4"): return float(val) * 1e4
    if u in ("m^4", "m4"):   return float(val) * 1e12
    raise ValueError(f"Unknown inertia unit: {unit}")

def to_line_load_N_per_mm(val, unit):
    u = unit.lower()
    # кН/м -> Н/мм: (val * 1000) / 1000 = val
    if u in ("kn/m", "knm^-1", "kn per m"): return float(val)  # (см. комментарий выше)
    if u in ("n/mm", "n/mm¹"):              return float(val)
    if u in ("n/m",):                       return float(val) / 1000.0
    if u in ("kn/mm",):                     return float(val) * 1000.0
    raise ValueError(f"Unknown line load unit: {unit}")

def to_acc_mm_per_s2(val, unit):
    u = unit.lower()
    if u in ("mm/s^2", "mm/s2"): return float(val)
    if u in ("m/s^2", "m/s2"):   return float(val) * 1000.0
    if u in ("g",):
        # 1 g = 9.81 m/s^2 = 9810 mm/s^2
        return float(val) * 9810.0
    raise ValueError(f"Unknown acceleration unit: {unit}")

# ----------------------------- векторная математика -----------------------------

def v_add(a,b): return (a[0]+b[0], a[1]+b[1], a[2]+b[2])
def v_sub(a,b): return (a[0]-b[0], a[1]-b[1], a[2]-b[2])
def v_dot(a,b): return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]
def v_cross(a,b): return (a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0])
def v_len(a): return math.sqrt(max(v_dot(a,a), 0.0))
def v_norm(a):
    L = v_len(a)
    if L < 1e-15: return (0.0,0.0,0.0)
    return (a[0]/L, a[1]/L, a[2]/L)

def project_on_plane(v, n):
    """Проекция v на плоскость, перпендикулярную n."""
    n = v_norm(n)
    return v_sub(v, tuple(n_i * v_dot(v,n) for n_i in n))

def rotate_around_axis(v, axis, angle_rad):
    """Поворот вектора v вокруг оси axis на угол angle (Rodrigues)."""
    k = v_norm(axis)
    if v_len(k) < 1e-12 or abs(angle_rad) < 1e-12:
        return v
    cosA = math.cos(angle_rad)
    sinA = math.sin(angle_rad)
    term1 = tuple(v_i * cosA for v_i in v)
    term2 = tuple(sinA * t for t in v_cross(k, v))
    term3 = tuple((1 - cosA) * v_dot(k, v) * k_i for k_i in k)
    return v_add(v_add(term1, term2), term3)

def rotate_offsets(o1, o2, angle_rad):
    """Поворот локальных смещений (OFFSET1, OFFSET2) в плоскости поперечного сечения."""
    c = math.cos(angle_rad); s = math.sin(angle_rad)
    return (o1*c - o2*s, o1*s + o2*c)

# ----------------------------- helpers -----------------------------

def fmt(x):
    """Красивое форматирование числа в INP."""
    if x is None: return ""
    return f"{float(x):.6g}"

def list_to_lines(ids, per_line=16, prefix=""):
    line = []
    out = []
    for i, v in enumerate(ids, 1):
        line.append(str(v))
        if i % per_line == 0:
            out.append(prefix + ", ".join(line))
            line = []
    if line:
        out.append(prefix + ", ".join(line))
    return out

# ----------------------------- основной конвертер -----------------------------

class InpWriter:
    def __init__(self):
        self.lines = []
        self.created_elsets = set()
        self.comp_map = {}  # phys_elem_id -> list of (comp_elem_id, area_fraction)

    def w(self, s=""):
        self.lines.append(s)

    # --- узлы и планарность ---
    def emit_nodes(self, nodes):
        self.w("*NODE")
        for n in nodes:
            nid = n["nodeId"]
            x = to_mm(n["x"]["value"], n["x"]["unit"]) if isinstance(n["x"], dict) else float(n["x"])
            y = to_mm(n["y"]["value"], n["y"]["unit"]) if isinstance(n["y"], dict) else float(n["y"])
            z = to_mm(n.get("z", {"value":0,"unit":"mm"})["value"], n.get("z", {"value":0,"unit":"mm"})["unit"]) if isinstance(n.get("z"), dict) else float(n.get("z", 0.0))
            self.w(f"{nid}, {fmt(x)}, {fmt(y)}, {fmt(z)}")

    def emit_planar_lock_all_nodes(self, node_ids):
        self.w(f"*NSET, NSET=ALLNODES")
        for ln in list_to_lines(sorted(node_ids), per_line=20):
            self.w(ln)
        self.w("*BOUNDARY")
        self.w("ALLNODES, 3, 3, 0.")  # UZ = 0
        self.w("ALLNODES, 4, 4, 0.")  # RX = 0
        self.w("ALLNODES, 5, 5, 0.")  # RY = 0

    # --- материалы ---
    def emit_materials(self, materials):
        for m in materials:
            name = m["id"]
            # E
            E = to_pressure_MPa(m["elasticModulus"]["value"], m["elasticModulus"]["unit"])
            nu = float(m.get("poissonRatio", 0.3))
            # ρ
            rho = to_density_Ns2_per_mm4(m["density"]["value"], m["density"]["unit"])
            self.w(f"*MATERIAL, NAME={name}")
            self.w("*ELASTIC")
            self.w(f"{fmt(E)}, {fmt(nu)}")
            self.w("*DENSITY")
            self.w(f"{fmt(rho)}")

    # --- supports (кинет.) ---
    def emit_supports(self, supports):
        for s in supports:
            nid = s["nodeId"]
            # создаём NSET на узел
            self.w(f"*NSET, NSET=N{nid}")
            self.w(str(nid))
            self.w("*BOUNDARY")
            if s.get("dx"): self.w(f"N{nid}, 1, 1, 0.")  # UX
            if s.get("dy"): self.w(f"N{nid}, 2, 2, 0.")  # UY
            if s.get("dr"): self.w(f"N{nid}, 6, 6, 0.")  # RZ

    # --- elastic supports (пружины) ---
    def emit_elastic_supports(self, elastic):
        for s in elastic:
            nid = s["nodeId"]
            self.w(f"*NSET, NSET=NS{nid}")
            self.w(str(nid))
            self.w(f"*SPRING, NSET=NS{nid}")
            if "kx" in s and s["kx"]["value"] != 0:
                kx = to_force_N(s["kx"]["value"], s["kx"]["unit"]) / 1.0  # Н/мм если unit=N
                self.w(f"1, {fmt(kx)}")
            if "ky" in s and s["ky"]["value"] != 0:
                ky = to_force_N(s["ky"]["value"], s["ky"]["unit"]) / 1.0
                self.w(f"2, {fmt(ky)}")
            if "kr" in s and s["kr"]["value"] != 0:
                kr = to_moment_Nmm(s["kr"]["value"], s["kr"]["unit"])  # Н*мм/рад
                self.w(f"6, {fmt(kr)}")

    # --- элементы и сечения ---
    def _emit_element_line(self, elset, elem_id, n1, n2):
        if elset not in self.created_elsets:
            self.created_elsets.add(elset)
        self.w(f"*ELEMENT, TYPE=B31, ELSET={elset}")
        self.w(f"{elem_id}, {n1}, {n2}")

    def _emit_beam_section_rect(self, elset, mat, h, b, v1, offset=None):
        offstr = ""
        if offset:
            offstr = f", OFFSET1={fmt(offset[0])}, OFFSET2={fmt(offset[1])}"
        self.w(f"*BEAM SECTION, SECTION=RECT, MATERIAL={mat}, ELSET={elset}{offstr}")
        self.w(f"{fmt(h)}, {fmt(b)}")
        self.w(f"{fmt(v1[0])}, {fmt(v1[1])}, {fmt(v1[2])}")

    def _emit_beam_section_circ(self, elset, mat, d, v1):
        self.w(f"*BEAM SECTION, SECTION=CIRC, MATERIAL={mat}, ELSET={elset}")
        self.w(f"{fmt(d)}")
        self.w(f"{fmt(v1[0])}, {fmt(v1[1])}, {fmt(v1[2])}")

    def _emit_beam_section_pipe(self, elset, mat, d, t, v1):
        self.w(f"*BEAM SECTION, SECTION=PIPE, MATERIAL={mat}, ELSET={elset}")
        self.w(f"{fmt(d)}, {fmt(t)}")
        self.w(f"{fmt(v1[0])}, {fmt(v1[1])}, {fmt(v1[2])}")

    def _emit_beam_section_i(self, elset, mat, h, b, tw, tf, v1):
        self.w(f"*BEAM SECTION, SECTION=I, MATERIAL={mat}, ELSET={elset}")
        self.w(f"{fmt(h)}, {fmt(b)}, {fmt(tw)}, {fmt(tf)}")
        self.w(f"{fmt(v1[0])}, {fmt(v1[1])}, {fmt(v1[2])}")

    def _emit_beam_section_box(self, elset, mat, h, b, t, v1):
        self.w(f"*BEAM SECTION, SECTION=BOX, MATERIAL={mat}, ELSET={elset}")
        self.w(f"{fmt(h)}, {fmt(b)}, {fmt(t)}")
        self.w(f"{fmt(v1[0])}, {fmt(v1[1])}, {fmt(v1[2])}")

    # --- генератор 1: стандартные ---
    def emit_standard_element(self, e, nodes_lookup, section, material):
        n1, n2 = e["nodeId1"], e["nodeId2"]
        p1 = nodes_lookup[n1]; p2 = nodes_lookup[n2]
        xl = v_norm((p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2]))
        pref = (0.0, 0.0, -1.0)
        v1 = project_on_plane(pref, xl)
        if v_len(v1) < 1e-9:
            v1 = project_on_plane((0.0,1.0,0.0), xl)
        beta = float(e.get("betaAngle", 0.0))  # рад или град? предположим рад
        v1b = rotate_around_axis(v_norm(v1), xl, beta)

        elset = f"E_{e['elemId']}"
        self._emit_element_line(elset, e["elemId"], n1, n2)

        kind = section["kind"].upper()
        if kind == "RECT":
            h = to_mm(section["h"]["value"], section["h"]["unit"])
            b = to_mm(section["b"]["value"], section["b"]["unit"])
            self._emit_beam_section_rect(elset, material["id"], h, b, v1b)
        elif kind == "CIRC":
            d = to_mm(section["d"]["value"], section["d"]["unit"])
            self._emit_beam_section_circ(elset, material["id"], d, v1b)
        elif kind == "PIPE":
            d = to_mm(section["d"]["value"], section["d"]["unit"])
            t = to_mm(section["t"]["value"], section["t"]["unit"])
            self._emit_beam_section_pipe(elset, material["id"], d, t, v1b)
        elif kind == "I":
            h = to_mm(section["h"]["value"], section["h"]["unit"])
            b = to_mm(section["b"]["value"], section["b"]["unit"])
            tw = to_mm(section["tw"]["value"], section["tw"]["unit"])
            tf = to_mm(section["tf"]["value"], section["tf"]["unit"])
            self._emit_beam_section_i(elset, material["id"], h, b, tw, tf, v1b)
        elif kind == "BOX":
            h = to_mm(section["h"]["value"], section["h"]["unit"])
            b = to_mm(section["b"]["value"], section["b"]["unit"])
            t = to_mm(section["t"]["value"], section["t"]["unit"])
            self._emit_beam_section_box(elset, material["id"], h, b, t, v1b)
        else:
            raise ValueError(f"Unsupported standard section kind: {kind}")

    # --- генератор 2: L (уголок) как составное ---
    def emit_L_composite(self, e, nodes_lookup, section, material):
        # Геометрия: h (вертикаль 1ₗ), b (горизонталь 2ₗ), t (толщина)
        h = to_mm(section["h"]["value"], section["h"]["unit"])
        b = to_mm(section["b"]["value"], section["b"]["unit"])
        t = to_mm(section["t"]["value"], section["t"]["unit"])

        n1, n2 = e["nodeId1"], e["nodeId2"]
        p1 = nodes_lookup[n1]; p2 = nodes_lookup[n2]
        xl = v_norm((p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2]))

        # ориентация 1ₗ
        pref = (0.0, 0.0, -1.0)
        v1 = project_on_plane(pref, xl)
        if v_len(v1) < 1e-9:
            v1 = project_on_plane((0.0,1.0,0.0), xl)
        beta = float(e.get("betaAngle", 0.0))
        v1b = rotate_around_axis(v_norm(v1), xl, beta)

        # площади ветвей (без двойного учёта в углу):
        A1 = h * t               # вертикальная ветвь
        A2 = max(b - t, 0.0) * t # горизонтальная ветвь (укорочена на t)
        Atot = max(A1 + A2, 1e-9)

        # координаты центров тяжести (локально: 1ₗ вверх (y), 2ₗ вправо (z))
        # соглашение для β=0: длинная полка снизу, другая слева от оси -> как обсуждали:
        c1 = (h/2.0,          t/2.0)              # (y,z) вертикальная
        c2 = (t/2.0,          t + (max(b - t,0.0))/2.0)  # горизонтальная

        ybar = (A1*c1[0] + A2*c2[0]) / Atot
        zbar = (A1*c1[1] + A2*c2[1]) / Atot

        offV = (c1[0] - ybar, c1[1] - zbar)
        offH = (c2[0] - ybar, c2[1] - zbar)

        # учесть поворот β для OFFSETS:
        offV = rotate_offsets(offV[0], offV[1], beta)
        offH = rotate_offsets(offH[0], offH[1], beta)

        # создаём два дубля элемента
        eid_base = int(e["elemId"])
        elV = f"E_{eid_base}L1"; idV = f"{eid_base}01"
        elH = f"E_{eid_base}L2"; idH = f"{eid_base}02"

        self._emit_element_line(elV, idV, n1, n2)
        self._emit_beam_section_rect(elV, material["id"], h, t, v1b, offset=offV)

        self._emit_element_line(elH, idH, n1, n2)
        self._emit_beam_section_rect(elH, material["id"], t, max(b - t, 0.0), v1b, offset=offH)

        # карта для разбиения линейных нагрузок по площадям:
        self.comp_map[eid_base] = [
            (idV, A1/Atot),
            (idH, A2/Atot if Atot>0 else 0.0),
        ]

    # --- генератор 3: U (швеллер) как составное ---
    def emit_U_composite(self, e, nodes_lookup, section, material):
        h = to_mm(section["h"]["value"], section["h"]["unit"])
        b = to_mm(section["b"]["value"], section["b"]["unit"])
        tw = to_mm(section["tw"]["value"], section["tw"]["unit"])
        tf = to_mm(section["tf"]["value"], section["tf"]["unit"])

        n1, n2 = e["nodeId1"], e["nodeId2"]
        p1 = nodes_lookup[n1]; p2 = nodes_lookup[n2]
        xl = v_norm((p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2]))

        pref = (0.0, 0.0, -1.0)
        v1 = project_on_plane(pref, xl)
        if v_len(v1) < 1e-9:
            v1 = project_on_plane((0.0,1.0,0.0), xl)
        beta = float(e.get("betaAngle", 0.0))
        v1b = rotate_around_axis(v_norm(v1), xl, beta)

        # площадь ветвей
        Aweb = h * tw
        Afr  = tf * max(b - tw, 0.0)
        Atot = max(Aweb + 2*Afr, 1e-9)

        # β=0: стенка слева, полки сверху и снизу
        c_web = ( h/2.0,              tw/2.0 )
        c_bot = ( tf/2.0,             tw + max(b - tw,0.0)/2.0 )
        c_top = ( h - tf/2.0,         tw + max(b - tw,0.0)/2.0 )

        ybar = (Aweb*c_web[0] + Afr*c_bot[0] + Afr*c_top[0]) / Atot
        zbar = (Aweb*c_web[1] + Afr*c_bot[1] + Afr*c_top[1]) / Atot

        off_web = (c_web[0]-ybar, c_web[1]-zbar)
        off_bot = (c_bot[0]-ybar, c_bot[1]-zbar)
        off_top = (c_top[0]-ybar, c_top[1]-zbar)

        off_web = rotate_offsets(off_web[0], off_web[1], beta)
        off_bot = rotate_offsets(off_bot[0], off_bot[1], beta)
        off_top = rotate_offsets(off_top[0], off_top[1], beta)

        eid_base = int(e["elemId"])
        elW = f"E_{eid_base}Uw"; idW = f"{eid_base}01"
        elB = f"E_{eid_base}Ub"; idB = f"{eid_base}02"
        elT = f"E_{eid_base}Ut"; idT = f"{eid_base}03"

        self._emit_element_line(elW, idW, n1, n2)
        self._emit_beam_section_rect(elW, material["id"], h, tw, v1b, offset=off_web)

        self._emit_element_line(elB, idB, n1, n2)
        self._emit_beam_section_rect(elB, material["id"], tf, max(b - tw, 0.0), v1b, offset=off_bot)

        self._emit_element_line(elT, idT, n1, n2)
        self._emit_beam_section_rect(elT, material["id"], tf, max(b - tw, 0.0), v1b, offset=off_top)

        self.comp_map[eid_base] = [
            (idW, Aweb/Atot),
            (idB, Afr/Atot),
            (idT, Afr/Atot),
        ]

    # --- нагрузки/STEP ---
    def emit_step_with_loads(self, model, nodes_lookup, elements, materials_by_id, sections_by_id):
        """Один STEP на каждый loadCase из model['loadCases']."""
        # соберём список всех ELSET, чтобы дать GRAV по группам (или можно построить EALL)
        all_elsets = sorted(self.created_elsets)

        gravity = model.get("gravity", None)
        g_val = 9810.0  # мм/с^2 по умолчанию
        if gravity and "g" in gravity:
            g_val = to_acc_mm_per_s2(gravity["g"]["value"], gravity["g"]["unit"])
        g_dir = gravity.get("direction", [0.0, 0.0, -1.0]) if gravity else [0.0,0.0,-1.0]

        # индекс нагрузок по loadCaseId
        loads_by_case = defaultdict(list)
        for L in model.get("loads", []):
            loads_by_case[L.get("loadCaseId", 0)].append(L)

        for lc in model.get("loadCases", [{"id": 0, "name":"LC0"}]):
            self.w("*STEP")
            self.w("*STATIC")

            # гравитация по всем ELSET
            if gravity:
                self.w("*DLOAD")
                for es in all_elsets:
                    self.w(f"{es}, GRAV, {fmt(g_val)}, {fmt(g_dir[0])}, {fmt(g_dir[1])}, {fmt(g_dir[2])}")

            # нагрузки из контейнера
            case_loads = loads_by_case.get(lc["id"], [])
            # узловые
            node_load_lines = []
            # элементные
            dload_lines = []

            for L in case_loads:
                scope = L.get("scope", "node")
                if scope == "node":
                    nid = L["targetId"]
                    t = L.get("type", "force").lower()
                    comp = L.get("component", "y").lower()
                    if t == "force":
                        F = to_force_N(L["value"], L["units"])
                        dof = {"x":1, "y":2}.get(comp, 2)
                        node_load_lines.append(f"{nid}, {dof}, {fmt(F)}")
                    elif t == "moment":
                        M = to_moment_Nmm(L["value"], L["units"])
                        node_load_lines.append(f"{nid}, 6, {fmt(M)}")

                elif scope == "element":
                    eid = int(L["targetId"])
                    kind = L.get("type","uniform").lower()
                    comp = L.get("component","y").lower()
                    if kind == "uniform" and comp == "y":
                        q = to_line_load_N_per_mm(L["startValue"], L["units"])  # равномерная
                        # если это составной элемент -> распределяем по компонентам:
                        if eid in self.comp_map:
                            for (comp_id, frac) in self.comp_map[eid]:
                                dload_lines.append(f"{comp_id}, P2, {fmt(q * frac)}")
                        else:
                            dload_lines.append(f"{eid}, P2, {fmt(q)}")
                    else:
                        # другие случаи можно добавить позже
                        pass

            if node_load_lines:
                self.w("*CLOAD")
                for ln in node_load_lines:
                    self.w(ln)

            if dload_lines:
                self.w("*DLOAD")
                for ln in dload_lines:
                    self.w(ln)

            # вывод полей
            self.w("*NODE FILE")
            self.w("U")
            self.w("*EL FILE")
            self.w("S, E")
            # (опционально для эпюр N-V-M-T):
            # self.w("*EL FILE, SECTION FORCES")
            # self.w("S")
            self.w("*END STEP")

# ----------------------------- основная функция -----------------------------

def convert(model: dict) -> str:
    iw = InpWriter()

    iw.w("*HEADING")
    iw.w("RodX export (mm-N-s-K), planar XY")

    # узлы
    nodes = model.get("nodes", [])
    iw.emit_nodes(nodes)
    node_ids = [n["nodeId"] for n in nodes]
    nodes_lookup = {}
    for n in nodes:
        x = to_mm(n["x"]["value"], n["x"]["unit"]) if isinstance(n["x"], dict) else float(n["x"])
        y = to_mm(n["y"]["value"], n["y"]["unit"]) if isinstance(n["y"], dict) else float(n["y"])
        z = to_mm(n.get("z", {"value":0,"unit":"mm"})["value"], n.get("z", {"value":0,"unit":"mm"})["unit"]) if isinstance(n.get("z"), dict) else float(n.get("z", 0.0))
        nodes_lookup[n["nodeId"]] = (x,y,z)

    iw.emit_planar_lock_all_nodes(node_ids)

    # материалы
    materials = model.get("materials", [])
    mats_by_id = {m["id"]: m for m in materials}
    iw.emit_materials(materials)

    # секции индексом
    sections = model.get("sections", [])
    secs_by_id = {s["id"]: s for s in sections}

    # элементы
    elements = model.get("elements", [])
    if any((e.get("structuralType", "beam").lower() == "truss") for e in elements):
        iw.w("*USER ELEMENT, TYPE=U1, NODES=2, INTEGRATION POINTS=2, MAXDOF=2")
    for e in elements:
        sec = secs_by_id[e["sectionId"]]
        mat = mats_by_id[e["materialId"]]
        kind = sec["kind"].upper()
        if kind in ("RECT","CIRC","PIPE","I","BOX"):
            iw.emit_standard_element(e, nodes_lookup, sec, mat)
        elif kind in ("L",):
            iw.emit_L_composite(e, nodes_lookup, sec, mat)
        elif kind in ("U","CHANNEL","C","UPN"):
            iw.emit_U_composite(e, nodes_lookup, sec, mat)
        else:
            raise ValueError(f"Unsupported section kind for MVP: {kind}")

    # supports
    iw.emit_supports(model.get("supports", []))

    # elastic supports
    iw.emit_elastic_supports(model.get("elasticSupports", []))

    # STEP + нагрузки
    iw.emit_step_with_loads(model, nodes_lookup, elements, mats_by_id, secs_by_id)

    return "\n".join(iw.lines)

# ----------------------------- CLI -----------------------------

if __name__ == "__main__":
    import sys, pathlib
    if len(sys.argv) < 3:
        print("Usage: json_to_inp.py <input.json> <output.inp>")
        sys.exit(1)
    jpath = sys.argv[1]
    opath = sys.argv[2]
    data = json.load(open(jpath, "r", encoding="utf-8"))
    text = convert(data)
    pathlib.Path(opath).write_text(text, encoding="utf-8")
    print(f"INP written to {opath}")
