#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
JSON → CalculiX .inp (2D beams, I-beam only for now), with unit normalization to mm–N–s–K.
"""

from __future__ import annotations
import json, math, sys
from pathlib import Path
from typing import Dict, Any, List, Tuple, Optional

# ---------------- Unit conversion → mm, N, s, K ----------------

def conv_length_to_mm(x: float, u: str) -> float:
    u = u.lower()
    if u in ("mm","millimeter","millimeters"): return x
    if u in ("m","meter","meters"):            return x*1000.0
    if u in ("cm","centimeter","centimeters"): return x*10.0
    if u in ("in","inch","inches"):            return x*25.4
    if u in ("ft","feet"):                     return x*304.8
    raise ValueError(f"Unsupported length unit: {u}")

def conv_force_to_N(x: float, u: str) -> float:
    u = u.lower()
    if u=="n":  return x
    if u=="kn": return x*1_000.0
    if u=="mn": return x*1_000_000.0
    if u=="lbf":return x*4.4482216153
    raise ValueError(f"Unsupported force unit: {u}")

def conv_E_to_N_per_mm2(x: float, u: str) -> float:
    u = u.lower()
    if u=="pa":   return x/1e6
    if u=="mpa":  return x
    if u=="gpa":  return x*1000.0
    if u=="psi":  return x*0.00689475729
    raise ValueError(f"Unsupported E unit: {u}")

def conv_density_to_Ns2_per_mm4(rho: float, u: str) -> float:
    # ρ[kg/m^3] → ρ[N*s^2/mm^4] = ρ * 1e-12
    u = u.lower()
    if u in ("kg/m^3","kg/m3"): return rho*1e-12
    if u in ("t/m^3","t/m3"):   return (rho*1000.0)*1e-12
    raise ValueError(f"Unsupported density unit: {u}")

def conv_area_to_mm2(x: float, u: str) -> float:
    u=u.lower()
    if u in ("mm^2","mm2"): return x
    if u in ("cm^2","cm2"): return x*100.0
    if u in ("m^2","m2"):   return x*1e6
    raise ValueError(f"Unsupported area unit: {u}")

def conv_inertia_to_mm4(x: float, u: str) -> float:
    u=u.lower()
    if u in ("mm^4","mm4"): return x
    if u in ("cm^4","cm4"): return x*1e4
    if u in ("m^4","m4"):   return x*1e12
    raise ValueError(f"Unsupported inertia unit: {u}")

def conv_moment_to_Nmm(x: float, u: str) -> float:
    u=u.lower()
    if u in ("n*mm","nmm","n-mm"): return x
    if u in ("n*m","nm"):          return x*1000.0
    if u in ("kn*m","knm"):        return x*1_000_000.0
    raise ValueError(f"Unsupported moment unit: {u}")

def conv_line_load_to_N_per_mm(x: float, u: str) -> float:
    u=u.lower()
    if u in ("n/mm","n/mm."): return x
    if u in ("n/m","n/ m"):   return x/1000.0
    if u in ("kn/m","kn/ m"): return (x*1000.0)/1000.0
    raise ValueError(f"Unsupported line load unit: {u}")

def conv_stiffness_N_per_mm(k: float, force_u: str, length_u: str) -> float:
    return conv_force_to_N(1.0, force_u)/conv_length_to_mm(1.0, length_u)*k

def conv_rot_stiffness_Nmm(k: float, force_u: str, length_u: str) -> float:
    return conv_force_to_N(1.0, force_u)*conv_length_to_mm(1.0, length_u)*k

def fmt(x: float) -> str:
    return f"{x:.9g}"

# ---------------- Section handling (I-beam only) ----------------

def rotate_Iy_Iz(Iy: float, Iz: float, beta_deg: float) -> Tuple[float,float,float]:
    """Rotate inertia tensor around beam axis by beta (degrees)."""
    b = math.radians(beta_deg)
    c, s = math.cos(b), math.sin(b)
    Iyz = 0.0
    Iy_p  = Iy*c*c + Iz*s*s - 2*Iyz*s*c
    Iz_p  = Iy*s*s + Iz*c*c + 2*Iyz*s*c
    Iyz_p = (Iy - Iz)*s*c + Iyz*(c*c - s*s)
    return Iy_p, Iz_p, Iyz_p

def section_I_beam_props(section: Dict[str,Any]) -> Tuple[float,float,float,float]:
    """
    Вернуть (A, Iy, Iz, J) в мм^2 / мм^4 для двутавра.
    Отдаём приоритет явным properties (A, Iy, Iz, J). Если их нет — можно добавить
    расчёт из geometry (h,b,tw,tf) — пока не нужен, т.к. в вашем JSON свойства уже заданы.
    """
    props = section.get("properties", {})
    if not props:
        raise ValueError("I-beam section must provide 'properties' (A, Iy, Iz, J)")

    A  = conv_area_to_mm2(float(props["A"]["value"]),  props["A"]["unit"])
    Iy = conv_inertia_to_mm4(float(props["Iy"]["value"]), props["Iy"]["unit"])
    Iz = conv_inertia_to_mm4(float(props["Iz"]["value"]), props["Iz"]["unit"])
    J  = conv_inertia_to_mm4(float(props["J"]["value"]),  props["J"]["unit"])
    return A, Iy, Iz, J

# ---------------- INP writer (2D beams) ----------------

class InpWriter:
    def __init__(self, model: Dict[str,Any]) -> None:
        self.m = model
        u = model.get("units", {})
        self.u_len = u.get("length","mm")
        self.u_force = u.get("force","N")

        self.sections_by_id = {s["id"]: s for s in model.get("sections", [])}
        self.materials_by_id = {m["id"]: m for m in model.get("materials", [])}
        self.loads_by_id = {ld["id"]: ld for ld in model.get("loads", [])}

    def build(self) -> List[str]:
        L: List[str] = []
        L += ["** Generated by json2inp (mm-N-s-K) — I-beam only"]

        # Nodes
        L += ["*NODE"]
        for n in self.m.get("nodes", []):
            nid = int(n["nodeId"])
            x = conv_length_to_mm(float(n["x"]), self.u_len)
            y = conv_length_to_mm(float(n["y"]), self.u_len)
            L.append(f"{nid}, {fmt(x)}, {fmt(y)}, 0")

        # Elements (B31)
        L += ["*ELEMENT, TYPE=B31"]
        for e in self.m.get("elements", []):
            L.append(f"{int(e['elemId'])}, {int(e['nodeId1'])}, {int(e['nodeId2'])}")

        # Global sets
        all_nodes = [int(n["nodeId"]) for n in self.m.get("nodes",[])]
        all_elems = [int(e["elemId"]) for e in self.m.get("elements",[])]
        L += ["*NSET, NSET=ALL", ", ".join(map(str, all_nodes))]
        L += ["*ELSET, ELSET=ALL", ", ".join(map(str, all_elems))]

        # Materials
        for mid, mobj in self.materials_by_id.items():
            p = mobj.get("properties", {})
            E  = conv_E_to_N_per_mm2(float(p["elasticModulus"]["value"]), p["elasticModulus"]["unit"])
            nu = float(p.get("poissonRatio",{}).get("value", 0.3))
            L += [f"*MATERIAL, NAME={mid}", "*ELASTIC", f"{fmt(E)}, {fmt(nu)}"]
            if "density" in p:
                rho = conv_density_to_Ns2_per_mm4(float(p["density"]["value"]), p["density"]["unit"])
                L += ["*DENSITY", fmt(rho)]

        # Per-element ELSET + SECTION
        for e in self.m.get("elements", []):
            eid   = int(e["elemId"])
            elset = f"EL_{eid}"
            L += [f"*ELSET, ELSET={elset}", f"{eid}"]

            mid = e["materialId"]
            sec = self.sections_by_id[e["sectionId"]]
            if sec.get("type","").lower() not in ("i-beam","i","ipe","ipe-beam","eu i-beam"):
                raise ValueError("Only I-beam sections are supported in this version.")

            A, Iy, Iz, J = section_I_beam_props(sec)

            # beta at element
            beta = float(e.get("betaAngle", 0.0))
            Iy_r, Iz_r, _ = rotate_Iy_Iz(Iy, Iz, beta)
            Iyz_r = 0.0  # 2D requirement

            L += [f"*BEAM GENERAL SECTION, ELSET={elset}, MATERIAL={mid}"]
            L += [f"{fmt(A)}, {fmt(max(J,1e-18))}, {fmt(Iy_r)}, {fmt(Iz_r)}, {fmt(Iyz_r)}"]

        # Supports → BOUNDARY
        for sp in self.m.get("supports", []):
            nid = int(sp["nodeId"])
            if int(sp.get("dx",0))==1: L += ["*BOUNDARY", f"{nid}, 1, 1"]
            if int(sp.get("dy",0))==1: L += ["*BOUNDARY", f"{nid}, 2, 2"]
            if int(sp.get("dr",0))==1: L += ["*BOUNDARY", f"{nid}, 6, 6"]

        # Elastic supports (springs at node)
        for es in self.m.get("elasticSupports", []):
            nid = int(es["nodeId"])
            kx = float(es.get("kx",0.0)); ky = float(es.get("ky",0.0)); kr = float(es.get("kr",0.0))
            if kx: L += [f"*SPRING1, DOF=1", f"{nid}, {fmt(conv_stiffness_N_per_mm(kx,self.u_force,self.u_len))}"]
            if ky: L += [f"*SPRING1, DOF=2", f"{nid}, {fmt(conv_stiffness_N_per_mm(ky,self.u_force,self.u_len))}"]
            if kr: L += [f"*SPRING1, DOF=6", f"{nid}, {fmt(conv_rot_stiffness_Nmm(kr,self.u_force,self.u_len))}"]

        # Connectors (rotational stiffness at node — simple placeholder)
        for cn in self.m.get("connectors", []):
            nid = int(cn["nodeId"])
            rkr = float(cn.get("stiffness",{}).get("rkr",0.0))
            if rkr:
                L += [f"*SPRING1, DOF=6", f"{nid}, {fmt(conv_rot_stiffness_Nmm(rkr,self.u_force,self.u_len))}"]

        # Steps per loadCase
        loads_by_id = self.loads_by_id
        for lc in self.m.get("loadCases", []):
            L += [f"*STEP, NLGEOM=NO", "*STATIC", "1., 1., 1e-5, 1.", f"** {lc.get('name','LC')}"]

            # Gather loads
            clines: List[str] = []
            dlines: List[str] = []
            for lid in lc.get("loads", []):
                ld = loads_by_id.get(lid)
                if not ld: continue
                scope = ld.get("scope","node")
                if scope=="node":
                    if ld.get("type")=="force":
                        dof = 1 if ld.get("component","x").lower()=="x" else 2
                        val = conv_force_to_N(float(ld["value"]), ld.get("units", self.u_force))
                        clines.append(f"{int(ld['targetId'])}, {dof}, {fmt(val)}")
                    elif ld.get("type")=="moment":
                        val = conv_moment_to_Nmm(float(ld["value"]), ld.get("units","N*mm"))
                        clines.append(f"{int(ld['targetId'])}, 6, {fmt(val)}")
                elif scope=="element" and ld.get("type")=="uniform":
                    # component y → local dir 2
                    q = conv_line_load_to_N_per_mm(float(ld.get("startValue",0.0)), ld.get("units","N/mm"))
                    dlines.append(f"EL_{int(ld['targetId'])}, P2, {fmt(q)}")

            if clines: L += ["*CLOAD"] + clines
            if dlines: L += ["*DLOAD"] + dlines
            L += ["*NODE PRINT, NSET=ALL", "U", "*EL PRINT, ELSET=ALL", "S", "*END STEP"]

        return L

# ---------------- CLI ----------------

def convert_json_to_inp(json_path: Path, out_inp: Path) -> None:
    data = json.loads(Path(json_path).read_text(encoding="utf-8"))
    lines = InpWriter(data).build()
    Path(out_inp).write_text("\n".join(lines) + "\n", encoding="utf-8")

if __name__ == "__main__":
    # Usage: python json2inp_Ibeam.py model.json out.inp
    if len(sys.argv) >= 3:
        convert_json_to_inp(Path(sys.argv[1]), Path(sys.argv[2]))
    else:
        print("Usage: python json2inp_Ibeam.py input.json output.inp")
