// json2inp_Ibeam_rect.js
// Convert model JSON → CalculiX .inp (B31). I-beam is composed as 3 RECT sections with OFFSETS.
// Units normalized to mm–N–s–K. Supports β-rotation (about local axis 1) for each element.

const conv = {
  length(x, u="mm"){u=u.toLowerCase();
    if(u==="mm")return x; if(u==="m"||u==="meter"||u==="meters")return x*1000;
    if(u==="cm")return x*10; if(u==="in"||u==="inch"||u==="inches")return x*25.4;
    if(u==="ft"||u==="feet")return x*304.8; throw Error("len "+u);},
  force(x, u="N"){u=u.toLowerCase();
    if(u==="n")return x; if(u==="kn")return x*1e3; if(u==="mn")return x*1e6;
    if(u==="lbf")return x*4.4482216153; throw Error("force "+u);},
  E(x,u="MPa"){u=u.toLowerCase();
    if(u==="pa")return x/1e6; if(u==="mpa")return x; if(u==="gpa")return x*1e3;
    if(u==="psi")return x*0.00689475729; throw Error("E "+u);},
  rho(x,u="kg/m^3"){u=u.toLowerCase();
    if(u==="kg/m^3"||u==="kg/m3")return x*1e-12; if(u==="t/m^3"||u==="t/m3")return (x*1000)*1e-12;
    throw Error("rho "+u);},
  mom(x,u="N*mm"){u=u.toLowerCase();
    if(u==="n*mm"||u==="nmm"||u==="n-mm")return x; if(u==="n*m"||u==="nm")return x*1000;
    if(u==="kn*m"||u==="knm")return x*1e6; throw Error("M "+u);},
  q(x,u="N/mm"){u=u.toLowerCase();
    if(u==="n/mm")return x; if(u==="n/m")return x/1000; if(u==="kn/m")return (x*1000)/1000;
    if(u==="lbf/in")return (x*4.4482216153)/25.4; throw Error("q "+u);},
  kT(k,fu,lu){return conv.force(1,fu)/conv.length(1,lu)*k;},
  kR(k,fu,lu){return conv.force(1,fu)*conv.length(1,lu)*k;}
};
const fmt = x => Number(x).toPrecision(9).replace(/\.0+($|e)/,"$1");

// ---------- small math helpers ----------
function normalize(v){ const n=Math.hypot(v[0],v[1],v[2]); return n? [v[0]/n,v[1]/n,v[2]/n]:[0,0,0]; }
function cross(a,b){ return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
function add(a,b){ return [a[0]+b[0],a[1]+b[1],a[2]+b[2]]; }
function scale(a,s){ return [a[0]*s,a[1]*s,a[2]*s]; }
/** Rotate vector v around unit axis k by angle beta (rad) via Rodrigues */
function rotateAround(v,k,b){ const c=Math.cos(b), s=Math.sin(b); return add(add(scale(v,c), scale(cross(k,v),s)), scale(k,(1-c)*(k[0]*v[0]+k[1]*v[1]+k[2]*v[2]))); }
/** Rotate offsets (off2,off3) in local 2–3 plane by beta (deg) */
function rot23(off2, off3, betaDeg){
  const b = betaDeg*Math.PI/180;
  const c = Math.cos(b), s = Math.sin(b);
  return { off2: off2*c - off3*s, off3: off2*s + off3*c };
}

// ---------- I-beam geometry → three RECTs with offsets ----------
function iBeamToRECTs(section, unitsLen="mm"){
  // geometry: h, b, tw, tf (r ignored here)
  const g = section.geometry || {};
  const h  = conv.length(Number(g.h.value),  g.h.unit  || unitsLen);   // overall depth
  const b  = conv.length(Number(g.b.value),  g.b.unit  || unitsLen);   // flange width
  const tw = conv.length(Number(g.tw.value), g.tw.unit || unitsLen);   // web thickness
  const tf = conv.length(Number(g.tf.value), g.tf.unit || unitsLen);   // flange thickness

  // RECT data line in CCX: "b, h" where b ↔ local 3 (width), h ↔ local 2 (height)
  // Base offsets for β=0 (local 2 up, local 3 to the right):
  const yOff = h/2 - tf/2;
  return [
    { name: "FLANGE_BOTTOM", b3: b,  h2: tf,      off2: -yOff, off3: 0 },
    { name: "WEB",           b3: tw, h2: Math.max(h-2*tf,1e-12), off2: 0,     off3: 0 },
    { name: "FLANGE_TOP",    b3: b,  h2: tf,      off2: +yOff, off3: 0 },
  ];
}

// ---------- Core converter ----------
function convertJsonToInp(model){
  const units = model.units || {};
  const LEN_U   = units.length || "mm";
  const FORCE_U = units.force  || "N";

  const secById = Object.fromEntries((model.sections||[]).map(s=>[s.id,s]));
  const loadById= Object.fromEntries((model.loads||[]).map(l=>[l.id,l]));

  // quick node map for element tangents
  const nodeById = Object.fromEntries((model.nodes||[]).map(n=>[n.nodeId,n]));
  const xyz = (nid)=>[conv.length(+nodeById[nid].x, LEN_U), conv.length(+nodeById[nid].y, LEN_U), 0];

  const out = [];
  out.push("** Generated by json2inp (JS, mm-N-s-K) — B31 + composite I-beam (3x RECT with OFFSET + β)");

  // *NODE
  out.push("*NODE");
  for(const n of (model.nodes||[])){
    const id=+n.nodeId, x=conv.length(+n.x, LEN_U), y=conv.length(+n.y, LEN_U);
    out.push(`${id}, ${fmt(x)}, ${fmt(y)}, 0`);
  }

  // *ELEMENT, TYPE=B31
  out.push("*ELEMENT, TYPE=B31");
  for(const e of (model.elements||[])){
    out.push(`${+e.elemId}, ${+e.nodeId1}, ${+e.nodeId2}`);
  }

  // Sets
  const allN=(model.nodes||[]).map(n=>+n.nodeId), allE=(model.elements||[]).map(e=>+e.elemId);
  if(allN.length){ out.push("*NSET, NSET=ALL"); out.push(allN.join(", ")); }
  if(allE.length){ out.push("*ELSET, ELSET=ALL"); out.push(allE.join(", ")); }

  // *MATERIAL
  for(const m of (model.materials||[])){
    const p=m.properties||{};
    const E = conv.E(+p.elasticModulus?.value ?? 206000, p.elasticModulus?.unit ?? "MPa");
    const nu= +(p.poissonRatio?.value ?? 0.3);
    out.push(`*MATERIAL, NAME=${m.id}`);
    out.push(`*ELASTIC`);
    out.push(`${fmt(E)}, ${fmt(nu)}`);
    if(p.density){ out.push(`*DENSITY`); out.push(fmt(conv.rho(+p.density.value, p.density.unit))); }
  }

  // Per-element RECT sections with OFFSET and β orientation
  for(const e of (model.elements||[])){
    const eid=+e.elemId, elset=`EL_${eid}`, mid=e.materialId;
    const sec = secById[e.sectionId];
    if(!sec) throw new Error(`Section ${e.sectionId} not found`);
    const typ=(sec.type||"").toLowerCase();
    if(!["i-beam","i","ipe","ipe-beam","eu i-beam"].includes(typ)){
      throw new Error("Only I-beam supported (as 3x RECT).");
    }
    const parts = iBeamToRECTs(sec, LEN_U);
    const beta = +(e.betaAngle || 0);                 // deg

    // element local axis 1 (unit tangent)
    const p1 = xyz(e.nodeId1), p2 = xyz(e.nodeId2);
    const t = normalize([p2[0]-p1[0], p2[1]-p1[1], 0]);

    // base N1 vector (defines local 2-axis). Take global Z as baseline and rotate it by β around t.
    // For planar XY beams this gives a stable 2–3 frame while honoring β.
    const n1_base = [0,0,1];
    const n1_vec  = rotateAround(n1_base, t, beta*Math.PI/180);

    // Element set
    out.push(`*ELSET, ELSET=${elset}`); out.push(String(eid));

    // Emit three RECT sections with rotated OFFSETS and element-wise N1
    for(const p of parts){
      const r = rot23(p.off2, p.off3, beta);
      out.push(`*BEAM SECTION, SECTION=RECT, ELSET=${elset}, MATERIAL=${mid}, OFFSET=${fmt(r.off2)}, ${fmt(r.off3)}`);
      // data line: b (along local 3), h (along local 2)
      out.push(`${fmt(p.b3)}, ${fmt(p.h2)}`);
      // N1 vector (global components) — defines local 2-direction for THIS section on THIS elset
      out.push(`${fmt(n1_vec[0])}, ${fmt(n1_vec[1])}, ${fmt(n1_vec[2])}`);
      out.push(`** ${p.name}`);
    }
  }

  // Supports
  for(const sp of (model.supports||[])){
    const nid=+sp.nodeId;
    if(+sp.dx===1){ out.push(`*BOUNDARY`); out.push(`${nid}, 1, 1`); }
    if(+sp.dy===1){ out.push(`*BOUNDARY`); out.push(`${nid}, 2, 2`); }
    if(+sp.dr===1){ out.push(`*BOUNDARY`); out.push(`${nid}, 6, 6`); }
  }

  // Elastic supports → *SPRING1
  for(const es of (model.elasticSupports||[])){
    const nid=+es.nodeId, kx=+es.kx||0, ky=+es.ky||0, kr=+es.kr||0;
    if(kx){ out.push(`*SPRING1, DOF=1`); out.push(`${nid}, ${fmt(conv.kT(kx, FORCE_U, LEN_U))}`); }
    if(ky){ out.push(`*SPRING1, DOF=2`); out.push(`${nid}, ${fmt(conv.kT(ky, FORCE_U, LEN_U))}`); }
    if(kr){ out.push(`*SPRING1, DOF=6`); out.push(`${nid}, ${fmt(conv.kR(kr, FORCE_U, LEN_U))}`); }
  }

  // Connectors → rotational spring at node (placeholder)
  for(const cn of (model.connectors||[])){
    const nid=+cn.nodeId, rkr=+(cn.stiffness?.rkr||0);
    if(rkr){ out.push(`*SPRING1, DOF=6`); out.push(`${nid}, ${fmt(conv.kR(rkr, FORCE_U, LEN_U))}`); }
  }

  // Steps by loadCases
  const loadById = loadByIdGlobal = loadById; // alias
  for(const lc of (model.loadCases||[])){
    out.push(`*STEP, NLGEOM=NO`);
    out.push(`*STATIC`);
    out.push(`1., 1., 1e-5, 1.`);
    out.push(`** ${lc.name||"LoadCase"}`);

    const cl=[], dl=[];
    for(const lid of (lc.loads||[])){
      const ld=loadById[lid]; if(!ld) continue;
      if((ld.scope||"node")==="node"){
        if(ld.type==="force"){
          const dof=(ld.component||"x").toLowerCase()==="x"?1:2;
          cl.push(`${+ld.targetId}, ${dof}, ${fmt(conv.force(+ld.value, ld.units||FORCE_U))}`);
        }else if(ld.type==="moment"){
          cl.push(`${+ld.targetId}, 6, ${fmt(conv.mom(+ld.value, ld.units||"N*mm"))}`);
        }
      }else if(ld.scope==="element" && ld.type==="uniform"){
        const q=conv.q(+ld.startValue ?? 0, ld.units||"N/mm");
        dl.push(`EL_${+ld.targetId}, P2, ${fmt(q)}`); // along local 2
      }
    }
    if(cl.length){ out.push(`*CLOAD`, ...cl); }
    if(dl.length){ out.push(`*DLOAD`, ...dl); }
    out.push(`*NODE PRINT, NSET=ALL`,`U`);
    out.push(`*EL PRINT, ELSET=ALL`,`S`);
    out.push(`*END STEP`);
  }

  return out.join("\n")+"\n";
}

// Exports for Node:
// module.exports = { convertJsonToInp, iBeamToRECTs };

/*
Usage:
import { readFileSync, writeFileSync } from "node:fs";
const data = JSON.parse(readFileSync("beam_kN_m.json","utf8"));
const inp  = convertJsonToInp(data);
writeFileSync("model.inp", inp, "utf8");
*/
