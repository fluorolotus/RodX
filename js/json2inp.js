// json2inp.js
// Convert model JSON → CalculiX .inp (B31).
// Currently *NODE and *ELEMENT data are emitted. Other entities will be added stepwise.

(function (global) {

const conv = {
  length(x, u="mm"){u=u.toLowerCase();
    if(u==="mm")return x; if(u==="m"||u==="meter"||u==="meters")return x*1000;
    if(u==="cm")return x*10; if(u==="in"||u==="inch"||u==="inches")return x*25.4;
    if(u==="ft"||u==="feet")return x*304.8; throw Error("len "+u);},
  force(x, u="N"){u=u.toLowerCase();
    if(u==="n")return x; if(u==="kn")return x*1e3; if(u==="mn")return x*1e6;
    if(u==="lbf")return x*4.4482216153; throw Error("force "+u);},
  E(x,u="MPa"){u=u.toLowerCase();
    if(u==="pa")return x/1e6; if(u==="mpa")return x; if(u==="gpa")return x*1e3;
    if(u==="psi")return x*0.00689475729; throw Error("E "+u);},
  rho(x,u="kg/m^3"){u=u.toLowerCase();
    if(u==="kg/m^3"||u==="kg/m3")return x*1e-12; if(u==="t/m^3"||u==="t/m3")return (x*1000)*1e-12;
    throw Error("rho "+u);},
  mom(x,u="N*mm"){u=u.toLowerCase();
    if(u==="n*mm"||u==="nmm"||u==="n-mm")return x; if(u==="n*m"||u==="nm")return x*1000;
    if(u==="kn*m"||u==="knm")return x*1e6; throw Error("M "+u);},
  q(x,u="N/mm"){u=u.toLowerCase();
    if(u==="n/mm")return x; if(u==="n/m")return x/1000; if(u==="kn/m")return (x*1000)/1000;
    if(u==="lbf/in")return (x*4.4482216153)/25.4; throw Error("q "+u);},
  area(x,u="mm^2"){u=u.toLowerCase(); const lu=u.replace(/\^?2$/,'').replace(/2$/,'');
    return x*Math.pow(conv.length(1,lu),2);},
  inertia(x,u="mm^4"){u=u.toLowerCase(); const lu=u.replace(/\^?4$/,'').replace(/4$/,'');
    return x*Math.pow(conv.length(1,lu),4);},
  kT(k,fu,lu){return conv.force(1,fu)/conv.length(1,lu)*k;},
  kR(k,fu,lu){return conv.force(1,fu)*conv.length(1,lu)*k;}
};
const fmt = x => Number(x).toPrecision(9).replace(/\.0+($|e)/,"$1");

// ---------- small math helpers ----------
function normalize(v){ const n=Math.hypot(v[0],v[1],v[2]); return n? [v[0]/n,v[1]/n,v[2]/n]:[0,0,0]; }
function cross(a,b){ return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
function add(a,b){ return [a[0]+b[0],a[1]+b[1],a[2]+b[2]]; }
function scale(a,s){ return [a[0]*s,a[1]*s,a[2]*s]; }
/** Rotate vector v around unit axis k by angle beta (rad) via Rodrigues */
function rotateAround(v,k,b){ const c=Math.cos(b), s=Math.sin(b); return add(add(scale(v,c), scale(cross(k,v),s)), scale(k,(1-c)*(k[0]*v[0]+k[1]*v[1]+k[2]*v[2]))); }
/** Rotate offsets (off2,off3) in local 2–3 plane by beta (deg) */
function rot23(off2, off3, betaDeg){
  const b = betaDeg*Math.PI/180;
  const c = Math.cos(b), s = Math.sin(b);
  return { off2: off2*c - off3*s, off3: off2*s + off3*c };
}

// ---------- I-beam geometry → three RECTs with offsets ----------
function iBeamToRECTs(section, unitsLen="mm"){
  // geometry: h, b, tw, tf (r ignored here)
  const g = section.geometry || {};
  const h  = conv.length(Number(g.h.value),  g.h.unit  || unitsLen);   // overall depth
  const b  = conv.length(Number(g.b.value),  g.b.unit  || unitsLen);   // flange width
  const tw = conv.length(Number(g.tw.value), g.tw.unit || unitsLen);   // web thickness
  const tf = conv.length(Number(g.tf.value), g.tf.unit || unitsLen);   // flange thickness

  // RECT data line in CCX: "b, h" where b ↔ local 3 (width), h ↔ local 2 (height)
  // Base offsets for β=0 (local 2 up, local 3 to the right):
  const yOff = h/2 - tf/2;
  return [
    { name: "FLANGE_BOTTOM", b3: b,  h2: tf,      off2: -yOff, off3: 0 },
    { name: "WEB",           b3: tw, h2: Math.max(h-2*tf,1e-12), off2: 0,     off3: 0 },
    { name: "FLANGE_TOP",    b3: b,  h2: tf,      off2: +yOff, off3: 0 },
  ];
}

// ---------- Core converter ----------
function convertJsonToInp(model){
  const units = model.units || {};
  const LEN_U   = units.length || "mm";

  const out = [];
  out.push("** Generated by json2inp (JS, mm-N-s-K)");

  // *NODE
  out.push("*NODE, NSET=Nall");
  for(const n of (model.nodes||[])){
    const id=+n.nodeId, x=conv.length(+n.x, LEN_U), y=conv.length(+n.y, LEN_U);
    out.push(`${id}, ${fmt(x)}, ${fmt(y)}, 0`);
  }

  // *NSET from supports
  const supportNodes = Array.from(new Set((model.supports || []).map(s => +s.nodeId)));
  if (supportNodes.length) {
    out.push("*NSET, NSET=RF");
    out.push(supportNodes.join(", "));
  }

  // *ELEMENT
  const elements = model.elements || [];
  const groups = [];
  const gmap = {};
  let hasTruss = false;
  for (const e of elements) {
    const st = (e.structuralType || 'beam').toLowerCase();
    if (st === 'truss') hasTruss = true;
    const key = `${e.sectionId}_${e.materialId}_${st}`;
    let g = gmap[key];
    if (!g) {
      g = gmap[key] = { name: key, st, material: e.materialId, sectionId: e.sectionId, elems: [] };
      groups.push(g);
    }
    g.elems.push(e);
  }
  if (hasTruss) {
    out.push('*USER ELEMENT, TYPE=U1, NODES=2, INTEGRATION POINTS=2, MAXDOF=2');
  }
  for (const g of groups) {
    let etype = 'U1';
    if (g.st === 'truss') etype = 'T3D2';
    else if (g.st !== 'beam') etype = 'U1';
    out.push(`*ELEMENT, TYPE=${etype}, ELSET=${g.name}`);
    for (const e of g.elems) {
      out.push(`${+e.elemId}, ${+e.nodeId1}, ${+e.nodeId2}`);
    }
  }

  // *MATERIAL
  for (const m of (model.materials || [])) {
    const p = m.properties || {};
    const em = p.elasticModulus || {};
    const pr = p.poissonRatio || {};
    const de = p.density || {};
    const E   = conv.E(+em.value, em.unit || 'MPa');
    const nu  = +pr.value;
    const rho = conv.rho(+de.value, de.unit || 'kg/m^3');
    out.push(`*MATERIAL, NAME=${JSON.stringify(m.id)}`);
    out.push('*ELASTIC');
    out.push(`${fmt(E)}, ${fmt(nu)}`);
    out.push('*DENSITY');
  out.push(fmt(rho));
  }

  // Sections for beams and trusses
  const secMap = {};
  for (const s of (model.sections || [])) secMap[s.id] = s;
  let elsetIdx = 0;
  for (const g of groups) {
    const sec = secMap[g.sectionId] || {};
    const props = sec.properties || {};
    const A = conv.area(props.A?.value || 0, props.A?.unit || (LEN_U+"^2"));
    if (g.st === 'beam') {
      const Iy = conv.inertia(props.Iy?.value || 0, props.Iy?.unit || (LEN_U+"^4"));
      const Iz = conv.inertia(props.Iz?.value || 0, props.Iz?.unit || (LEN_U+"^4"));
      out.push(`*ELSET, ELSET=${g.sectionId}_${g.material}`);
      out.push(`${++elsetIdx}`);
      out.push(`*BEAM SECTION, ELSET=${g.name}, MATERIAL=${g.material}, SECTION=GENERAL`);
      out.push(`${A.toFixed(4)}, ${Iy.toFixed(4)}, 0.0, ${Iz.toFixed(4)}, 10000`);
      out.push('0, 0, -1');
    } else if (g.st === 'truss') {
      out.push(`*ELSET, ELSET=${g.name}`);
      out.push(`${++elsetIdx}`);
      out.push(`*SOLID SECTION, ELSET=${g.name}, MATERIAL=${g.material}`);
      out.push(`${A.toFixed(4)}`);
    }
  }

  return out.join("\n")+"\n";
}

if (typeof module !== "undefined" && module.exports) {
  module.exports = { convertJsonToInp, iBeamToRECTs };
} else {
  global.convertJsonToInp = convertJsonToInp;
  global.iBeamToRECTs = iBeamToRECTs;
}

/*
Usage:
import { readFileSync, writeFileSync } from "node:fs";
const data = JSON.parse(readFileSync("beam_kN_m.json","utf8"));
const inp  = convertJsonToInp(data);
writeFileSync("model.inp", inp, "utf8");
*/

})(typeof window !== "undefined" ? window : globalThis);
