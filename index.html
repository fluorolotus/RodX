<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Графический интерфейс для расчетных моделей</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Общие стили для body */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Скрывает полосы прокрутки, если содержимое выходит за границы */
            display: flex;
            flex-direction: column; /* Элементы (topBar, main-content-area, bottomBar) располагаются вертикально */
            height: 100vh; /* Body занимает всю высоту viewport */
            background-color: #f0f2f5; /* Цвет фона для всего приложения */
        }

        /* Стили для верхней и нижней панелей */
        #topBar, #bottomBar {
            flex-shrink: 0; /* Эти панели не должны сжиматься по высоте */
        }

        /* Основная область содержимого: Flex-контейнер для левой панели и области холста */
        .main-content-area {
            display: flex; /* Элементы (properties-panel и canvas-container) располагаются горизонтально */
            flex-grow: 1; /* Занимает всю оставшуюся высоту между topBar и bottomBar */
			overflow: hidden; /* ДОБАВЬТЕ ЭТУ СТРОКУ: Скрывает переполнение, если дочерние элементы выходят за границы */
							/* Это предотвратит растягивание .main-content-area по высоте, если его flex-элементы пытаются стать выше. */
        }

        /* Левая панель свойств */
        .properties-panel {
            width: 25vw; /* Занимает 1/4 ширины viewport */
            min-width: 250px; /* Минимальная ширина, чтобы контент не сжимался слишком сильно */
            
            background-color: #f0f2f5;
            border-right: 1px solid #d1d5db;
            padding: 15px;
            box-sizing: border-box; /* Учитываем padding в ширине */
            overflow-y: auto; /* Прокрутка, если содержимое не помещается */
            flex-shrink: 0; /* Не позволяет панели сжиматься по ширине */
        }

        /* Контейнер для холста (рабочая область) */
        .canvas-container {
            flex-grow: 1; /* Занимает всю оставшуюся ширину (3/4) */
            position: relative; /* Важно для позиционирования тултипа и контекстного меню */
            overflow: hidden; /* Скрывает содержимое, выходящее за границы */
            background-color: #fff;
            /* width: 75vw; // Этот класс больше не нужен, flex-grow справится */
            /* height: 100%; // Этот класс больше не нужен, flex-grow справится */
        }
        
        /* Сам холст */
        canvas { 
            display: block; 
            background-color: #fff; 
            cursor: crosshair; 
            width: 100%; /* Холст занимает 100% ширины своего родителя */
            height: 100%; /* Холст занимает 100% высоты своего родителя */
        }

        /* Стили для элементов внутри панелей */
        .properties-panel h3 {
            font-size: 1.2em;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
        }
        .property-group {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background-color: #fff;
        }
        .property-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }
        .property-group input[type="number"] {
            width: calc(100% - 16px); /* Учитываем padding */
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1em;
            margin-bottom: 10px;
        }
        .property-group input[type="number"]:focus {
            border-color: #007bff;
            outline: none;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }
        .property-group .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .property-group .checkbox-group input[type="checkbox"] {
            margin-right: 8px;
            transform: scale(1.2);
        }

        .restriction-icon-btn {
            background-color: #e2e8f0;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            padding: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 50px; /* Фиксированный размер для кнопок */
            height: 50px;
            transition: all 0.2s ease-in-out;
            margin: 4px; /* Небольшой отступ между кнопками */
        }
        .restriction-icon-btn:hover {
            background-color: #d1d9e2;
            border-color: #a0aec0;
        }
        .restriction-icon-btn.active {
            background-color: #a7d9f7; /* Цвет активной кнопки */
            border-color: #3490dc;
            box-shadow: 0 0 0 3px rgba(52, 144, 220, 0.4);
        }
        .restriction-icon-btn img {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Убедиться, что SVG вписывается */
        }
        .restriction-icon-btn .no-restriction-text {
            font-size: 2em; /* Размер символа "Ø" */
            font-weight: bold;
            color: #666;
        }
		
        .visibility-toggle-btn {
            background-color: #e2e8f0;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            padding: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            transition: background-color 0.2s, border-color 0.2s;
            margin: 2px;
        }
        .visibility-toggle-btn:hover {
            background-color: #d1d9e2;
            border-color: #a0aec0;
        }
        .visibility-toggle-btn.active {
            background-color: #a7d9f7;
            border-color: #3490dc;
            box-shadow: 0 0 0 3px rgba(52,144,220,0.4);
        }
        .visibility-toggle-btn img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
		.load-input-group {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 8px; /* Добавляем отступ между элементами группы */
        }
        .load-input-group input[type="number"] {
            flex-grow: 1; /* Позволяет полю ввода занимать всё доступное пространство */
            margin-bottom: 0; /* Убираем нижний отступ, так как он уже есть в flexbox gap */
        }
        .load-input-group button {
            padding: 6px 12px;
            background-color: #4CAF50; /* Зеленая кнопка */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .load-input-group button:hover {
            background-color: #45a049;
        }
        .load-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid #eee;
        }
        .load-item:last-child {
            border-bottom: none; /* Убираем границу у последнего элемента */
        }
        .load-item button {
            background-color: #f44336; /* Красная кнопка удаления */
            padding: 4px 8px;
            font-size: 0.8em;
        }
        .load-item button:hover {
            background-color: #da190b;
        }

        /* Стили для элементов управления в нижней панели */
        #bottomBar label, #bottomBar input, #bottomBar select, #bottomBar button {
            font-size: 14px;
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid #b0b0b0; /* Светлее для темного фона */
            color: #b0b0b0; /* Цвет текста для светлых элементов */
        }
        #bottomBar select, #bottomBar input {
            /*background-color: #f0f2f5; /* Светлый фон для полей ввода/выбора */
        }
        #bottomBar input[type="number"] { width: 60px; text-align: center;}
        #bottomBar input[type="checkbox"] { margin-right: 3px; transform: scale(1.1); }
        #bottomBar button { 
            background-color: #007bff; 
            color:white; 
            cursor: pointer; 
            border-color: #007bff;
        }
        #bottomBar button:hover { background-color: #0056b3; border-color: #0056b3; }
        #bottomBar #clearCanvasBtn { background-color: #dc3545; border-color: #dc3545;}
        #bottomBar #clearCanvasBtn:hover { background-color: #c82333; border-color: #bd2130;}


        /* Стили для тултипа и контекстного меню */
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
            pointer-events: none;
            white-space: pre;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .context-menu {
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.15);
            padding: 5px 0;
            z-index: 1001;
            min-width: 160px;
        }
        .context-menu-item {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
        }
        .context-menu-item:hover {
            background-color: #f0f0f0;
        }

        /* Модальное окно */
        #materialsModal {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.6);
            /*display: none;*/
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        #materialsModal > div { /* Внутренний контейнер модального окна */
            background-color: #fff;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 11/12; /* Tailwind-класс */
            max-width: 600px; /* Максимальная ширина */
            max-height: 90vh;
            overflow-y: auto;
        }

        #sectionsModal {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.6);
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        #sectionsModal > div {
            background-color: #fff;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

    </style>
</head>
<body>

    <!-- Верхняя панель инструментов -->
    <div id="topBar" class="bg-gray-800 text-white h-16 p-3 flex justify-between items-center z-100">
        <h1 class="text-xl font-bold ml-2">Графический интерфейс</h1>
        <div class="flex items-center space-x-4 mr-4">
            <!-- Кнопка "Материалы" -->
            <button id="openMaterialsModalBtn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition duration-150 ease-in-out">
                Материалы
            </button>
            <!-- Кнопка "Сечения" -->
            <button id="openSectionsModalBtn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition duration-150 ease-in-out">
                Сечения
            </button>
            <button id="toggleNodeNumbersBtn" class="visibility-toggle-btn active" title="Переключить номера узлов">
                <img src="icons/icon_nodeNumberVisibility.svg" alt="Node numbers">
            </button>
            <button id="toggleLineNumbersBtn" class="visibility-toggle-btn active" title="Переключить номера элементов">
                <img src="icons/icon_lineNumberVisibility.svg" alt="Line numbers">
            </button>
        </div>
    </div>

    <!-- Основное содержимое приложения -->
    <!-- flex-grow: 1 позволяет этой области занять всю оставшуюся высоту -->
    <div class="main-content-area flex flex-grow">
        <!-- Левая панель свойств -->
        <div id="propertiesPanel" class="properties-panel">
            <h3>Свойства элементов</h3>
            <div id="nodePropertiesContent">
                <p>Выберите элемент для просмотра его свойств.</p>
                <!-- Содержимое nodePropertiesContent будет динамически генерироваться JS -->
            </div>
        </div>

        <!-- Область для холста (рабочая область) -->
        <div class="canvas-container" id="canvasContainer">
            <canvas id="drawingCanvas"></canvas>
        </div>
    </div>

    <!-- Модальное окно для материалов -->
    <div id="materialsModal" class="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center hidden z-50">
        <!-- Основной контейнер модального окна, увеличена максимальная ширина -->
        <div class="bg-white p-8 rounded-lg shadow-xl w-11/12 md:w-5/6 lg:max-w-4xl max-h-[90vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold">Управление материалами</h2>
                <button id="closeMaterialsModalBtn" class="text-gray-500 hover:text-gray-700 text-3xl leading-none">&times;</button>
            </div>
            
            <!-- Сетка для разделения на две колонки: выбор/пользовательский материал слева, свойства/материалы в модели справа -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <!-- ЛЕВАЯ КОЛОНКА: Выбор материала и поля пользовательского материала -->
                <div>
                    <h3 class="text-xl font-bold mb-4">Выбор материала</h3>

                    <div class="mb-4">
                        <label for="materialTypeSelect" class="block text-gray-700 text-sm font-bold mb-2">Тип материала:</label>
                        <select id="materialTypeSelect" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                            <!-- Опции будут заполняться из JS (или уже есть статика) -->

                        </select>
                    </div>

                    <div class="mb-4">
                        <label for="materialStandardSelect" class="block text-gray-700 text-sm font-bold mb-2">Стандарт:</label>
                        <select id="materialStandardSelect" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                            <!-- Опции будут заполняться из JS -->
                        </select>
                    </div>
                    
                    <div class="mb-4">
                        <label for="materialClassSelect" class="block text-sm font-medium text-gray-700">Класс/Марка:</label>
                        <select id="materialClassSelect" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md shadow-sm">
                            <!-- Опции будут заполняться из JS -->
                        </select>
                    </div>

                    <!-- Поля для пользовательского материала (скрыты по умолчанию) -->
                    <div id="customMaterialFields" class="hidden mt-6 p-4 border rounded-md bg-gray-50">
                        <h3 class="text-lg font-semibold mb-2">Добавить свой материал</h3>
                        <label for="customMaterialName" class="block text-sm font-medium text-gray-700">Пользовательское имя:</label>
                        <input type="text" id="customMaterialName" placeholder="Название материала" class="mt-1 block w-full pl-3 pr-3 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md shadow-sm mb-2">
                        <label for="customElasticModulus" class="block text-sm font-medium text-gray-700">Модуль упругости (МПа):</label>
                        <input type="number" id="customElasticModulus" placeholder="Например, 2.1e11" class="mt-1 block w-full pl-3 pr-3 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md shadow-sm mb-2">
                        <label for="customDensity" class="block text-sm font-medium text-gray-700">Плотность (кг/м³):</label>
                        <input type="number" id="customDensity" placeholder="Например, 7850" class="mt-1 block w-full pl-3 pr-3 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md shadow-sm mb-2">
                        <label for="customPoissonRatio" class="block text-sm font-medium text-gray-700">Коэффициент Пуассона:</label>
                        <input type="number" id="customPoissonRatio" step="0.01" placeholder="Например, 0.3" class="mt-1 block w-full pl-3 pr-3 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md shadow-sm">
                        
                        <button id="saveCustomMaterialBtn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded mt-4">
                            Сохранить пользовательский материал
                        </button>
                    </div>

                    <button id="addMaterialToModelBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded mt-4 w-full">
                        Добавить выбранный материал в модель
                    </button>
                </div>

                <!-- ПРАВАЯ КОЛОНКА: Свойства выбранного материала и Список материалов в модели -->
                <div>
                    <h3 class="text-xl font-bold mb-4">Свойства выбранного материала</h3>
                    <div id="selectedMaterialProperties" class="bg-gray-100 p-4 rounded-md shadow-inner mb-6">
                        <p class="font-semibold text-gray-800 mb-2">Имя: <span id="propName" class="font-normal text-gray-700 italic">Не выбрано</span></p>
                        <p class="text-gray-700 text-sm">Тип: <span id="propType" class="font-normal"></span></p>
                        <p class="text-gray-700 text-sm mb-4">Стандарт: <span id="propStandard" class="font-normal"></span></p>
                        
                        <div class="border-t border-gray-300 pt-4 mt-4">
                            <p class="text-gray-700"><span class="font-medium">Модуль упругости (E):</span> <span id="propElasticModulus" class="font-normal"></span> <span id="unitElasticModulus" class="text-xs text-gray-500"></span></p>
                            <p class="text-gray-700"><span class="font-medium">Плотность (ρ):</span> <span id="propDensity" class="font-normal"></span> <span id="unitDensity" class="text-xs text-gray-500"></span></p>
                            <p class="text-gray-700"><span class="font-medium">Коэффициент Пуассона (ν):</span> <span id="propPoissonRatio" class="font-normal"></span> <span id="unitPoissonRatio" class="text-xs text-gray-500"></span></p>
                        </div>
                    </div>

                    <!-- Существующий блок "Материалы в модели" -->
                    <div>
                        <h3 class="text-xl font-bold mb-2">Материалы в модели:</h3>
                        <ul id="modelMaterialList" class="border rounded-md p-3 bg-white max-h-48 overflow-y-auto">
                            <li id="noMaterialsMessage" class="text-gray-500 italic">Нет материалов в модели.</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Кнопки Закрыть снизу, вне сетки -->
            <div class="flex justify-end space-x-3 mt-4">
                <button id="closeMaterialsModalBtnBottom" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded transition duration-150 ease-in-out">
                    Закрыть
                </button>
            </div>
        </div>
    </div>

    <!-- Модальное окно для сечений -->
    <div id="sectionsModal" class="fixed inset-0 bg-gray-600 bg-opacity-75 flex items-center justify-center hidden z-50">
        <div class="bg-white p-8 rounded-lg shadow-xl">
            <div class="mb-4">
                <label for="sectionTypeSelect" class="block text-gray-700 text-sm font-bold mb-2">Тип сечения:</label>
                <select id="sectionTypeSelect" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline"></select>
            </div>
            <div class="mb-4">
                <label for="sectionStandardSelect" class="block text-gray-700 text-sm font-bold mb-2">Стандарт:</label>
                <select id="sectionStandardSelect" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline"></select>
            </div>
            <div class="mb-4">
                <label for="sectionNameSelect" class="block text-gray-700 text-sm font-bold mb-2">Сечение:</label>
                <select id="sectionNameSelect" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline"></select>
            </div>
            <button id="closeSectionsModalBtn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded">
                Закрыть
            </button>
        </div>
    </div>

    <!-- Нижняя панель управления -->
    <div id="bottomBar" class="bg-gray-800 text-white h-16 p-3 flex justify-center items-center space-x-8 z-100">
        <!-- Кнопки Сохранить/Загрузить/Очистить -->
        <div class="flex items-center space-x-4">
            <button id="saveModelBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded transition duration-150 ease-in-out">Сохранить</button>
            <button id="loadModelBtn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded transition duration-150 ease-in-out">Загрузить</button>
            <input type="file" id="fileInput" accept=".json" class="hidden">
            <button id="clearCanvasBtn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded transition duration-150 ease-in-out">Очистить все</button>
        </div>

        <!-- Управление сеткой -->
        <div class="flex items-center space-x-2 ml-8">
            <label for="divisions">Делений на ед.:</label>
            <input type="number" id="divisions" value="4" min="1" max="20"
                   class="w-20 bg-gray-700 border border-gray-600 text-white text-sm rounded-md px-2 py-1 focus:outline-none focus:ring-blue-500 focus:border-blue-500">
        </div>
        <div class="flex items-center space-x-2">
            <input type="checkbox" id="snapToGrid" class="form-checkbox h-4 w-4 text-blue-600 rounded">
            <label for="snapToGrid" class="text-white text-sm">Привязка к сетке</label>
        </div>
        
        <!-- Управление единицами измерения -->
        <div class="flex items-center space-x-2 ml-8">
            <label for="unitsSelect" class="text-white text-sm">Ед. измерения:</label>
            <select id="unitsSelect" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-md px-2 py-1 focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                <option value="m">м</option>
                <option value="cm">см</option>
                <option value="mm">мм</option>
                <option value="in">дюймы</option>
                <option value="ft">фут</option>
            </select>
        </div>
        <div class="flex items-center space-x-2">
            <label for="forceUnitsSelect" class="text-white text-sm">Ед. силы:</label>
            <select id="forceUnitsSelect" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-md px-2 py-1 focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                <option value="N">Н</option>
                <option value="kN">кН</option>
                <option value="lbf">фунт-сила</option>
                <option value="kg">кг</option>
                <option value="t">т</option>
                <option value="kips">kips</option>
            </select>
        </div>
        <div class="flex items-center space-x-2">
            <label for="unitPairsSelect" class="text-white text-sm">Пары ед.:</label>
            <select id="unitPairsSelect" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-md px-2 py-1 focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                <option value="none">Польз.</option>
                <option value="metric_t_m">т, м</option>
                <option value="metric_standard">кН, м</option>
                <option value="metric_mm_N">Н, мм</option>
                <option value="imperial_ft_lbf">lbf, фут</option>
                <option value="imperial_in_lbf">lbf, дюйм</option>
                <option value="imperial_in_kips">kips, дюйм</option>
            </select>
        </div>
    </div>

    <!-- Контекстное меню и тултип -->
    <div id="customContextMenu" class="context-menu hidden">
        <div id="deleteNodeItem" class="context-menu-item">Удалить узел</div>
        <div id="deleteLineItem" class="context-menu-item">Удалить линию</div>
    </div>
    <div id="tooltip" class="tooltip hidden"></div>

    <script>
        // DOM Elements - ОБНОВЛЕННЫЕ ССЫЛКИ ПОСЛЕ ПЕРЕМЕЩЕНИЯ В BOTTOMBAR
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const canvasContainer = document.getElementById('canvasContainer');
        
        // Элементы, перемещенные в bottomBar
        const divisionsInput = document.getElementById('divisions');
        const snapToGridCheckbox = document.getElementById('snapToGrid');
        const clearCanvasBtn = document.getElementById('clearCanvasBtn');
        const unitsSelect = document.getElementById('unitsSelect'); // ID изменен
        const forceUnitsSelect = document.getElementById('forceUnitsSelect'); // ID изменен
        const unitPairsSelect = document.getElementById('unitPairsSelect'); // ID изменен
        const saveModelBtn = document.getElementById('saveModelBtn'); // Перемещен
        const loadModelBtn = document.getElementById('loadModelBtn'); // Перемещен
        const fileInput = document.getElementById('fileInput'); // Перемещен

        const tooltip = document.getElementById('tooltip');
        const customContextMenu = document.getElementById('customContextMenu');
        const deleteNodeItem = document.getElementById('deleteNodeItem');
        const deleteLineItem = document.getElementById('deleteLineItem');
        
        // Элементы propertiesPanel
        const propertiesPanel = document.getElementById('propertiesPanel');
        const nodePropertiesContent = document.getElementById('nodePropertiesContent');
        
        // Application State
        let nodes = [];
        let lines = [];
        let restrictions = [];
        let nextNodeId = 1;
        let nextElemId = 1; 
		let nodeLoads = [];
        let nextLoadId = 1;
		let elementLoads = [];
        let nextElementLoadId = 1;
		
		let selectedElements = [];
		
		// --- Глобальные переменные для работы с материалами ---
        let allMaterials = []; // Здесь будут храниться все загруженные материалы
        // Эту переменную будем инициализировать в DOMContentLoaded
        let materialListContainer = null; 
		
		// Глобальные флаги видимости для элементов канваса (НОВОЕ)
		let showNodeIds = true;    // Показывать ID узлов по умолчанию
		let showElementIds = true; // Показывать ID элементов (линий) по умолчанию

        let scale = 50; 
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let lastPanX, lastPanY;

        let divisionsPerUnit = parseInt(divisionsInput.value);
        let snapToGrid = true; 
        let currentUnit = unitsSelect.value;
        let currentForceUnit = forceUnitsSelect.value;
        let currentTemperatureUnit = 'C'; 
        let currentTimeUnit = 's'; 
        
        // Коэффициенты конвертации единиц длины (базовая единица: метры 'm')
        const lengthUnitConversions = { 
            'm': 1,    
            'cm': 0.01,
            'mm': 0.001,
            'in': 0.0254,
            'ft': 0.3048
        };

        // Коэффициенты конвертации единиц силы: сколько Ньютонов в ОДНОЙ единице (базовая единица: Ньютоны 'N')
        const forceUnitConversions = {
            'N':    1,
            'kN':   1000,
            'kg':   9.80665, 
            't':    9806.65, 
            'lbf':  4.44822,
            'kips': 4448.22
        };
		
		// Определения наборов единиц
        const unitPairConversions = {
            'metric_standard': { length: 'm', force: 'kN' },
            'metric_mm_N': { length: 'mm', force: 'N' },
            'imperial_ft_lbf': { length: 'ft', force: 'lbf' },
            'imperial_in_lbf': { length: 'in', force: 'lbf' },
			'imperial_in_kips': { length: 'in', force: 'kips' },
			'metric_t_m': { length: 'm', force: 't' }
        };
		
		let currentUnitPair = unitPairsSelect.value;
		
		// Вспомогательная функция для обновления поля "Пары ед."
        function updateUnitPairsSelect() {
            const currentLengthUnit = unitsSelect.value;
            const currentForceUnit = forceUnitsSelect.value;
            
            let foundMatch = false;
            for (const pairKey in unitPairConversions) {
                const pair = unitPairConversions[pairKey];
                if (pair.length === currentLengthUnit && pair.force === currentForceUnit) {
                    unitPairsSelect.value = pairKey;
                    foundMatch = true;
                    break;
                }
            }

            if (!foundMatch) {
                unitPairsSelect.value = 'none'; // Если не найдено соответствие, устанавливаем "Пользовательский"
            }
        }
        
        let firstNodeForLine = null;
        let hoveredElement = null;
        let contextMenuTarget = null;
        let selectedNode = null;
		let selectedElement = null;

        let mouse = { x: 0, y: 0, worldX: 0, worldY: 0, snappedX: 0, snappedY: 0 }; 

        // Иконки закреплений и их свойства (dx, dy, dr)
        const restrictionTypes = {
            "none":      { dx: 0, dy: 0, dr: 0, icon: null, label: "Нет" },
            "pinned":    { dx: 1, dy: 1, dr: 0, icon: "icon_Pinned.svg", label: "Шарнирная (Pin)" },
            "rolled-x":  { dx: 0, dy: 1, dr: 0, icon: "icon_Rolled-X.svg", label: "Подвижная по X" },
            "rolled-y":  { dx: 1, dy: 0, dr: 0, icon: "icon_Rolled-Y.svg", label: "Подвижная по Y" },
            "fixed":     { dx: 1, dy: 1, dr: 1, icon: "icon_Fixed.svg", label: "Защемление (Fixed)" },
            "sleeve-x":  { dx: 0, dy: 1, dr: 1, icon: "icon_Sleeve-X.svg", label: "Обойма по X" },
            "sleeve-y":  { dx: 1, dy: 0, dr: 1, icon: "icon_Sleeve-Y.svg", label: "Обойма по Y" }
        };

        // Функция для сохранения модели в JSON
        function saveModel() {
            const modelData = {
                nodes: nodes,
                lines: lines,
                restrictions: restrictions,
                nodeLoads: nodeLoads,
                elementLoads: elementLoads,
				materials: modelMaterials,
                units: {
                    length: currentUnit,
                    force: currentForceUnit,
                    temperature: currentTemperatureUnit,
                    time: currentTimeUnit
                }
            };
            
            console.log("Модель данных перед сохранением:", modelData);
            console.log("Единицы измерения в модели:", modelData.units);

            const jsonString = JSON.stringify(modelData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'model.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.log("Модель сохранена в model.json");
        }

		async function loadModel(jsonFileContent) {
            try {
                const modelData = JSON.parse(jsonFileContent);

                nodes = modelData.nodes || [];
                lines = modelData.lines || [];
                restrictions = modelData.restrictions || [];
                nodeLoads = modelData.nodeLoads || [];
                elementLoads = modelData.elementLoads || [];
				
				// НОВОЕ: Загружаем материалы модели
                modelMaterials = modelData.materials || []; // <-- Добавляем эту строку
                // НОВОЕ: Отрисовываем список загруженных материалов в модальном окне
                renderModelMaterialsList(); // <-- Добавляем эту строку

                if (modelData.units) {
                    const loadedLengthUnit = modelData.units.length;
                    const loadedForceUnit = modelData.units.force;
                    const loadedTemperatureUnit = modelData.units.temperature || 'C';
                    const loadedTimeUnit = modelData.units.time || 's';

                    currentTemperatureUnit = loadedTemperatureUnit;
                    currentTimeUnit = loadedTimeUnit;

                    if (unitsSelect.value !== loadedLengthUnit) {
                        unitsSelect.value = loadedLengthUnit;
                        unitsSelect.dispatchEvent(new Event('change'));
                    } else {
                        currentUnit = loadedLengthUnit;
                        updateUnitPairsSelect();
                        updateForceUnitDisplay();
                    }

                    if (forceUnitsSelect.value !== loadedForceUnit) {
                        forceUnitsSelect.value = loadedForceUnit;
                        forceUnitsSelect.dataset.previousValue = loadedForceUnit;
                        forceUnitsSelect.dispatchEvent(new Event('change'));
                    } else {
                        currentForceUnit = loadedForceUnit;
                        updateUnitPairsSelect();
                        updateForceUnitDisplay();
                    }

                } else {
                    currentTemperatureUnit = 'C';
                    currentTimeUnit = 's';
                }

                nextNodeId = nodes.length > 0 ? Math.max(...nodes.map(n => n.node_id)) + 1 : 1;
                nextElemId = lines.length > 0 ? Math.max(...lines.map(l => l.elem_id)) + 1 : 1;
                nextLoadId = nodeLoads.length > 0 ? Math.max(...nodeLoads.map(l => l.load_id)) + 1 : 1;
                nextElementLoadId = elementLoads.length > 0 ? Math.max(...elementLoads.map(l => l.load_id)) + 1 : 1;

                selectedNode = null;
                selectedElement = null;
                firstNodeForLine = null;

                if ((modelData.units && unitsSelect.value === modelData.units.length && forceUnitsSelect.value === modelData.units.force) || !modelData.units) {
                    updatePropertiesPanel();
                    draw();
                }

                console.log("Модель успешно загружена.");
            } catch (error) {
                console.error("Ошибка при загрузке модели:", error);
                console.error("Не удалось загрузить модель. Проверьте формат файла.");
            }
        }
		
		function toggleMaterialsModal() {
			materialsModal.classList.toggle('hidden');
		}

		openMaterialsModalBtn.addEventListener('click', toggleMaterialsModal);
		closeMaterialsModalBtn.addEventListener('click', toggleMaterialsModal);
		closeMaterialsModalBtnBottom.addEventListener('click', toggleMaterialsModal);

		materialsModal.addEventListener('click', (e) => {
			if (e.target === materialsModal) {
				toggleMaterialsModal();
			}
		});		
		
		
		
        function init() {
            snapToGridCheckbox.checked = snapToGrid; 
            resizeCanvas();
            addEventListeners();
            
            forceUnitsSelect.value = 'kN'; 
            forceUnitsSelect.dataset.previousValue = 'kN';
            
            currentUnit = unitsSelect.value;
            currentForceUnit = forceUnitsSelect.value;
            
            updateUnitPairsSelect(); 
            updateForceUnitDisplay(); 
        }

        function resizeCanvas() {
            canvas.width = canvasContainer.clientWidth;
            canvas.height = canvasContainer.clientHeight;
            panX = canvas.width / 2;
            panY = canvas.height / 2; 
            draw();
        }

        // Coordinate Transformations (world coords are in currentUnit, positive Y is UP)
        function screenToWorld(screenX, screenY) {
            return {
                x: (screenX - panX) / scale,
                y: -(screenY - panY) / scale 
            };
        }

        function worldToScreen(worldX, worldY) { 
            return {
                x: worldX * scale + panX,
                y: worldY * (-scale) + panY 
            };
        }
        
        // Snapping Logic (snaps to sub-grid of currentUnit)
        function getSnappedCoordinates(worldX_currentUnit, worldY_currentUnit) { 
            if (!snapToGrid) return { x: worldX_currentUnit, y: worldY_currentUnit };
            const gridSize_currentUnit = 1 / divisionsPerUnit;
            return {
                x: Math.round(worldX_currentUnit / gridSize_currentUnit) * gridSize_currentUnit,
                y: Math.round(worldY_currentUnit / gridSize_currentUnit) * gridSize_currentUnit
            };
        }
        
        // Unit Conversion Helper (для длины)
        function convertUnits(value, fromUnit, toUnit) {
            if (fromUnit === toUnit) return value;
            if (!lengthUnitConversions[fromUnit] || !lengthUnitConversions[toUnit]) {
                console.warn(`Неизвестные единицы длины: ${fromUnit} или ${toUnit}`);
                return value;
            }
            // Сначала конвертируем в метры (базовая единица для длины)
            const valueInMeters = value * lengthUnitConversions[fromUnit];
            // Затем конвертируем из метров в целевую единицу
            return valueInMeters / lengthUnitConversions[toUnit];
        }

        // Новая универсальная функция конвертации силы
        // Конвертирует 'value' из 'fromUnit' в 'toUnit'
        function convertForce(value, fromUnit, toUnit) {
            if (fromUnit === toUnit || !forceUnitConversions[fromUnit] || !forceUnitConversions[toUnit]) {
                return value;
            }
            const valueInNewtons = value * forceUnitConversions[fromUnit];
            return valueInNewtons / forceUnitConversions[toUnit];
        }

        // НОВАЯ ФУНКЦИЯ: Универсальная функция конвертации моментов
        function convertMoment(value, fromForceUnit, fromLengthUnit, toForceUnit, toLengthUnit) {
            if (!forceUnitConversions[fromForceUnit] || !forceUnitConversions[toForceUnit] ||
                !lengthUnitConversions[fromLengthUnit] || !lengthUnitConversions[toLengthUnit]) {
                console.warn("Неизвестные единицы для конвертации момента.");
                return value;
            }

            const momentInNewtonMeters = value * forceUnitConversions[fromForceUnit] * lengthUnitConversions[fromLengthUnit];
            const convertedValue = momentInNewtonMeters / (forceUnitConversions[toForceUnit] * lengthUnitConversions[toLengthUnit]);
            
            return convertedValue;
        }
		
		// НОВАЯ ФУНКЦИЯ: Универсальная функция конвертации распределенных нагрузок (F/L)
        function convertDistributedForce(value, fromForceUnit, fromLengthUnit, toForceUnit, toLengthUnit) {
            if (!forceUnitConversions[fromForceUnit] || !forceUnitConversions[toForceUnit] ||
                !lengthUnitConversions[fromLengthUnit] || !lengthUnitConversions[toLengthUnit]) {
                console.warn(`Неизвестные единицы для конвертации распределенной нагрузки: ${fromForceUnit}/${fromLengthUnit} -> ${toForceUnit}/${toLengthUnit}`);
                return value;
            }

            const valueInNewtonsPerMeter = (value * forceUnitConversions[fromForceUnit]) / lengthUnitConversions[fromLengthUnit];
            const convertedValue = valueInNewtonsPerMeter / (forceUnitConversions[toForceUnit] / lengthUnitConversions[toLengthUnit]);
            
            return convertedValue;
        }

        // Вспомогательная функция для получения текста единицы измерения
        // Возвращает единицу измерения, если она не 'none', иначе пустую строку.
        function getUnitText(unit) {
            return (unit && unit !== 'none') ? unit : '';
        }

        // Обновляет текстовые спаны с единицами измерения на панели свойств
        function updateForceUnitDisplay() {
            const selectedUnit = forceUnitsSelect.value; 
            const selectedMomentUnit = selectedUnit + '*' + unitsSelect.value;

            const displayFx = document.getElementById('currentForceUnitDisplay_Fx');
            const displayFy = document.getElementById('currentForceUnitDisplay_Fy');
            const displayM = document.getElementById('currentForceUnitDisplay_M');
            const displayqX = document.getElementById('currentDistributedForceUnitDisplay_qX'); // For distributed loads
            const displayqY = document.getElementById('currentDistributedForceUnitDisplay_qY'); // For distributed loads

            if (displayFx) displayFx.textContent = selectedUnit;
            if (displayFy) displayFy.textContent = selectedUnit;
            if (displayM) displayM.textContent = selectedMomentUnit;
            if (displayqX) displayqX.textContent = `${selectedUnit}/${unitsSelect.value}`; // For distributed loads
            if (displayqY) displayqY.textContent = `${selectedUnit}/${unitsSelect.value}`; // For distributed loads
            
            updatePropertiesPanel(); 
            draw();
        }
		
		// Drawing Functions
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(panX, panY);
            ctx.scale(scale, -scale); // Важно: Y-ось инвертирована здесь!

            drawGrid();
            drawAxes();
			drawDistributedLoads();
            drawLines();
            drawRestrictions();
            drawNodes();        

            drawNodeLoads();
			
            
            ctx.restore(); // Восстанавливаем исходную матрицу трансформации
            drawCursorCircle();
            updateTooltip();
        }
		
		// ====================================================================
		
		// --- Вспомогательные функции для рисования символов нагрузок ---

		// Функция для рисования стрелки (для сил)
		function drawArrow(fromX, fromY, toX, toY, color, arrowheadLength = 10) {
			ctx.strokeStyle = color;
			ctx.fillStyle = color;
			ctx.lineWidth = 0.7 / scale;

			ctx.beginPath();
			ctx.moveTo(fromX, fromY);
			ctx.lineTo(toX, toY);
			ctx.stroke();

			const angle = Math.atan2(toY - fromY, toX - fromX);
			const headLen = arrowheadLength / scale;
			const headAngle = Math.PI / 10;

			ctx.beginPath();
			ctx.moveTo(toX, toY);
			ctx.lineTo(toX - headLen * Math.cos(angle - headAngle), toY - headLen * Math.sin(angle - headAngle));
			ctx.lineTo(toX - headLen * Math.cos(angle + headAngle), toY - headLen * Math.sin(angle + headAngle));
			ctx.closePath();
			ctx.fill();
		}

		// Функция для рисования дуговой стрелки (для моментов)
		function drawArcArrow(centerX, centerY, radius, startAngle, endAngle, counterClockwise, color, arrowheadLength = 10) {
			ctx.strokeStyle = color;
			ctx.fillStyle = color;
			ctx.lineWidth = 1 / scale;

			ctx.beginPath();
			ctx.arc(centerX, centerY, radius, startAngle, endAngle, counterClockwise);
			ctx.stroke();

			const arrowAngle = endAngle;
			const headLen = arrowheadLength / scale;
			const headAngle = Math.PI / 10;

			let headTangentAngle = arrowAngle;
			if (counterClockwise) {
				headTangentAngle -= Math.PI / 2;
			} else {
				headTangentAngle += Math.PI / 2;
			}

			const arrowPointX = centerX + radius * Math.cos(arrowAngle);
			const arrowPointY = centerY + radius * Math.sin(arrowAngle);

			ctx.beginPath();
			ctx.moveTo(arrowPointX, arrowPointY);
			ctx.lineTo(arrowPointX - headLen * Math.cos(headTangentAngle - headAngle), arrowPointY - headLen * Math.sin(headTangentAngle - headAngle));
			ctx.lineTo(arrowPointX - headLen * Math.cos(headTangentAngle + headAngle), arrowPointY - headLen * Math.sin(headTangentAngle + headAngle));
			ctx.closePath();
			ctx.fill();
		}

		function drawGrid() {
            let gridBaseUnit = 'm';
            if (currentUnit === 'ft' || currentUnit === 'in') {
                gridBaseUnit = 'ft';
            }

            const baseGridStep = 1; 
            const gridStep_currentUnit = convertUnits(baseGridStep, gridBaseUnit, currentUnit);
            const subGridStep_currentUnit = gridStep_currentUnit / divisionsPerUnit;

            const worldView = {
                minX: screenToWorld(0, 0).x,
                maxX: screenToWorld(canvas.width, 0).x,
                minY: screenToWorld(0, canvas.height).y, 
                maxY: screenToWorld(0, 0).y             
            };
            
            ctx.beginPath();
            ctx.strokeStyle = '#e0e0e0'; 
            ctx.lineWidth = 1 / scale; 

            const startX_currentUnit = Math.floor(worldView.minX / subGridStep_currentUnit) * subGridStep_currentUnit;
            const endX_currentUnit = Math.ceil(worldView.maxX / subGridStep_currentUnit) * subGridStep_currentUnit;
            for (let x = startX_currentUnit; x <= endX_currentUnit; x += subGridStep_currentUnit) {
                ctx.moveTo(x, Math.min(worldView.minY, worldView.maxY));
                ctx.lineTo(x, Math.max(worldView.minY, worldView.maxY));
            }

            const startY_currentUnit = Math.floor(Math.min(worldView.minY, worldView.maxY) / subGridStep_currentUnit) * subGridStep_currentUnit;
            const endY_currentUnit = Math.ceil(Math.max(worldView.minY, worldView.maxY) / subGridStep_currentUnit) * subGridStep_currentUnit;
            for (let y = startY_currentUnit; y <= endY_currentUnit; y += subGridStep_currentUnit) {
                ctx.moveTo(worldView.minX, y);
                ctx.lineTo(worldView.maxX, y);
            }
            ctx.stroke();
        }

		function drawAxes() {
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 2 / scale;
            ctx.fillStyle = '#555';
            const fontSizeWorld = 12 / scale; 
            ctx.font = `${fontSizeWorld}px Arial`;

            const visMinX = screenToWorld(0,0).x; 
            const visMaxX = screenToWorld(canvas.width,0).x; 
            const visMinY_world = screenToWorld(0,canvas.height).y; 
            const visMaxY_world = screenToWorld(0,0).y;         

            ctx.beginPath(); 
            ctx.moveTo(visMinX, 0); 
            ctx.lineTo(visMaxX, 0);
            ctx.stroke();

            ctx.beginPath(); 
            ctx.moveTo(0, visMinY_world); 
            ctx.lineTo(0, visMaxY_world);
            ctx.stroke();

            let axisLabelBaseUnit = 'm';
            if (currentUnit === 'ft' || currentUnit === 'in') {
                axisLabelBaseUnit = 'ft';
            }

            const unitLabelIncrement = 1; 
            const xLabelYOffsetWorld = fontSizeWorld * 0.5; 

            // X-axis labels
            const xLabelMinNum = Math.floor(convertUnits(visMinX, currentUnit, axisLabelBaseUnit) / unitLabelIncrement);
            const xLabelMaxNum = Math.ceil(convertUnits(visMaxX, currentUnit, axisLabelBaseUnit) / unitLabelIncrement);
            for (let num = xLabelMinNum; num <= xLabelMaxNum; num += unitLabelIncrement) {
                const worldX_currentUnit = convertUnits(num * unitLabelIncrement, axisLabelBaseUnit, currentUnit);
                const labelText = num.toFixed(0);
                
                ctx.save();
                ctx.translate(worldX_currentUnit, xLabelYOffsetWorld); 
                ctx.scale(1, -1); 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom'; 
                ctx.fillText(labelText, 0, 0);
                ctx.restore();
            }
            
            // Y-axis labels
            const yLabelXOffsetWorld = -fontSizeWorld * 0.5; 
            const yLabelMinNum = Math.floor(convertUnits(Math.min(visMinY_world, visMaxY_world), currentUnit, axisLabelBaseUnit) / unitLabelIncrement);
            const yLabelMaxNum = Math.ceil(Math.max(visMinY_world, visMaxY_world) / unitLabelIncrement);
            for (let num = yLabelMinNum; num <= yLabelMaxNum; num += unitLabelIncrement) {
                if (Math.abs(num) < 1e-9 / scale && Math.abs(0 - xLabelYOffsetWorld) < 1e-9 / scale ) continue; 
                if (num === 0) continue; 
                const worldY_currentUnit = convertUnits(num * unitLabelIncrement, axisLabelBaseUnit, currentUnit);
                const labelText = num.toFixed(0);

                ctx.save();
                ctx.translate(yLabelXOffsetWorld, worldY_currentUnit); 
                ctx.scale(1, -1); 
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                ctx.fillText(labelText, 0, 0);
                ctx.restore();
            }
        }

		function drawNodes() {
			const nodeRadiusWorld = 2 / scale;
			const nodeIdFontSizeWorld = 12 / scale;
			
			nodes.forEach(node => {
				ctx.save(); // НОВОЕ: Сохраняем состояние контекста для этого узла
				ctx.beginPath();
				ctx.arc(node.x, node.y, nodeRadiusWorld, 0, 2 * Math.PI);
				
				const isSelected = selectedElements.some(el => el.type === 'node' && el.element.node_id === node.node_id);

				if (isSelected) {
					ctx.fillStyle = '#FF6D2D'; // Оранжево-красный для выделенного
				} else if (hoveredElement && hoveredElement.type === 'node' && hoveredElement.element.node_id === node.node_id) {
					ctx.fillStyle = '#dc3545'; // Красный для наведения
				} else {
					ctx.fillStyle = '#007bff'; // Синий по умолчанию
				}

				ctx.fill();
				// ctx.strokeStyle = '#343a40'; // Оставляем закомментированным, как вы просили убрать обводку
				// ctx.lineWidth = 1.5 / scale;
				// ctx.stroke();

				if (showNodeIds) {
					ctx.save(); // Сохраняем состояние для преобразований текста
					ctx.translate(node.x + 7/scale, node.y - 5/scale);
					ctx.scale(1, -1);
					
					ctx.fillStyle = ctx.fillStyle; // Берем цвет, который был установлен для заливки узла
					ctx.font = `${nodeIdFontSizeWorld}px Arial`;
					ctx.textAlign = 'center';
					ctx.textBaseline = 'middle';
					ctx.fillText(node.node_id, 0, -(nodeRadiusWorld + (nodeIdFontSizeWorld / 2) + 2/scale));
					ctx.restore(); // Восстанавливаем состояние после преобразований текста
				}
				ctx.restore(); // НОВОЕ: Восстанавливаем состояние контекста после отрисовки этого узла
			});
		}

        // ===============================================
        // Функция для рисования ВСЕХ иконок закреплений на Canvas
        // ===============================================
        function drawRestrictions() {
            restrictions.forEach(restriction => {
                const node = nodes.find(n => n.node_id === restriction.node_id);
                if (node) {
                    let iconToDraw = null;
                    for (const typeKey in restrictionTypes) {
                        const type = restrictionTypes[typeKey];
                        if (type.icon && type.dx === restriction.dx && type.dy === restriction.dy && type.dr === restriction.dr) {
                            iconToDraw = typeKey;
                            break;
                        }
                    }

                    if (iconToDraw) {
                        drawRestrictionIcon(ctx, node.x, node.y, scale, iconToDraw);
                    }
                }
            });
        }
		
		// --- Обновленная функция для отрисовки узловых нагрузок ---
		function drawNodeLoads() {
			const LOAD_COLOR = 'black'; 

			const FIXED_ARROW_LENGTH_PX = 70; 
			const FIXED_MOMENT_RADIUS_PX = 35; 
			const FIXED_TEXT_OFFSET_PX = 10; 

			nodeLoads.forEach(load => {
				const node = nodes.find(n => n.node_id === load.target_id);
				if (!node) return;

                const currentForceDisplayUnit = forceUnitsSelect.value;
                const currentLengthDisplayUnit = unitsSelect.value;

                let displayedValue;
                let displayedUnitString;

                if (load.type === 'point_force') {
                    displayedValue = convertForce(load.value, load.unit, currentForceDisplayUnit).toFixed(2);
                    displayedUnitString = currentForceDisplayUnit;
                } else if (load.type === 'moment') {
                    displayedValue = convertMoment(load.value, load.unit, load.lengthUnit, currentForceDisplayUnit, currentLengthDisplayUnit).toFixed(2);
                    displayedUnitString = `${currentForceDisplayUnit}*${currentLengthDisplayUnit}`;
                }

				const drawX = node.x;
				const drawY = node.y;

				const currentArrowLength = FIXED_ARROW_LENGTH_PX / scale;
				const currentMomentRadius = FIXED_MOMENT_RADIUS_PX / scale;
				const currentTextOffset = FIXED_TEXT_OFFSET_PX / scale;

				ctx.font = `${12 / scale}px Arial`; 
				ctx.fillStyle = LOAD_COLOR;
				ctx.textBaseline = 'middle'; 

				if (load.type === 'point_force') {
					let fromX, fromY, toX, toY;
					let textX, textY;

					toX = drawX;
					toY = drawY;

					if (load.component === 'x') {
						fromX = drawX - (load.value > 0 ? currentArrowLength : -currentArrowLength);
						fromY = drawY;
						
						textX = fromX + (load.value > 0 ? -currentTextOffset : currentTextOffset) * 0;
						textY = fromY + currentTextOffset * 0.5; 
						ctx.textAlign = load.value > 0 ? 'left': 'right';
						ctx.textBaseline = 'bottom';
					} else if (load.component === 'y') {
						fromX = drawX;
						fromY = drawY - (load.value > 0 ? currentArrowLength : -currentArrowLength);
						
						textX = fromX + currentTextOffset;
						textY = fromY + (load.value > 0 ? -currentTextOffset : currentTextOffset) * 0; 
						ctx.textBaseline = load.value > 0 ? 'bottom' : 'top';
						ctx.textAlign = 'left';
					}

					drawArrow(fromX, fromY, toX, toY, LOAD_COLOR);
					
					ctx.save();
					ctx.scale(1, -1);
					ctx.fillText(`${displayedValue} ${displayedUnitString}`, textX, -textY); 
					ctx.restore();

				} else if (load.type === 'moment') {
					let startAngle, endAngle, counterClockwise;
					const arcLength = Math.PI * (90 / 180);

					if (load.value > 0) {
						startAngle = Math.PI / 4;
						endAngle = startAngle - arcLength;
						counterClockwise = false;
					} else {
						startAngle = Math.PI / 1.33333;
						endAngle = startAngle + arcLength;
						counterClockwise = true;
					}

					drawArcArrow(drawX, drawY, currentMomentRadius, startAngle, endAngle, counterClockwise, LOAD_COLOR); 

					const textArcAngle = endAngle; 
					const textPosX = drawX + (currentMomentRadius + currentTextOffset) * Math.cos(textArcAngle);
					const textPosY = drawY + (currentMomentRadius + currentTextOffset) * Math.sin(textArcAngle);
					
					ctx.save();
					ctx.scale(1, -1);
					ctx.textAlign = load.value > 0 ? 'left' : 'right';
					ctx.fillText(`${displayedValue} ${displayedUnitString}`, textPosX, -textPosY); 
					ctx.restore();
				}
			});
		}
		
		// НОВАЯ ФУНКЦИЯ: Отрисовка распределенных нагрузок
        function drawDistributedLoads() {
            const LOAD_COLOR = 'green';
            const DIST_LOAD_ARROW_LENGTH_PX = 15;
            const DIST_LOAD_OFFSET_PX = 0;
            const DIST_LOAD_RECT_WIDTH_PX = 15;
            const DIST_LOAD_TEXT_OFFSET_PX = 15;
            const ARROW_HEAD_LENGTH_PX = 8;

            elementLoads.forEach(load => {
                const line = lines.find(l => l.elem_id === load.target_elem_id);
                if (!line) return;

                const node1 = nodes.find(n => n.node_id === line.nodeId1);
                const node2 = nodes.find(n => n.node_id === line.nodeId2);
                if (!node1 || !node2) return;

                const currentForceDisplayUnit = forceUnitsSelect.value;
                const currentLengthDisplayUnit = unitsSelect.value;
                const currentDistributedForceUnit = `${currentForceDisplayUnit}/${currentLengthDisplayUnit}`;

                const storedForceUnit = load.unit.split('/')[0];
                const storedLengthUnit = load.unit.split('/')[1];

				const displayedValue = parseFloat(convertDistributedForce(load.startValue, storedForceUnit, storedLengthUnit, currentForceDisplayUnit, currentLengthDisplayUnit).toFixed(2));
                const displayedUnitString = currentDistributedForceUnit;

                const dx_line = node2.x - node1.x;
                const dy_line = node2.y - node1.y;
                const lineLength = Math.sqrt(dx_line * dx_line + dy_line * dy_line);

                if (lineLength === 0) return;

                const lineAngle = Math.atan2(dy_line, dx_line);

                const arrowLengthWorld = DIST_LOAD_ARROW_LENGTH_PX / scale;
                const offsetWorld = DIST_LOAD_OFFSET_PX / scale;
                const rectWidthWorld = DIST_LOAD_RECT_WIDTH_PX / scale;
                const textOffsetWorld = DIST_LOAD_TEXT_OFFSET_PX / scale;
                const arrowHeadLengthWorld = ARROW_HEAD_LENGTH_PX / scale;

                ctx.save();
                ctx.strokeStyle = LOAD_COLOR;
                ctx.fillStyle = LOAD_COLOR;
                ctx.lineWidth = 0.7 / scale;
                ctx.font = `${12 / scale}px Arial`;
                ctx.textBaseline = 'middle';

                let perpDx, perpDy;
                if (load.component === 'x') {
                    perpDx = 0;
                    perpDy = (load.startValue > 0) ? 1 : -1; 
                } else {
                    perpDx = (load.startValue > 0) ? -1 : 1; 
                    perpDy = 0;
                }

                const perpVectorLength = Math.sqrt(perpDx * perpDx + perpDy * perpDy);
                if (perpVectorLength > 0) {
                    perpDx = (perpDx / perpVectorLength) * offsetWorld;
                    perpDy = (perpDy / perpVectorLength) * offsetWorld;
                }

				// --- Определение координат четырех вершин четырехугольника ---
				let p1_world = { x: node1.x, y: node1.y };
				let p2_world = { x: node2.x, y: node2.y };

				let p3_world = {};
				let p4_world = {};

				if (load.component === 'y') {
					p3_world.x = node2.x;
					p4_world.x = node1.x;

					if (load.startValue > 0) {
						p3_world.y = node2.y - arrowLengthWorld;
						p4_world.y = node1.y - arrowLengthWorld;
					} else {
						p3_world.y = node2.y + arrowLengthWorld;
						p4_world.y = node1.y + arrowLengthWorld;
					}
				} else if (load.component === 'x') {
					p3_world.y = node2.y;
					p4_world.y = node1.y;

					if (load.startValue > 0) {
						p3_world.x = node2.x - arrowLengthWorld;
						p4_world.x = node1.x - arrowLengthWorld;
					} else {
						p3_world.x = node2.x + arrowLengthWorld;
						p4_world.x = node1.x + arrowLengthWorld;
					}
				}

				// --- Построение четырехугольника ---
				ctx.beginPath();
				ctx.moveTo(p1_world.x, p1_world.y);
				ctx.lineTo(p2_world.x, p2_world.y);
				ctx.lineTo(p3_world.x, p3_world.y);
				ctx.lineTo(p4_world.x, p4_world.y);
				ctx.closePath();

				ctx.fillStyle = 'green';
				ctx.globalAlpha = 0.2;
				ctx.fill();

				ctx.globalAlpha = 0.7;
				ctx.strokeStyle = 'green';
				ctx.lineWidth = 0.5 / scale;
				ctx.stroke();

                const numArrows = Math.max(2, Math.floor(lineLength / (arrowLengthWorld * 2))); 
                for (let i = 0; i <= numArrows; i++) {
                    const t = i / numArrows;
                    const currentPointX = node1.x + dx_line * t;
                    const currentPointY = node1.y + dy_line * t;

                    let arrowFromX, arrowFromY, arrowToX, arrowToY;

                    if (load.component === 'x') {
                        arrowToX = currentPointX + perpDx;
                        arrowToY = currentPointY + perpDy;
                        arrowFromX = arrowToX - (load.startValue > 0 ? arrowLengthWorld : -arrowLengthWorld);
                        arrowFromY = arrowToY;						
                    } else {
						arrowToX = currentPointX + perpDx;
                        arrowToY = currentPointY + perpDy;
                        arrowFromX = arrowToX;
                        arrowFromY = arrowToY - (load.startValue > 0 ? arrowLengthWorld : -arrowLengthWorld);
                    }
                    
                    drawArrow(arrowFromX, arrowFromY, arrowToX, arrowToY, LOAD_COLOR, arrowHeadLengthWorld * scale); 
                }

                const midPointX = node1.x + dx_line / 2;
                const midPointY = node1.y + dy_line / 2;

                let textX, textY;
                if (load.component === 'x') {
                    textX = midPointX - perpDx - (load.startValue > 0 ? arrowLengthWorld + textOffsetWorld : -(arrowLengthWorld + textOffsetWorld));
                    textY = midPointY + perpDy;
                    ctx.textAlign = load.startValue > 0 ? 'right' : 'left';
                    ctx.textBaseline = 'middle';
                } else {
                    textX = midPointX + perpDx;
                    textY = midPointY - perpDy - (load.startValue > 0 ? arrowLengthWorld + textOffsetWorld : -(arrowLengthWorld + textOffsetWorld));
                    ctx.textAlign = 'center';
                    ctx.textBaseline = load.startValue > 0 ? 'bottom' : 'top';
                }
                
                ctx.save();
                ctx.scale(1, -1);
				ctx.globalAlpha = 1;
                ctx.fillText(`${displayedValue} ${displayedUnitString}`, textX, -textY);
                ctx.restore();

                ctx.restore();
            });
        }

        // ===============================================
        // Функции для рисования КОНКРЕТНОЙ иконки закрепления на Canvas
        // ===============================================
        const restrictionIconSizeWorld = 15;
        const restrictionIconOffsetWorld = 2;

        function drawRestrictionIcon(ctx, nodeX, nodeY, currentScale, iconType) {
            ctx.save();
            ctx.translate(nodeX, nodeY);
            ctx.scale(1, 1);

            const iconRenderSize = restrictionIconSizeWorld / currentScale;
            const iconRenderOffset = restrictionIconOffsetWorld / currentScale;

            ctx.strokeStyle = '#343a40';
            ctx.lineWidth = 1.1 / currentScale;
            ctx.fillStyle = '#6c757d';

            switch (iconType) {
                case "pinned":
                    ctx.beginPath();
                    ctx.moveTo(0, -iconRenderOffset);
                    ctx.lineTo(-iconRenderSize / 1.5, -(iconRenderOffset + iconRenderSize));
                    ctx.lineTo(iconRenderSize / 1.5, -(iconRenderOffset + iconRenderSize));
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(-iconRenderSize * 0.8, -(iconRenderOffset + iconRenderSize + 0 / currentScale));
                    ctx.lineTo(iconRenderSize * 0.8, -(iconRenderOffset + iconRenderSize + 0 / currentScale));
					ctx.lineWidth = 1.5 / currentScale;
                    ctx.stroke();
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(iconRenderSize * (0.2 - i * 0.5), (iconRenderOffset - iconRenderSize - 12/ currentScale));
                        ctx.lineTo(iconRenderSize * (0.6 - i * 0.5), (iconRenderOffset - iconRenderSize - 5/ currentScale));
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 1 / currentScale;
                        ctx.stroke();
                    }
                    break;
                case "rolled-x":
                    ctx.beginPath();
                    ctx.moveTo(0, -iconRenderOffset*0.5);
                    ctx.lineTo(-iconRenderSize / 1.8, -(iconRenderOffset + iconRenderSize-4/ currentScale));
                    ctx.lineTo(iconRenderSize / 1.8, -(iconRenderOffset + iconRenderSize-4/ currentScale));
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(-iconRenderSize * 0.8, -(iconRenderOffset + iconRenderSize + 0 / currentScale));
                    ctx.lineTo(iconRenderSize * 0.8, -(iconRenderOffset + iconRenderSize + 0 / currentScale));
					ctx.lineWidth = 1.5 / currentScale;
                    ctx.stroke();
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(iconRenderSize * (0.2 - i * 0.5), (iconRenderOffset - iconRenderSize - 12/ currentScale));
                        ctx.lineTo(iconRenderSize * (0.6 - i * 0.5), (iconRenderOffset - iconRenderSize - 5/ currentScale));
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 1 / currentScale;
                        ctx.stroke();
                    }
                    break;
                case "rolled-y":
                    ctx.rotate(Math.PI / 1);
                    ctx.translate(iconRenderOffset, -iconRenderSize * 0); 

                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(-(iconRenderSize)*0.9, -iconRenderSize / 1.6);
                    ctx.lineTo(-(iconRenderSize)*0.9, iconRenderSize / 1.6);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(-(rollerOffsetX_y + rollerRadius_y - 2 / currentScale), -iconRenderSize * 0.8);
                    ctx.lineTo(-(rollerOffsetX_y + rollerRadius_y - 2 / currentScale), iconRenderSize * 0.8);			
                    ctx.stroke();
                     for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo((iconRenderOffset - iconRenderSize - 12/ currentScale), iconRenderSize * (0.6 - i * 0.5));
                        ctx.lineTo((iconRenderOffset - iconRenderSize - 5/ currentScale), iconRenderSize * (0.2 - i * 0.5));						
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 1 / currentScale;
                        ctx.stroke();
                    }
                    break;
                case "fixed":
                    const fixedHeight = iconRenderSize * 1.5;

                    ctx.beginPath();
                    ctx.moveTo(-iconRenderSize * 0.8, 0);
                    ctx.lineTo(iconRenderSize * 0.8, 0);
					ctx.lineWidth = 1.5 / currentScale;
                    ctx.stroke();
					
                    ctx.moveTo(0, -20/ currentScale);
                    ctx.lineTo(0, 0/ currentScale);
					ctx.stroke();
					
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(iconRenderSize * (0.2 - i * 0.5), -8/ currentScale);
                        ctx.lineTo(iconRenderSize * (0.6 - i * 0.5), 0/ currentScale);
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 1 / currentScale;
                        ctx.stroke();
                    }
                    break;
                case "sleeve-x":

                    const sleeveWidth = iconRenderSize * 0.8;
                    const sleeveHeight = iconRenderSize * 1.2;
					// Горизонт нижняя
                    ctx.beginPath();
                    ctx.moveTo(-iconRenderSize * 0.8, (iconRenderOffset - iconRenderSize + 5 / currentScale));
                    ctx.lineTo(iconRenderSize * 0.8, (iconRenderOffset - iconRenderSize + 5 / currentScale));
					ctx.lineWidth = 1.5 / currentScale;
                    ctx.stroke();
					// Горизонт верхняя
                    ctx.beginPath();
                    ctx.moveTo(-iconRenderSize * 0.8, -(iconRenderOffset - iconRenderSize + 5 / currentScale));
                    ctx.lineTo(iconRenderSize * 0.8, -(iconRenderOffset - iconRenderSize + 5 / currentScale));
					ctx.lineWidth = 1.5 / currentScale;
                    ctx.stroke();
					// Штриховка нижняя
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(iconRenderSize * (0.2 - i * 0.5), (iconRenderOffset - iconRenderSize - 2/ currentScale));
                        ctx.lineTo(iconRenderSize * (0.6 - i * 0.5), (iconRenderOffset - iconRenderSize + 5/ currentScale));
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 1 / currentScale;
                        ctx.stroke();
                    }
					// Штриховка верхняя
					for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(iconRenderSize * (0.6 - i * 0.5), -(iconRenderOffset - iconRenderSize - 2/ currentScale));
                        ctx.lineTo(iconRenderSize * (0.2 - i * 0.5), -(iconRenderOffset - iconRenderSize + 5/ currentScale));
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 1 / currentScale;
                        ctx.stroke();
                    }
                    break;
                case "sleeve-y":
                    ctx.rotate(Math.PI / 2);

                    const sleeveWidth_y = iconRenderSize * 0.8;
                    const sleeveHeight_y = iconRenderSize * 1.2;
					// Горизонт нижняя
                    ctx.beginPath();
                    ctx.moveTo(-iconRenderSize * 0.8, (iconRenderOffset - iconRenderSize + 5 / currentScale));
                    ctx.lineTo(iconRenderSize * 0.8, (iconRenderOffset - iconRenderSize + 5 / currentScale));
					ctx.lineWidth = 1.5 / currentScale;
                    ctx.stroke();
					// Горизонт верхняя
                    ctx.beginPath();
                    ctx.moveTo(-iconRenderSize * 0.8, -(iconRenderOffset - iconRenderSize + 5 / currentScale));
                    ctx.lineTo(iconRenderSize * 0.8, -(iconRenderOffset - iconRenderSize + 5 / currentScale));
					ctx.lineWidth = 1.5 / currentScale;
                    ctx.stroke();
					
					// Штриховка нижняя
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(iconRenderSize * (0.2 - i * 0.5), (iconRenderOffset - iconRenderSize - 2/ currentScale));
                        ctx.lineTo(iconRenderSize * (0.6 - i * 0.5), (iconRenderOffset - iconRenderSize + 5/ currentScale));
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 1 / currentScale;
                        ctx.stroke();
                    }
					
					// Штриховка верхняя
					for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(iconRenderSize * (0.6 - i * 0.5), -(iconRenderOffset - iconRenderSize - 2/ currentScale));
                        ctx.lineTo(iconRenderSize * (0.2 - i * 0.5), -(iconRenderOffset - iconRenderSize + 5/ currentScale));
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 1 / currentScale;
                        ctx.stroke();
                    }
                    break;
            }

            ctx.restore();
        }

		function drawLines() {
			const lineIdFontSizeWorld = 12 / scale;
			const lineIdOffsetWorld = 7 / scale;
			const normalLineWidth = 1.25;
			const selectedLineWidth = 3;  // УВЕЛИЧЕННАЯ ТОЛЩИНА ДЛЯ ВЫДЕЛЕННОГО ЭЛЕМЕНТА

			lines.forEach(line => {
				const node1 = nodes.find(n => n.node_id === line.nodeId1);
				const node2 = nodes.find(n => n.node_id === line.nodeId2);
				if (node1 && node2) {
					ctx.save(); // НОВОЕ: Сохраняем состояние контекста для этой линии
					ctx.beginPath();
					ctx.moveTo(node1.x, node1.y);
					ctx.lineTo(node2.x, node2.y);

					const isSelected = selectedElements.some(el => el.type === 'line' && el.element.elem_id === line.elem_id);

					if (isSelected) {
						ctx.strokeStyle = '#FF6D2D'; // Оранжево-красный для выделенного
						ctx.lineWidth = selectedLineWidth / scale;
					} else if (hoveredElement && hoveredElement.type === 'line' && hoveredElement.element.elem_id === line.elem_id) {
						ctx.strokeStyle = '#dc3545'; // Красный для наведения
						ctx.lineWidth = normalLineWidth / scale;
					} else {
						ctx.strokeStyle = '#343a40'; // Темно-серый по умолчанию
						ctx.lineWidth = normalLineWidth / scale;
					}
					ctx.stroke();

					if (showElementIds) {
						ctx.save(); // Сохраняем состояние для преобразований текста
						const midX = (node1.x + node2.x) / 2;
						const midY = (node1.y + node2.y) / 2;

						ctx.translate(midX, midY);
						ctx.scale(1, -1);

						const angle = -Math.atan2(node2.y - node1.y, node2.x - node1.x); 
						
						if (angle > Math.PI / 2 || angle < -Math.PI / 2) {
							ctx.rotate(angle + Math.PI);
						} else {
							ctx.rotate(angle);
						}

						ctx.fillStyle = ctx.strokeStyle; // Берем цвет, который был установлен для обводки линии
						ctx.font = `${lineIdFontSizeWorld}px Arial`;
						ctx.textAlign = 'center';
						ctx.textBaseline = 'middle';

						ctx.fillText(line.elem_id, 0, -lineIdOffsetWorld);
						
						ctx.restore(); // Восстанавливаем состояние после преобразований текста
					}
					ctx.restore(); // НОВОЕ: Восстанавливаем состояние контекста после отрисовки этой линии
				}
			});
		}

        function drawCursorCircle() { 
            let drawAtX_screen, drawAtY_screen;
            if (snapToGrid) {
                const screenSnappedPos = worldToScreen(mouse.snappedX, mouse.snappedY);
                drawAtX_screen = screenSnappedPos.x;
                drawAtY_screen = screenSnappedPos.y;
            } else {
                drawAtX_screen = mouse.x; 
                drawAtY_screen = mouse.y;
            }
            ctx.beginPath();
            ctx.arc(drawAtX_screen, drawAtY_screen, 5, 0, 2 * Math.PI);
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.9)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
        }
        
        // Event Handlers
        function addEventListeners() {
            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleWheelZoom, { passive: false });
            canvas.addEventListener('contextmenu', handleContextMenu);
            document.addEventListener('click', handleClickOutsideContextMenu);

            divisionsInput.addEventListener('change', () => {
                divisionsPerUnit = parseInt(divisionsInput.value) || 1;
                if (divisionsPerUnit < 1) divisionsPerUnit = 1;
                if (divisionsPerUnit > 20) divisionsPerUnit = 20;
                divisionsInput.value = divisionsPerUnit;
                draw();
            });
            snapToGridCheckbox.addEventListener('change', () => {
                snapToGrid = snapToGridCheckbox.checked;
                const worldCoords = screenToWorld(mouse.x, mouse.y); 
                const snapped = getSnappedCoordinates(worldCoords.x, worldCoords.y); 
                mouse.snappedX = snapped.x;
                mouse.snappedY = snapped.y; 
                draw();
            });
            clearCanvasBtn.addEventListener('click', clearAll);
			
			// НОВОЕ: Обработчик для кнопки сохранения модели
            saveModelBtn.addEventListener('click', saveModel);
			
			            // НОВОЕ: DOM элементы для загрузки модели
            // const loadModelBtn = document.getElementById('loadModelBtn'); // Уже объявлен
            // const fileInput = document.getElementById('fileInput'); // Уже объявлен

            // Обработчик для кнопки "Загрузить"
            loadModelBtn.addEventListener('click', () => {
                fileInput.click();
            });

            // Обработчик для изменения (выбора) файла в поле ввода
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) {
                    console.log("Файл не выбран.");
                    return;
                }

                const reader = new FileReader();

                reader.onload = async (event) => {
                    const fileContent = event.target.result;
                    await loadModel(fileContent);
                    fileInput.value = ''; 
                };

                reader.onerror = (error) => {
                    console.error("Ошибка чтения файла:", error);
                    console.error("Не удалось прочитать файл.");
                };

                reader.readAsText(file);
            });
            
            unitsSelect.addEventListener('change', (e) => {
                const oldUnit = currentUnit;
                const newUnit = e.target.value;
                if (oldUnit === newUnit) return;

                nodes.forEach(node => { 
                    node.x = convertUnits(node.x, oldUnit, newUnit);
                    node.y = convertUnits(node.y, oldUnit, newUnit);
                });

				nodeLoads.forEach(load => {
                    if (load.type === 'moment') {
                        load.value = convertMoment(load.value, load.unit, oldUnit, load.unit, newUnit);
                        load.lengthUnit = newUnit; 
                    }
                });
				
                elementLoads.forEach(load => {
                    const storedForceUnit = load.unit.split('/')[0];
                    const storedLengthUnit = load.unit.split('/')[1];

                    load.startValue = convertDistributedForce(load.startValue, storedForceUnit, storedLengthUnit, storedForceUnit, newUnit);
                    load.endValue = convertDistributedForce(load.endValue, storedForceUnit, storedLengthUnit, storedForceUnit, newUnit);
                    
                    load.unit = `${storedForceUnit}/${newUnit}`;
                });

                scale = scale * (lengthUnitConversions[newUnit] / lengthUnitConversions[oldUnit]);
                currentUnit = newUnit;
				
                if (newUnit === 'mm' || newUnit === 'cm' || newUnit === 'in') {
                    snapToGrid = false;
                    snapToGridCheckbox.checked = false;
                } else {
                    snapToGrid = true;
                    snapToGridCheckbox.checked = true;
                }
                
                const worldCoordsNow = screenToWorld(mouse.x, mouse.y); 
                const snappedNow = getSnappedCoordinates(worldCoordsNow.x, worldCoordsNow.y);
                mouse.worldX = worldCoordsNow.x;
                mouse.worldY = worldCoordsNow.y; 
                mouse.snappedX = snappedNow.x;
                mouse.snappedY = snappedNow.y; 

                updatePropertiesPanel();
                draw();
				
				updateForceUnitDisplay();
                updateUnitPairsSelect();
            });

			// НОВОЕ: Слушатель событий для изменения единиц силы
            forceUnitsSelect.addEventListener('change', (e) => {
                const newForceUnit = e.target.value;
                const oldForceUnit = forceUnitsSelect.dataset.previousValue;

                forceUnitsSelect.dataset.previousValue = newForceUnit;

				nodeLoads.forEach(load => {
                    if (load.type === 'point_force') {
                        load.value = convertForce(load.value, load.unit, newForceUnit);
                        load.unit = newForceUnit; 
                    } else if (load.type === 'moment') {
                        load.value = convertMoment(load.value, load.unit, load.lengthUnit, newForceUnit, load.lengthUnit);
                        load.unit = newForceUnit; 
                    }
                });
				
                elementLoads.forEach(load => {
                    const storedForceUnit = load.unit.split('/')[0];
                    const storedLengthUnit = load.unit.split('/')[1];

                    load.startValue = convertDistributedForce(load.startValue, storedForceUnit, storedLengthUnit, newForceUnit, storedLengthUnit);
                    load.endValue = convertDistributedForce(load.endValue, storedForceUnit, storedLengthUnit, newForceUnit, storedLengthUnit);
                    
                    load.unit = `${newForceUnit}/${storedLengthUnit}`;
                });

                updateForceUnitDisplay(); 
				updateUnitPairsSelect();
            });

			// НОВОЕ: Слушатель событий для изменения наборов единиц
            unitPairsSelect.addEventListener('change', (e) => {
                const selectedPairKey = e.target.value;
                currentUnitPair = selectedPairKey;

                if (selectedPairKey !== 'none') {
                    const targetUnits = unitPairConversions[selectedPairKey];
                    
                    unitsSelect.value = targetUnits.length;
                    unitsSelect.dispatchEvent(new Event('change')); 

                    forceUnitsSelect.value = targetUnits.force;
                    forceUnitsSelect.dataset.previousValue = targetUnits.force; 
                    forceUnitsSelect.dispatchEvent(new Event('change')); 
                }
            });

            deleteNodeItem.addEventListener('click', handleDeleteNode);
            deleteLineItem.addEventListener('click', handleDeleteLine);

            // --- Логика открытия/закрытия модального окна материалов ---
            const openMaterialsModalBtn = document.getElementById('openMaterialsModalBtn');
            const materialsModal = document.getElementById('materialsModal');
            const closeMaterialsModalBtn = document.getElementById('closeMaterialsModalBtn');
            const closeMaterialsModalBtnBottom = document.getElementById('closeMaterialsModalBtnBottom');


        }

		function handleMouseDown(e) {
			e.preventDefault();
			hideContextMenu(); // Убедитесь, что эта функция существует, или закомментируйте её

			const rect = canvas.getBoundingClientRect();
			mouse.x = e.clientX - rect.left;
			mouse.y = e.clientY - rect.top; // Используем rect.top для консистентности, если в вашем коде это так

			// Получаем мировые координаты
			const worldCoords = screenToWorld(mouse.x, mouse.y); 
			mouse.worldX = worldCoords.x;
			mouse.worldY = worldCoords.y; 
			const snapped = getSnappedCoordinates(mouse.worldX, mouse.worldY); 
			mouse.snappedX = snapped.x;
			mouse.snappedY = snapped.y; 

			const clickedNode = findNodeAt(mouse.worldX, mouse.worldY); 
			const clickedLine = findLineAt(mouse.worldX, mouse.worldY); 
			
			// --- НОВОЕ: Проверяем нажата ли клавиша Ctrl/Cmd ---
			const isCtrlPressed = e.ctrlKey || e.metaKey; // Для Windows/Linux (Ctrl) и macOS (Cmd)

			if (e.button === 0) { // Левый клик
				// --- СЦЕНАРИЙ 1: Попытка завершить линию (firstNodeForLine активен) ---
				if (firstNodeForLine) {
					if (clickedNode && firstNodeForLine.node_id !== clickedNode.node_id) {
						// Второй клик по другому узлу: пытаемся создать линию
						const exists = lines.some(line =>
							(line.nodeId1 === firstNodeForLine.node_id && line.nodeId2 === clickedNode.node_id) || 
							(line.nodeId1 === clickedNode.node_id && line.nodeId2 === firstNodeForLine.node_id)    
						);
						if (!exists) {
							lines.push({ elem_id: nextElemId++, nodeId1: firstNodeForLine.node_id, nodeId2: clickedNode.node_id, structural_type: 'beam', materialId: null, loads: [] }); 
							console.log(`Линия ${nextElemId - 1} создана между узлами ${firstNodeForLine.node_id} и ${clickedNode.node_id}.`);
						} else {
							console.log(`Линия между узлами ${firstNodeForLine.node_id} и ${clickedNode.node_id} уже существует.`); 
						}
						
						// --- ИЗМЕНЕНИЕ ДЛЯ СКВОЗНОГО ПОСТРОЕНИЯ ЛИНИЙ ---
						// Если линия успешно создана, новый узел становится первым для следующей линии
						firstNodeForLine = clickedNode; // Теперь clickedNode (второй узел) становится новым firstNodeForLine
						selectedNode = clickedNode; // Выделяем новый активный узел
						selectedElement = null; // Сбрасываем выделение линии
						selectedElements = [{ type: 'node', element: clickedNode }]; // Выделяем только этот узел
						// --- КОНЕЦ ИЗМЕНЕНИЯ ---

					} else {
						// Клик по тому же узлу или пустому месту, когда линия ожидала второй узел
						firstNodeForLine = null; // Отменяем построение линии
						selectedNode = null; 
						selectedElement = null;
						selectedElements = []; // Сбрасываем все выделения
					}
				} 
				// --- СЦЕНАРИЙ 2: Клавиша Ctrl/Cmd нажата (множественный выбор) ---
				// Этот блок выполняется, если firstNodeForLine НЕ активен, но Ctrl/Cmd нажат
				else if (isCtrlPressed) { 
					if (clickedNode) {
						// Если клик по узлу с Ctrl: добавить/удалить узел из множественного выделения
						const existingIndex = selectedElements.findIndex(el => el.type === 'node' && el.element.node_id === clickedNode.node_id);
						if (existingIndex > -1) {
							selectedElements.splice(existingIndex, 1); // Удалить, если уже выделен
						} else {
							selectedElements.push({ type: 'node', element: clickedNode }); // Добавить, если не выделен
						}
					} else if (clickedLine) {
						// Если клик по линии с Ctrl: добавить/удалить линию из множественного выделения
						const existingIndex = selectedElements.findIndex(el => el.type === 'line' && el.element.elem_id === clickedLine.elem_id);
						if (existingIndex > -1) {
							selectedElements.splice(existingIndex, 1); // Удалить, если уже выделен
						} else {
							selectedElements.push({ type: 'line', element: clickedLine }); // Добавить, если не выделен
						}
					} else {
						// Клик по пустому месту с Ctrl/Cmd: не меняем текущее множественное выделение
					}
					// В режиме CTRL-выбора, одиночные переменные selectedNode/selectedElement всегда будут null
					selectedNode = null;
					selectedElement = null;
					firstNodeForLine = null; // Всегда очищаем firstNodeForLine в режиме выбора
				}
				// --- СЦЕНАРИЙ 3: Обычный левый клик (одиночный выбор или создание узла) ---
				// Этот блок выполняется, если firstNodeForLine НЕ активен И Ctrl/Cmd НЕ нажат
				else { 
					if (clickedNode) {
						// Обычный клик по узлу: выделяем его И устанавливаем как первый для линии
						// ЭТО ПОВЕДЕНИЕ ВАШЕГО ИСХОДНОГО КОДА, КОТОРОЕ АВТОМАТИЧЕСКИ НАЧИНАЕТ ПОСТРОЕНИЕ ЛИНИИ
						firstNodeForLine = clickedNode; 
						selectedNode = clickedNode; // Одиночное выделение узла
						selectedElement = null;
						selectedElements = [{ type: 'node', element: clickedNode }]; // Обновляем множественное выделение для одиночного выбора
					} else if (clickedLine) {
						// Обычный клик по линии: выделяем только эту линию
						selectedElement = clickedLine; // Одиночное выделение линии
						selectedNode = null;
						firstNodeForLine = null; // Сбрасываем firstNodeForLine
						selectedElements = [{ type: 'line', element: clickedLine }]; // Обновляем множественное выделение для одиночного выбора
					} else { // Клик по пустому месту
						if (selectedNode || selectedElement || firstNodeForLine || selectedElements.length > 0) { 
							// Если что-то было выделено (одиночно или множественно) или линия была наполовину, сбрасываем все
							selectedNode = null;
							selectedElement = null;
							firstNodeForLine = null;
							selectedElements = []; // Очищаем множественное выделение
						} else {
							// Ничего не выделено/не наполовину, клик по пустому месту: создаем новый узел (ВАША ИСХОДНАЯ ЛОГИКА)
							const placeX = snapToGrid ? mouse.snappedX : mouse.worldX; 
							const placeY = snapToGrid ? mouse.snappedY : mouse.worldY;
							const newNode = { node_id: nextNodeId++, x: placeX, y: placeY }; 
							nodes.push(newNode); 
							console.log(`Узел ${newNode.node_id} создан по координатам (${newNode.x.toFixed(3)}, ${newNode.y.toFixed(3)}).`);
							
							// После создания узла, выделения быть не должно
							selectedNode = null; 
							selectedElement = null;
							firstNodeForLine = null; 
							selectedElements = [];
						}
					}
				}
			} else if (e.button === 1) { // Средний клик для панорамирования
				isPanning = true;
				lastPanX = e.clientX;
				lastPanY = e.clientY;
				canvas.style.cursor = 'grabbing';
			}
			updatePropertiesPanel(); // В конце всегда обновляем панель свойств
			draw(); // В конце всегда перерисовываем холст
		}

        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
            
            const worldCoords = screenToWorld(mouse.x, mouse.y); 
            mouse.worldX = worldCoords.x;
            mouse.worldY = worldCoords.y; 
            const snapped = getSnappedCoordinates(worldCoords.x, worldCoords.y);
            mouse.snappedX = snapped.x;
            mouse.snappedY = snapped.y; 

            if (isPanning) {
                const dx = e.clientX - lastPanX;
                const dy = e.clientY - lastPanY;
                panX += dx;
                panY += dy; 
                lastPanX = e.clientX;
                lastPanY = e.clientY;
            } else {
                hoveredElement = findElementAt(mouse.worldX, mouse.worldY); 
            }
            draw();
        }

        function handleMouseUp(e) {
            if (e.button === 1 && isPanning) { 
                isPanning = false;
                canvas.style.cursor = 'crosshair';
            }
        }

        function handleWheelZoom(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX_screen = e.clientX - rect.left;
            const mouseY_screen = e.clientY - rect.top;

            const worldBeforeZoom = screenToWorld(mouseX_screen, mouseY_screen); 

            const zoomFactor = 1.1;
            let newScale = scale;
            if (e.deltaY < 0) newScale *= zoomFactor; 
            else newScale /= zoomFactor; 
            
            const minScaleFactor = 0.001; 
            const maxScaleFactor = 300000; 
            scale = Math.max(minScaleFactor, Math.min(maxScaleFactor, newScale));
            
            const worldAfterZoom_if_pan_did_not_change = {
                x: (mouseX_screen - panX) / scale, 
                y: -(mouseY_screen - panY) / scale  
            };

            panX += (worldAfterZoom_if_pan_did_not_change.x - worldBeforeZoom.x) * scale;
            panY += (worldAfterZoom_if_pan_did_not_change.y - worldBeforeZoom.y) * (-scale); 

            draw();
        }


        function handleContextMenu(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const worldCoords = screenToWorld(e.clientX - rect.left, e.clientY - rect.top); 
            contextMenuTarget = findElementAt(worldCoords.x, worldCoords.y); 

            if (contextMenuTarget) {
                deleteNodeItem.style.display = contextMenuTarget.type === 'node' ? 'block' : 'none';
                deleteLineItem.style.display = contextMenuTarget.type === 'line' ? 'block' : 'none';
                customContextMenu.style.left = `${e.clientX}px`;
                customContextMenu.style.top = `${e.clientY}px`;
                customContextMenu.classList.remove('hidden');
            } else {
                hideContextMenu();
            }
        }
        
        function handleClickOutsideContextMenu(e) {
            if (!customContextMenu.contains(e.target)) {
                hideContextMenu();
            }
        }

        function hideContextMenu() {
            customContextMenu.classList.add('hidden');
            contextMenuTarget = null;
        }

        // Element Interaction & Deletion
        function findNodeAt(worldX_currentUnit, worldY_currentUnit) {
            const clickRadiusWorld = 12 / scale; 
            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i]; 
                const dist = Math.sqrt((node.x - worldX_currentUnit)**2 + (node.y - worldY_currentUnit)**2);
                if (dist < clickRadiusWorld) return node;
            }
            return null;
        }

        function findLineAt(worldX_currentUnit, worldY_currentUnit) {
            const clickRadiusWorld = 6 / scale; 
            for (let i = lines.length - 1; i >= 0; i--) {
                const line = lines[i];
                const n1 = nodes.find(n => n.node_id === line.nodeId1); 
                const n2 = nodes.find(n => n.node_id === line.nodeId2); 
                if (n1 && n2) { 
                    const lenSq = (n1.x - n2.x)**2 + (n1.y - n2.y)**2; 
                    if (lenSq === 0) continue; 
                    let t = ((worldX_currentUnit - n1.x) * (n2.x - n1.x) + (worldY_currentUnit - n1.y) * (n2.y - n1.y)) / lenSq;
                    t = Math.max(0, Math.min(1, t));
                    const projX = n1.x + t * (n2.x - n1.x); 
                    const projY = n1.y + t * (n2.y - n1.y); 
                    const dist = Math.sqrt((worldX_currentUnit - projX)**2 + (worldY_currentUnit - projY)**2); 
                    if (dist < clickRadiusWorld) return line;
                }
            }
            return null;
        }

        function findElementAt(worldX_currentUnit, worldY_currentUnit) {
            const node = findNodeAt(worldX_currentUnit, worldY_currentUnit);
            if (node) return { type: 'node', element: node };
            const line = findLineAt(worldX_currentUnit, worldY_currentUnit);
            if (line) return { type: 'line', element: line };
            return null;
        }

        function handleDeleteNode() {
            if (contextMenuTarget && contextMenuTarget.type === 'node') {
                const nodeIdToDelete = contextMenuTarget.element.node_id; 
                nodes = nodes.filter(node => node.node_id !== nodeIdToDelete); 
                lines = lines.filter(line => line.nodeId1 !== nodeIdToDelete && line.nodeId2 !== nodeIdToDelete);
                restrictions = restrictions.filter(res => res.node_id !== nodeIdToDelete);
				nodeLoads = nodeLoads.filter(load => load.target_id !== nodeIdToDelete);

                if (firstNodeForLine && firstNodeForLine.node_id === nodeIdToDelete) firstNodeForLine = null; 
                if (selectedNode && selectedNode.node_id === nodeIdToDelete) selectedNode = null; 
                hideContextMenu();
                updatePropertiesPanel(); 
                draw();
            }
        }

        function handleDeleteLine() {
             if (contextMenuTarget && contextMenuTarget.type === 'line') {
                lines = lines.filter(line => line.elem_id !== contextMenuTarget.element.elem_id); 
                hideContextMenu();
                draw();
            }
        }

		function clearAll() {
            nodes = [];
            lines = [];
            restrictions = [];
            nodeLoads = [];
			elementLoads = [];
            nextNodeId = 1;
            nextElemId = 1;
            nextLoadId = 1;
			nextElementLoadId = 1;
            selectedNode = null;
            firstNodeForLine = null;
            selectedElement = null;
            updatePropertiesPanel();
            draw();
        }

        // Node Properties Panel Logic
        function updatePropertiesPanel() {
            const propertiesPanel = document.getElementById('propertiesPanel');
            const nodePropertiesContent = document.getElementById('nodePropertiesContent');

            if (selectedNode) {
                propertiesPanel.style.display = 'block';

                const currentForceDisplayUnit = forceUnitsSelect.value; 
                const currentLengthDisplayUnit = unitsSelect.value;
                const currentMomentDisplayUnit = currentForceDisplayUnit + '*' + currentLengthDisplayUnit;

                let loadsHtml = '';
                const nodeSpecificLoads = nodeLoads.filter(load => load.target_id === selectedNode.node_id);
                if (nodeSpecificLoads.length === 0) {
                    loadsHtml += '<p class="text-gray-500 text-sm">Нагрузок нет</p>';
                } else {
                    loadsHtml += '<div class="mb-2">';
                    nodeSpecificLoads.forEach(load => {
                        let displayedValue;
                        let displayedUnitString;

                        if (load.type === 'point_force') {
                            displayedValue = convertForce(load.value, load.unit, currentForceDisplayUnit).toFixed(2);
                            displayedUnitString = currentForceDisplayUnit;
                        } else if (load.type === 'moment') {
                            displayedValue = convertMoment(load.value, load.unit, load.lengthUnit, currentForceDisplayUnit, currentLengthDisplayUnit).toFixed(2);
                            displayedUnitString = currentMomentDisplayUnit;
                        }
                        
                        loadsHtml += `
                            <div class="load-item">
                                <span>${load.type === 'point_force' ? 'F' : 'M'}${load.component !== 'moment' ? load.component.toUpperCase() : ''}: ${displayedValue} ${displayedUnitString}</span>
                                <button data-load-id="${load.load_id}">Удалить</button>
                            </div>
                        `;
                    });
                    loadsHtml += '</div>';
                }

                let currentRestriction = restrictions.find(r => r.node_id === selectedNode.node_id);
                if (!currentRestriction) {
                    currentRestriction = { dx: 0, dy: 0, dr: 0, type: "none" };
                }

                nodePropertiesContent.innerHTML = `
                    <h4 class="font-bold text-gray-700 mb-2">Свойства узла ${selectedNode.node_id}</h4>
                    <div class="property-group">
                        <label for="nodeX">X:</label>
                        <input type="number" id="nodeX" value="${selectedNode.x.toFixed(2)}">
                        <label for="nodeY">Y:</label>
                        <input type="number" id="nodeY" value="${selectedNode.y.toFixed(2)}">
                    </div>
                    <div class="property-group">
                        <h4 class="font-bold text-gray-700 mb-2">Закрепления</h4>
                        <div id="restrictionIconsContainer" class="flex flex-wrap gap-2 mb-4">
                            </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="restrictX" class="mr-2" ${currentRestriction.dx === 1 ? 'checked' : ''}>
                            <label for="restrictX">dx</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="restrictY" class="mr-2" ${currentRestriction.dy === 1 ? 'checked' : ''}>
                            <label for="restrictY">dy</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="restrictR" class="mr-2" ${currentRestriction.dr === 1 ? 'checked' : ''}>
                            <label for="restrictR">dr</label>
                        </div>
                    </div>
                    <div class="property-group">
                        <h4 class="font-bold text-gray-700 mb-2">Нагрузки</h4>
                        <div id="nodeLoadsList" class="mb-4">
                            ${loadsHtml} </div>
                        <div class="load-input-group">
                            <label for="addForceX" class="sr-only">Сила X</label>
                            <input type="number" id="addForceX" placeholder="Fx">
                            <span id="currentForceUnitDisplay_Fx" class="ml-2 font-semibold text-gray-700"></span> 
                            <button id="addForceXBtn">Добавить Fx</button>
                        </div>
                        <div class="load-input-group">
                            <label for="addForceY" class="sr-only">Сила Y</label>
                            <input type="number" id="addForceY" placeholder="Fy">
                            <span id="currentForceUnitDisplay_Fy" class="ml-2 font-semibold text-gray-700"></span>
                            <button id="addForceYBtn">Добавить Fy</button>
                        </div>
                        <div class="load-input-group">
                            <label for="addMoment" class="sr-only">Момент</label>
                            <input type="number" id="addMoment" placeholder="M">
                            <span id="currentForceUnitDisplay_M" class="ml-2 font-semibold text-gray-700"></span>
                            <button id="addMomentBtn">Добавить M</button>
                        </div>
                    </div>
                `;

                const nodeXInput = document.getElementById('nodeX');
                const nodeYInput = document.getElementById('nodeY');

                const restrictXCheckbox = document.getElementById('restrictX');
                const restrictYCheckbox = document.getElementById('restrictY');
                const restrictRCheckbox = document.getElementById('restrictR');
                const restrictionIconsContainer = document.getElementById('restrictionIconsContainer');

                const nodeLoadsList = document.getElementById('nodeLoadsList');
                const addForceXInput = document.getElementById('addForceX');
                const addForceXBtn = document.getElementById('addForceXBtn');
                const addForceYInput = document.getElementById('addForceY');
                const addForceYBtn = document.getElementById('addForceYBtn');
                const addMomentInput = document.getElementById('addMoment');
                const addMomentBtn = document.getElementById('addMomentBtn');

                nodeXInput.value = selectedNode.x.toFixed(3);
                nodeYInput.value = selectedNode.y.toFixed(3);

                nodeXInput.addEventListener('change', (e) => {
                    const newValue = parseFloat(e.target.value);
                    if (!isNaN(newValue)) {
                        selectedNode.x = newValue;
                        draw();
                    }
                });

                nodeYInput.addEventListener('change', (e) => {
                    const newValue = parseFloat(e.target.value);
                    if (!isNaN(newValue)) {
                        selectedNode.y = newValue;
                        draw();
                    }
                });

                const updateRestriction = () => {
                    let updated = false;
                    restrictions = restrictions.filter(r => {
                        if (r.node_id === selectedNode.node_id) {
                            r.dx = restrictXCheckbox.checked ? 1 : 0;
                            r.dy = restrictYCheckbox.checked ? 1 : 0;
                            r.dr = restrictRCheckbox.checked ? 1 : 0;
                            updated = true;
                            if (r.dx === 0 && r.dy === 0 && r.dr === 0) {
                                return false;
                            }
                        }
                        return true;
                    });

                    if (!updated && (restrictXCheckbox.checked || restrictYCheckbox.checked || restrictRCheckbox.checked)) {
                        restrictions.push({
                            node_id: selectedNode.node_id,
                            dx: restrictXCheckbox.checked ? 1 : 0,
                            dy: restrictYCheckbox.checked ? 1 : 0,
                            dr: restrictRCheckbox.checked ? 1 : 0
                        });
                    }
                    draw();
                    renderRestrictionIcons();
                };

                restrictXCheckbox.addEventListener('change', updateRestriction);
                restrictYCheckbox.addEventListener('change', updateRestriction);
                restrictRCheckbox.addEventListener('change', updateRestriction);

                const renderRestrictionIcons = () => {
                    restrictionIconsContainer.innerHTML = '';

                    currentRestriction = restrictions.find(r => r.node_id === selectedNode.node_id);
                    if (!currentRestriction) {
                        currentRestriction = { dx: 0, dy: 0, dr: 0, type: "none" };
                    }

                    const noRestrictionBtn = document.createElement('button');
                    noRestrictionBtn.className = `restriction-icon-btn ${currentRestriction.dx === 0 && currentRestriction.dy === 0 && currentRestriction.dr === 0 ? 'active' : ''}`;
                    noRestrictionBtn.innerHTML = '<span class="no-restriction-text">Ø</span>';
                    noRestrictionBtn.title = 'Нет закрепления';
                    noRestrictionBtn.addEventListener('click', () => {
                        restrictions = restrictions.filter(r => r.node_id !== selectedNode.node_id);
                        restrictXCheckbox.checked = false;
                        restrictYCheckbox.checked = false;
                        restrictRCheckbox.checked = false;
                        updateRestriction();
                    });
                    restrictionIconsContainer.appendChild(noRestrictionBtn);

                    for (const typeKey in restrictionTypes) {
                        const type = restrictionTypes[typeKey];
                        if (type.icon) {
                            const btn = document.createElement('button');
                            btn.className = `restriction-icon-btn ${currentRestriction.dx === type.dx && currentRestriction.dy === type.dy && currentRestriction.dr === type.dr ? 'active' : ''}`;
                            btn.innerHTML = `<img src="icons/${type.icon}" alt="${type.label}" title="${type.label}">`;
                            btn.title = type.label;
                            btn.addEventListener('click', () => {
                                restrictions = restrictions.filter(r => r.node_id !== selectedNode.node_id);
                                restrictions.push({
                                    node_id: selectedNode.node_id,
                                    dx: type.dx,
                                    dy: type.dy,
                                    dr: type.dr
                                });
                                restrictXCheckbox.checked = type.dx === 1;
                                restrictYCheckbox.checked = type.dy === 1;
                                restrictRCheckbox.checked = type.dr === 1;
                                updateRestriction();
                            });
                            restrictionIconsContainer.appendChild(btn);
                        }
                    }
                };

                renderRestrictionIcons();

                const renderNodeLoads = () => {
                    nodeLoadsList.innerHTML = '';
                    const loadsForSelectedNode = nodeLoads.filter(load => load.target_id === selectedNode.node_id);

                    if (loadsForSelectedNode.length === 0) {
                        nodeLoadsList.innerHTML = '<p class="text-gray-500 text-sm">Нагрузок нет</p>';
                    } else {
                        const currentForceDisplayUnit = forceUnitsSelect.value; 
                        const currentLengthDisplayUnit = unitsSelect.value;
                        const currentMomentDisplayUnit = currentForceDisplayUnit + '*' + currentLengthDisplayUnit;

                        nodeLoadsList.innerHTML = '';
                        nodeSpecificLoads.forEach(load => { 
                            let displayedValue;
                            let displayedUnitString;

                            if (load.type === 'point_force') {
                                displayedValue = convertForce(load.value, load.unit, currentForceDisplayUnit).toFixed(2);
                                displayedUnitString = currentForceDisplayUnit;
                            } else if (load.type === 'moment') {
                                displayedValue = convertMoment(load.value, load.unit, load.lengthUnit, currentForceDisplayUnit, currentLengthDisplayUnit).toFixed(2);
                                displayedUnitString = currentMomentDisplayUnit;
                            }
                            
                            let loadLabel = '';
                            switch (load.type) {
                                case 'point_force':
                                    loadLabel = `F${load.component.toUpperCase()}: ${displayedValue} ${displayedUnitString}`; 
                                    break;
                                case 'moment':
                                    loadLabel = `M: ${displayedValue} ${displayedUnitString}`; 
                                    break;
                            }

                            const loadItemDiv = document.createElement('div');
                            loadItemDiv.className = 'load-item';
                            loadItemDiv.innerHTML = `
                                <span>${loadLabel}</span>
                                <button data-load-id="${load.load_id}">Удалить</button>
                            `;
                            nodeLoadsList.appendChild(loadItemDiv);
                        });

                        nodeLoadsList.querySelectorAll('.load-item button').forEach(button => {
                            button.addEventListener('click', (e) => {
                                const loadIdToDelete = parseInt(e.target.dataset.loadId);
                                nodeLoads = nodeLoads.filter(load => load.load_id !== loadIdToDelete);
                                renderNodeLoads();
                                draw();
                            });
                        });
                    }
                };

                renderNodeLoads();

                addForceXBtn.addEventListener('click', () => {
                    const value = parseFloat(addForceXInput.value);
                    if (!isNaN(value)) {
                        nodeLoads.push({
                            load_id: nextLoadId++,
                            type: 'point_force',
                            target_id: selectedNode.node_id,
                            component: 'x',
                            value: value,
                            unit: forceUnitsSelect.value
                        });
                        addForceXInput.value = '';
                        renderNodeLoads();
                        draw();
                    }
                });

                addForceYBtn.addEventListener('click', () => {
                    const value = parseFloat(addForceYInput.value);
                    if (!isNaN(value)) {
                        nodeLoads.push({
                            load_id: nextLoadId++,
                            type: 'point_force',
                            target_id: selectedNode.node_id,
                            component: 'y',
                            value: value,
                            unit: forceUnitsSelect.value
                        });
                        addForceYInput.value = '';
                        renderNodeLoads();
                        draw();
                    }
                });

                addMomentBtn.addEventListener('click', () => {
                    const value = parseFloat(addMomentInput.value);
                    if (!isNaN(value)) {
                        nodeLoads.push({
                            load_id: nextLoadId++,
                            type: 'moment',
                            target_id: selectedNode.node_id,
                            component: 'r',
                            value: value,
                            unit: forceUnitsSelect.value,
                            lengthUnit: unitsSelect.value
                        });
                        addMomentInput.value = '';
                        renderNodeLoads();
                        draw();
                    }
                });

			} else if (selectedElement) {
                propertiesPanel.style.display = 'block';

                const currentForceDisplayUnit = forceUnitsSelect.value;
                const currentLengthDisplayUnit = unitsSelect.value;
                const currentMomentDisplayUnit = `${currentForceDisplayUnit}*${currentLengthDisplayUnit}`;
                const currentDistributedForceUnit = `${currentForceDisplayUnit}/${currentLengthDisplayUnit}`;
				
                // --- Формирование опций для выпадающего списка материалов ---
                let materialOptionsHtml = '<option value="">Не выбрано</option>'; // Опция по умолчанию
                modelMaterials.forEach(mat => {
                    // Проверяем, назначен ли этот материал текущему элементу
                    const isSelected = selectedElement.materialId === mat.id ? 'selected' : '';
                    materialOptionsHtml += `<option value="${mat.id}" ${isSelected}>${mat.name} (${mat.standard})</option>`;
                });

                // --- Получаем имя назначенного материала для отображения ---
                let assignedMaterialName = 'Нет';
                if (selectedElement.materialId) {
                    const assignedMat = modelMaterials.find(m => m.id === selectedElement.materialId);
                    if (assignedMat) {
                        assignedMaterialName = `${assignedMat.name} (${assignedMat.standard})`;
                    }
                }				

                let loadsHtml = '';
                const elementSpecificLoads = elementLoads.filter(load => load.target_elem_id === selectedElement.elem_id);
                if (elementSpecificLoads.length === 0) {
                    loadsHtml += '<p class="text-gray-500 text-sm">Нагрузок нет</p>';
                } else {
                    loadsHtml += '<div class="mb-2">';
                    elementSpecificLoads.forEach(load => {
                        let displayedValue;
                        let displayedUnitString;
						
                        const storedForceUnit = load.unit.split('/')[0];
                        const storedLengthUnit = load.unit.split('/')[1];
						
                        const targetForceUnit = currentDistributedForceUnit.split('/')[0];
                        const targetLengthUnit = currentDistributedForceUnit.split('/')[1];
						
                        if (isNaN(load.startValue)) {
                            displayedValue = "NaN";
                        } else {
                            displayedValue = convertDistributedForce(load.startValue, storedForceUnit, storedLengthUnit, targetForceUnit, targetLengthUnit).toFixed(5);
                        }
                        displayedUnitString = currentDistributedForceUnit;

                        loadsHtml += `
                            <div class="load-item">
                                <span>q${load.component.toUpperCase()}: ${displayedValue} ${displayedUnitString}</span>
                                <button data-load-id="${load.load_id}" data-load-type="distributed">Удалить</button>
                            </div>
                        `;
                    });
                    loadsHtml += '</div>';
                }

                // НОВЫЙ ВНУТРЕННИЙ HTML ДЛЯ ПАНЕЛИ СВОЙСТВ ЭЛЕМЕНТА
                nodePropertiesContent.innerHTML = `
                    <h4 class="font-bold text-gray-700 mb-2">Свойства элемента ${selectedElement.elem_id}</h4>
                    <div class="property-group">
                        <p>Начальный узел: ${selectedElement.nodeId1}</p>
                        <p>Конечный узел: ${selectedElement.nodeId2}</p>
                    </div>

                    <!-- НОВАЯ СЕКЦИЯ: Назначение материала -->
                    <div class="property-group">
                        <h4 class="font-bold text-gray-700 mb-2">Назначение материала</h4>
                        <div class="flex items-center gap-2 mb-2">
                            <select id="materialAssignmentSelect" class="flex-grow form-select block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md shadow-sm">
                                ${materialOptionsHtml}
                            </select>
                            <button id="assignMaterialBtn" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                                Выбрать
                            </button>
                        </div>
                        <p class="text-sm text-gray-700">Назначенный материал: <span id="assignedMaterialDisplay" class="font-semibold italic">${assignedMaterialName}</span></p>
                    </div>

                    <!-- Существующий блок: Распределенные нагрузки -->
                    <div class="property-group">
                        <h4 class="font-bold text-gray-700 mb-2">Распределенные нагрузки</h4>
                        <div id="elementLoadsList" class="mb-4">
                            ${loadsHtml}
                        </div>
                        <div class="load-input-group">
                            <label for="addDistributedForceX" class="sr-only">Равномерная нагрузка X</label>
                            <input type="number" id="addDistributedForceX" placeholder="qX">
                            <span id="currentDistributedForceUnitDisplay_qX" class="ml-2 font-semibold text-gray-700">${currentDistributedForceUnit}</span>
                            <button id="addDistributedForceXBtn">Добавить qX</button>
                        </div>
                        <div class="load-input-group">
                            <label for="addDistributedForceY" class="sr-only">Равномерная нагрузка Y</label>
                            <input type="number" id="addDistributedForceY" placeholder="qY">
                            <span id="currentDistributedForceUnitDisplay_qY" class="ml-2 font-semibold text-gray-700">${currentDistributedForceUnit}</span>
                            <button id="addDistributedForceYBtn">Добавить qY</button>
                        </div>
						<div class="property-group">
							<h4 class="font-bold text-gray-700 mb-2">Разбить стержень</h4>
							<div class="flex items-center space-x-2 mb-2">
								<input type="number" id="splitSegmentsInput" value="2" min="2" class="flex-grow form-input block w-full pl-3 pr-3 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md">
								<button id="splitElementBtn" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">Разбить</button>
							</div>
						</div>
                    </div>
                `;

                const elementLoadsList = document.getElementById('elementLoadsList');
                const addDistributedForceXInput = document.getElementById('addDistributedForceX');
                const addDistributedForceXBtn = document.getElementById('addDistributedForceXBtn');
                const addDistributedForceYInput = document.getElementById('addDistributedForceY');
                const addDistributedForceYBtn = document.getElementById('addDistributedForceYBtn');

                const renderElementLoads = () => {
                    elementLoadsList.innerHTML = '';
                    const loadsForSelectedElement = elementLoads.filter(load => load.target_elem_id === selectedElement.elem_id);

                    if (loadsForSelectedElement.length === 0) {
                        elementLoadsList.innerHTML = '<p class="text-gray-500 text-sm">Нагрузок нет</p>';
                    } else {
                        const currentForceDisplayUnit = forceUnitsSelect.value;
                        const currentLengthDisplayUnit = unitsSelect.value;
                        const currentDistributedForceUnit = `${currentForceDisplayUnit}/${currentLengthDisplayUnit}`;

                        loadsForSelectedElement.forEach(load => {
                            const storedForceUnit = load.unit.split('/')[0];
                            const storedLengthUnit = load.unit.split('/')[1];
                            const targetForceUnit = currentDistributedForceUnit.split('/')[0];
                            const targetLengthUnit = currentDistributedForceUnit.split('/')[1];

                            const displayedValue = parseFloat(convertDistributedForce(load.startValue, storedForceUnit, storedLengthUnit, targetForceUnit, targetLengthUnit).toFixed(3));
                            const displayedUnitString = currentDistributedForceUnit;
                            
                            const loadItemDiv = document.createElement('div');
                            loadItemDiv.className = 'load-item';
                            loadItemDiv.innerHTML = `
                                <span>q${load.component.toUpperCase()}: ${displayedValue} ${displayedUnitString}</span>
                                <button data-load-id="${load.load_id}" data-load-type="distributed">Удалить</button>
                            `;
                            elementLoadsList.appendChild(loadItemDiv);
                        });

                        elementLoadsList.querySelectorAll('.load-item button').forEach(button => {
                            button.addEventListener('click', (e) => {
                                const loadIdToDelete = parseInt(e.target.dataset.loadId);
                                elementLoads = elementLoads.filter(load => load.load_id !== loadIdToDelete);
                                renderElementLoads();
                                draw();
                            });
                        });
                    }
                };

                renderElementLoads();

                addDistributedForceXBtn.addEventListener('click', () => {
                    const value = parseFloat(addDistributedForceXInput.value);
                    if (!isNaN(value)) {
                        elementLoads.push({
                            load_id: nextElementLoadId++,
                            target_elem_id: selectedElement.elem_id,
                            type: 'uniform', 
                            component: 'x',
                            startValue: value,
                            endValue: value,
                            unit: `${forceUnitsSelect.value}/${unitsSelect.value}`,
                            startPosition: 0, 
                            endPosition: 1 
                        });
                        addDistributedForceXInput.value = '';
                        renderElementLoads();
                        draw();
                    }
                });

                addDistributedForceYBtn.addEventListener('click', () => {
                    const value = parseFloat(addDistributedForceYInput.value);
                    if (!isNaN(value)) {
                        elementLoads.push({
                            load_id: nextElementLoadId++,
                            target_elem_id: selectedElement.elem_id,
                            type: 'uniform',
                            component: 'y',
                            startValue: value,
                            endValue: value,
                            unit: `${forceUnitsSelect.value}/${unitsSelect.value}`,
                            startPosition: 0, 
                            endPosition: 1 
                        });
                        addDistributedForceYInput.value = '';
                        renderElementLoads();
                        draw();
                    }
                });
				
                const splitSegmentsInput = document.getElementById('splitSegmentsInput');
                const splitElementBtn = document.getElementById('splitElementBtn');
				
                // НОВЫЕ: Получаем ссылки на элементы для назначения материала
                const materialAssignmentSelect = document.getElementById('materialAssignmentSelect');
                const assignMaterialBtn = document.getElementById('assignMaterialBtn');
                const assignedMaterialDisplay = document.getElementById('assignedMaterialDisplay');

                // НОВОЕ: Добавляем слушатель для кнопки "Выбрать"
                if (assignMaterialBtn && selectedElement) { // Проверяем, что кнопка и элемент существуют
                    // Удаляем старый слушатель, чтобы избежать дублирования при перерисовке панели
                    // Создаем анонимную функцию-обертку для слушателя
                    // Это позволяет нам иметь уникальный слушатель для каждого рендера панели
                    // и при этом безопасно его добавлять без риска дублирования.
                    // Для более сложных сценариев можно использовать .removeEventListener
                    // с именованной функцией, но для динамически генерируемых элементов
                    // это подходит.
                    assignMaterialBtn.onclick = () => { // Используем onclick вместо addEventListener для простоты перезаписи
                        const newMaterialId = materialAssignmentSelect.value;

                        if (selectedElement) {
                            // Если пользователь выбрал пустую опцию "Не выбрано"
                            if (newMaterialId === "") {
                                selectedElement.materialId = null; // Сброс назначенного материала
                                console.log(`Материал для элемента ${selectedElement.elem_id} сброшен.`);
                            } else {
                                // Назначаем новый материал
                                selectedElement.materialId = newMaterialId;
                                const assignedMat = modelMaterials.find(m => m.id === newMaterialId);
                                if (assignedMat) {
                                    console.log(`Материал "${assignedMat.name}" назначен элементу ${selectedElement.elem_id}.`);
                                } else {
                                    console.warn(`Выбранный материал ID "${newMaterialId}" не найден в modelMaterials.`);
                                }
                            }
                            
                            // Обновляем панель свойств, чтобы отобразить изменения
                            updatePropertiesPanel();
                            // Перерисовываем канвас, если есть какая-либо визуализация материала
                            draw(); 
                        }
                    };
                }			

                splitElementBtn.addEventListener('click', () => {
                    if (!selectedElement) return;

                    const numSegments = parseInt(splitSegmentsInput.value, 10);
                    if (isNaN(numSegments) || numSegments < 2) {
                        console.error("Некорректное количество участков для разбиения. Должно быть не менее 2.");
                        return;
                    }

                    const originalLine = selectedElement;
                    const node1 = nodes.find(n => n.node_id === originalLine.nodeId1);
                    const node2 = nodes.find(n => n.node_id === originalLine.nodeId2);

                    if (!node1 || !node2) {
                        console.error("Не найдены узлы для выбранного элемента.");
                        return;
                    }

                    lines = lines.filter(line => line.elem_id !== originalLine.elem_id);
                    console.log(`Удален стержень с ID: ${originalLine.elem_id}`);

                    elementLoads = elementLoads.filter(load => load.target_elem_id === originalLine.elem_id);
                    console.log(`Удалены равномерно-распределенные нагрузки для стержня ${originalLine.elem_id}`);

                    const newNodes = [];
                    const newLines = [];
                    
                    const dx = node2.x - node1.x;
                    const dy = node2.y - node1.y;

                    for (let i = 1; i < numSegments; i++) {
                        const ratio = i / numSegments;
                        const newNodeX = node1.x + dx * ratio;
                        const newNodeY = node1.y + dy * ratio;

                        const newNode = { 
                            node_id: nextNodeId++, 
                            x: newNodeX, 
                            y: newNodeY 
                        };
                        newNodes.push(newNode);
                        console.log(`Добавлен новый узел ${newNode.node_id} по координатам (${newNode.x.toFixed(3)}, ${newNode.y.toFixed(3)})`);
                    }

                    const allSegmentNodes = [node1, ...newNodes, node2]; 

                    for (let i = 0; i < allSegmentNodes.length - 1; i++) {
                        const startNode = allSegmentNodes[i];
                        const endNode = allSegmentNodes[i + 1];

                        const newLine = { 
                            elem_id: nextElemId++, 
                            nodeId1: startNode.node_id, 
                            nodeId2: endNode.node_id, 
                            structural_type: originalLine.structural_type || 'beam' 
                        };
                        newLines.push(newLine);
                        console.log(`Добавлен новый стержень ${newLine.elem_id} между узлами ${startNode.node_id} и ${endNode.node_id}`);
                    }

                    nodes.push(...newNodes);
                    lines.push(...newLines);

                    selectedElement = null;
                    selectedNode = null;
                    firstNodeForLine = null;

                    updatePropertiesPanel();
                    draw();
                });

            } else if (selectedElements.length > 1 && selectedElements.every(el => el.type === 'line')) {
                propertiesPanel.style.display = 'block';
                let materialOptionsHtml = '<option value="">Не выбрано</option>';
                modelMaterials.forEach(mat => {
                    materialOptionsHtml += `<option value="${mat.id}">${mat.name} (${mat.standard})</option>`;
                });
                const currentForceDisplayUnit = forceUnitsSelect.value;
                const currentLengthDisplayUnit = unitsSelect.value;
                const currentDistributedForceUnit = `${currentForceDisplayUnit}/${currentLengthDisplayUnit}`;
                nodePropertiesContent.innerHTML = `
                    <h4 class="font-bold text-gray-700 mb-2">Выбрано стержней: ${selectedElements.length}</h4>
                    <div class="property-group">
                        <div class="flex items-center gap-2 mb-2">
                            <select id="multiMaterialSelect" class="flex-grow form-select block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md shadow-sm">
                                ${materialOptionsHtml}
                            </select>
                            <button id="applyMaterialToSelectedBtn" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">Применить</button>
                        </div>
                    </div>
                    <div class="property-group">
                        <h4 class="font-bold text-gray-700 mb-2">Распределенные нагрузки</h4>
                        <div class="load-input-group">
                            <label for="multiDistributedForceX" class="sr-only">Равномерная нагрузка X</label>
                            <input type="number" id="multiDistributedForceX" placeholder="qX">
                            <span id="currentDistributedForceUnitDisplay_multi_qX" class="ml-2 font-semibold text-gray-700">${currentDistributedForceUnit}</span>
                            <button id="multiDistributedForceXBtn">Добавить qX</button>
                        </div>
                        <div class="load-input-group">
                            <label for="multiDistributedForceY" class="sr-only">Равномерная нагрузка Y</label>
                            <input type="number" id="multiDistributedForceY" placeholder="qY">
                            <span id="currentDistributedForceUnitDisplay_multi_qY" class="ml-2 font-semibold text-gray-700">${currentDistributedForceUnit}</span>
                            <button id="multiDistributedForceYBtn">Добавить qY</button>
                        </div>
                    </div>
                `;

                const applyBtn = document.getElementById('applyMaterialToSelectedBtn');
                const selectEl = document.getElementById('multiMaterialSelect');
                if (applyBtn && selectEl) {
                    applyBtn.addEventListener('click', () => {
                        const matId = selectEl.value;
                        selectedElements.forEach(sel => {
                            if (sel.type === 'line') {
                                sel.element.materialId = matId || null;
                            }
                        });
                        updatePropertiesPanel();
                        draw();
                    });
                }

                const multiLoadXInput = document.getElementById('multiDistributedForceX');
                const multiLoadXBtn = document.getElementById('multiDistributedForceXBtn');
                const multiLoadYInput = document.getElementById('multiDistributedForceY');
                const multiLoadYBtn = document.getElementById('multiDistributedForceYBtn');

                if (multiLoadXBtn && multiLoadXInput) {
                    multiLoadXBtn.addEventListener('click', () => {
                        const value = parseFloat(multiLoadXInput.value);
                        if (!isNaN(value)) {
                            selectedElements.forEach(sel => {
                                if (sel.type === 'line') {
                                    elementLoads.push({
                                        load_id: nextElementLoadId++,
                                        target_elem_id: sel.element.elem_id,
                                        type: 'uniform',
                                        component: 'x',
                                        startValue: value,
                                        endValue: value,
                                        unit: `${forceUnitsSelect.value}/${unitsSelect.value}`,
                                        startPosition: 0,
                                        endPosition: 1
                                    });
                                }
                            });
                            multiLoadXInput.value = '';
                            updatePropertiesPanel();
                            draw();
                        }
                    });
                }

                if (multiLoadYBtn && multiLoadYInput) {
                    multiLoadYBtn.addEventListener('click', () => {
                        const value = parseFloat(multiLoadYInput.value);
                        if (!isNaN(value)) {
                            selectedElements.forEach(sel => {
                                if (sel.type === 'line') {
                                    elementLoads.push({
                                        load_id: nextElementLoadId++,
                                        target_elem_id: sel.element.elem_id,
                                        type: 'uniform',
                                        component: 'y',
                                        startValue: value,
                                        endValue: value,
                                        unit: `${forceUnitsSelect.value}/${unitsSelect.value}`,
                                        startPosition: 0,
                                        endPosition: 1
                                    });
                                }
                            });
                            multiLoadYInput.value = '';
                            updatePropertiesPanel();
                            draw();
                        }
                    });
                }

            } else {
                propertiesPanel.style.display = 'block';
                nodePropertiesContent.innerHTML = '<p>Выберите узел или элемент для просмотра его свойств.</p>';
            }
        }
		
        // ====================================================================
        // Материалы: Функции загрузки, отображения и выбора
        // ====================================================================

        let allMaterialsData = {}; // Объект для хранения всех загруженных данных материалов
        let standardsData = []; // Массив для хранения данных стандартов
        let userMaterials = []; // Глобальная переменная для пользовательских материалов

        // --- Сечения ---
        let allSectionsData = {}; // Объект для хранения всех загруженных данных сечений
		
		// НОВОЕ: Массив для хранения материалов, добавленных в текущую модель
        let modelMaterials = []; 

        // Основная функция для загрузки всех данных материалов
        async function loadAllMaterials() {
            try {
                // Сначала загружаем файл стандартов (standards.json)
                const standardsResponse = await fetch('data/standards.json');
                if (!standardsResponse.ok) {
                    throw new Error(`HTTP error! status: ${standardsResponse.status}`);
                }
                standardsData = await standardsResponse.json();
                console.log("Loaded standards.json:", standardsData);

                // Теперь загружаем материалы для каждого стандарта
                for (const standard of standardsData) {
                    // ЕСЛИ materialFile равен "localStorage", используем локальное хранилище
                    if (standard.materialFile === "localStorage") {
                        userMaterials = loadUserMaterialsFromLocalStorage();
                        allMaterialsData[standard.id] = userMaterials;
                        console.log(`Loaded user materials from localStorage for standard ${standard.id}:`, userMaterials);
                    } else {
                        // В противном случае, загружаем файл JSON по указанному пути
                        const filePath = standard.materialFile; 
                        if (!filePath) {
                            console.warn(`Warning: 'materialFile' property not found for standard '${standard.id}'. Skipping this standard.`);
                            continue; // Пропускаем, если путь к файлу не указан
                        }

                        const response = await fetch(filePath); 
                        if (!response.ok) {
                            // Если файл не найден, выводим предупреждение, но не останавливаем загрузку других стандартов
                            console.warn(`Warning: Material file ${filePath} not found or could not be loaded. Skipping this standard.`);
                            continue; 
                        }
                        const data = await response.json();
                        allMaterialsData[standard.id] = data; 
                        console.log(`Loaded ${filePath}:`, data);
                    }
                }

            } catch (error) {
                console.error("Error during initial loading of materials or standards data:", error);
            }
        }

        // Функция для загрузки пользовательских материалов из localStorage
        function loadUserMaterialsFromLocalStorage() {
            try {
                const storedMaterials = localStorage.getItem('userMaterials');
                // Возвращаем распарсенный JSON, или пустой массив, если ничего нет
                return storedMaterials ? JSON.parse(storedMaterials) : [];
            } catch (error) {
                console.error("Error loading user materials from localStorage:", error);
                return []; // Возвращаем пустой массив в случае ошибки
            }
        }

        // Функция для сохранения пользовательских материалов в localStorage
        function saveUserMaterialsToLocalStorage(materials) {
            try {
                localStorage.setItem('userMaterials', JSON.stringify(materials));
                console.log("User materials saved to localStorage:", materials);
            } catch (error) {
                console.error("Error saving user materials to localStorage:", error);
            }
        }

        // НОВАЯ ФУНКЦИЯ: Заполняет выпадающий список "Тип материала"
        // Убедитесь, что эта функция существует как отдельный блок кода!
        function populateMaterialTypeSelect() {
            if (!materialTypeSelect) { // materialTypeSelect должен быть глобально объявлен
                console.error("materialTypeSelect not found. Cannot populate material types.");
                return;
            }

            materialTypeSelect.innerHTML = ''; // Очищаем текущие опции

            // Добавляем опцию "Выберите тип"
            let defaultOption = document.createElement('option');
            defaultOption.value = "";
            defaultOption.textContent = "Выберите тип";
            defaultOption.disabled = true; // Сделать невыбираемым
            defaultOption.selected = true; // Сделать выбранным по умолчанию
            materialTypeSelect.appendChild(defaultOption);

            // Собираем уникальные типы материалов из всех загруженных данных
            const uniqueTypes = new Set();
            for (const standardId in allMaterialsData) {
                if (allMaterialsData.hasOwnProperty(standardId)) {
                    allMaterialsData[standardId].forEach(material => {
                        if (material.type) {
                            uniqueTypes.add(material.type);
                        }
                    });
                }
            }
            
            // Сортируем типы, чтобы они всегда были в одном порядке
            const sortedTypes = Array.from(uniqueTypes).sort();

            // Добавляем уникальные типы в селектор
            sortedTypes.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                // Более понятное отображение (например, "steel" -> "Сталь")
                option.textContent = type === 'steel' ? 'Сталь' : (type === 'concrete' ? 'Бетон' : type); 
                materialTypeSelect.appendChild(option);
            });
        }


        // Функция для заполнения выпадающего списка "Стандарт"
        function populateStandardSelect() {
            const materialStandardSelect = document.getElementById('materialStandardSelect');
            if (materialStandardSelect) {
                materialStandardSelect.innerHTML = ''; // Очищаем текущие опции
                standardsData.forEach(standard => {
                    const option = document.createElement('option');
                    option.value = standard.id;
                    option.textContent = standard.id; // Или standard.name, если хотите более читаемое название
                    materialStandardSelect.appendChild(option);
                });
            }
        }

        // Функция для заполнения выпадающего списка "Класс/Марка"
        function populateMaterialClassSelect() {
            const materialTypeSelect = document.getElementById('materialTypeSelect');
            const materialStandardSelect = document.getElementById('materialStandardSelect');
            const materialClassSelect = document.getElementById('materialClassSelect');

            if (!materialTypeSelect || !materialStandardSelect || !materialClassSelect) {
                console.error("One or more material select elements not found. Cannot populate material class.");
                return;
            }

            const selectedType = materialTypeSelect.value; // 'steel' or 'concrete'
            const selectedStandard = materialStandardSelect.value; // 'GOST_SP', 'EN', etc.
            materialClassSelect.innerHTML = ''; // Очищаем текущие опции

            // Получаем данные для выбранного стандарта
            const materialsFromSelectedStandard = allMaterialsData[selectedStandard];

            if (materialsFromSelectedStandard && materialsFromSelectedStandard.length > 0) {
                // Фильтруем по типу материала
                const filteredMaterials = materialsFromSelectedStandard.filter(
                    mat => mat.type === selectedType // Теперь фильтруем по полю 'type' внутри объектов материала
                );

                if (filteredMaterials.length > 0) {
                    filteredMaterials.forEach(material => {
                        const option = document.createElement('option');
                        option.value = material.id;
                        option.textContent = material.name;
                        materialClassSelect.appendChild(option);
                    });
                } else {
                    const option = document.createElement('option');
                    option.value = "";
                    option.textContent = "Нет доступных материалов";
                    materialClassSelect.appendChild(option);
                }
            } else {
                const option = document.createElement('option');
                option.value = "";
                option.textContent = "Нет данных для выбранного стандарта";
                materialClassSelect.appendChild(option);
            }
        }

        // Инициализация при открытии модального окна или загрузке страницы
        async function initializeMaterialSelectors() {
            await loadAllMaterials(); // Сначала загружаем все данные
			
			if (Object.keys(allMaterialsData).length > 0 && standardsData.length > 0) {
				populateStandardSelect(); 
				populateMaterialTypeSelect();
				populateMaterialClassSelect();
				displaySelectedMaterialProperties(); // <-- НОВОЕ: Вызываем при инициализации
			} else {
				console.warn("No material data or standards data loaded. Material selectors will not be populated.");
				displaySelectedMaterialProperties(); // Все равно вызовите, чтобы очистить отображение
			}
        }

        // Функция для отображения материалов в модальном окне
        function renderMaterialsList() {
            if (!materialListContainer) return; // Защита от вызова до инициализации

            materialListContainer.innerHTML = ''; // Очищаем контейнер перед заполнением
            
            if (allMaterials.length === 0) {
                materialListContainer.innerHTML = '<p>Материалы не найдены в данных.</p>';
                return;
            }

            // Создаем группы для бетона и стали для лучшей организации
            const concreteGroup = document.createElement('div');
            concreteGroup.className = 'mb-4 border-b pb-2'; 
            concreteGroup.innerHTML = '<h3 class="text-lg font-semibold text-gray-700 mb-2">Бетон</h3>';
            materialListContainer.appendChild(concreteGroup);

            const steelGroup = document.createElement('div');
            steelGroup.className = 'mb-4';
            steelGroup.innerHTML = '<h3 class="text-lg font-semibold text-gray-700 mb-2">Сталь</h3>';
            materialListContainer.appendChild(steelGroup);

            allMaterials.forEach(material => {
                const materialDiv = document.createElement('div');
                materialDiv.className = 'bg-gray-100 p-3 rounded-md flex justify-between items-center shadow-sm mb-2'; 
                materialDiv.innerHTML = `
                    <div>
                        <p class="font-medium text-gray-800">${material.name} (${material.type === 'concrete' ? 'Бетон' : 'Сталь'})</p>
                        <p class="text-sm text-gray-600">Модуль упругости (E): ${material.properties.elasticModulus.value} ${material.properties.elasticModulus.unit}</p>
                        <p class="text-sm text-gray-600">Плотность: ${material.properties.density.value} ${material.properties.density.unit}</p>
                    </div>
                    <!-- Кнопка "Выбрать" пока ничего не делает, но HTML для нее есть -->
                    <button class="select-material-btn bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm transition-colors duration-200" data-material-id="${material.id}">Выбрать</button>
                `;
                
                if (material.type === 'concrete') {
                    concreteGroup.appendChild(materialDiv);
                } else if (material.type === 'steel') {
                    steelGroup.appendChild(materialDiv);
                }
            });
            // Мы пока не добавляем обработчик для кнопки "Выбрать" здесь. Это будет на следующем шаге.
        }		
		
		// Функция для добавления материала в модель
        function addSelectedMaterialToModel() {
            const selectedMaterialId = materialClassSelect.value;
            const selectedStandardId = materialStandardSelect.value;

            if (!selectedMaterialId || !selectedStandardId) {
                alert('Пожалуйста, выберите стандарт и класс/марку материала.');
                return;
            }

            // Находим выбранный материал в allMaterialsData
            const materialsForStandard = allMaterialsData[selectedStandardId];
            const materialToAdd = materialsForStandard ? materialsForStandard.find(m => m.id === selectedMaterialId) : null;

            if (materialToAdd) {
                // Проверяем, не добавлен ли этот материал уже в модель
                if (modelMaterials.some(m => m.id === materialToAdd.id)) {
                    alert(`Материал "${materialToAdd.name}" (${materialToAdd.standard}) уже добавлен в модель.`);
                    return;
                }

                modelMaterials.push(materialToAdd);
                console.log("Material added to model:", materialToAdd);
                // Обновляем список материалов в модальном окне
                renderModelMaterialsList();
            } else {
                console.error("Selected material not found:", selectedMaterialId, selectedStandardId);
                alert("Не удалось найти выбранный материал. Пожалуйста, попробуйте еще раз.");
            }
        }
		
		// Функция для отрисовки списка материалов, добавленных в модель
        function renderModelMaterialsList() {
            const modelMaterialList = document.getElementById('modelMaterialList');
            if (!modelMaterialList) {
                console.error("Element #modelMaterialList not found.");
                return;
            }

            modelMaterialList.innerHTML = ''; // Очищаем список

            const noMaterialsMessage = document.getElementById('noMaterialsMessage');
            if (noMaterialsMessage) { // Удаляем сообщение "Нет материалов" если оно есть
                noMaterialsMessage.remove();
            }

            if (modelMaterials.length === 0) {
                // Если материалов нет, добавляем сообщение
                const message = document.createElement('li');
                message.id = 'noMaterialsMessage';
                message.classList.add('text-gray-500', 'italic');
                message.textContent = 'Нет материалов в модели.';
                modelMaterialList.appendChild(message);
            } else {
                modelMaterials.forEach(material => {
                    const listItem = document.createElement('li');
                    listItem.id = `model-material-${material.id}`; // Уникальный ID для элемента списка
                    listItem.classList.add('flex', 'justify-between', 'items-center', 'p-2', 'border-b', 'last:border-b-0');
                    listItem.innerHTML = `
                        <span>${material.name} (${material.standard}) - ${material.type}</span>
                        <button class="remove-material-btn bg-red-500 hover:bg-red-700 text-white text-xs font-bold py-1 px-2 rounded" data-material-id="${material.id}">
                            Удалить
                        </button>
                    `;
                    modelMaterialList.appendChild(listItem);
                });

                // Добавляем слушатели событий для кнопок удаления после их создания
                modelMaterialList.querySelectorAll('.remove-material-btn').forEach(button => {
                    button.addEventListener('click', (event) => {
                        const materialIdToRemove = event.target.dataset.materialId;
                        removeMaterialFromModel(materialIdToRemove);
                    });
                });
            }
        }
		
		// Функция для удаления материала из модели
        function removeMaterialFromModel(materialId) {
            const initialLength = modelMaterials.length;
            modelMaterials = modelMaterials.filter(m => m.id !== materialId);

            if (modelMaterials.length < initialLength) {
                console.log("Material removed from model:", materialId);
                renderModelMaterialsList(); // Перерисовываем список
            } else {
                console.warn("Attempted to remove non-existent material:", materialId);
            }
        }

        // ====================================================================
        // Сечения: Функции загрузки и заполнения списков
        // ====================================================================

        async function loadAllSections() {
            try {
                if (standardsData.length === 0) {
                    const standardsResponse = await fetch('data/standards.json');
                    if (!standardsResponse.ok) {
                        throw new Error(`HTTP error! status: ${standardsResponse.status}`);
                    }
                    standardsData = await standardsResponse.json();
                }

                for (const standard of standardsData) {
                    const filePath = standard.sectionFile;
                    if (!filePath || filePath === 'localStorage') continue;

                    const response = await fetch(filePath);
                    if (!response.ok) {
                        console.warn(`Warning: Section file ${filePath} not found or could not be loaded. Skipping.`);
                        continue;
                    }
                    const data = await response.json();
                    allSectionsData[standard.id] = data;
                }
            } catch (error) {
                console.error('Error loading sections data:', error);
            }
        }

        function populateSectionTypeSelect() {
            if (!sectionTypeSelect) return;
            sectionTypeSelect.innerHTML = '';

            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Выберите тип';
            defaultOption.disabled = true;
            defaultOption.selected = true;
            sectionTypeSelect.appendChild(defaultOption);

            const uniqueTypes = new Set();
            for (const standardId in allSectionsData) {
                allSectionsData[standardId].forEach(sec => {
                    if (sec.type) uniqueTypes.add(sec.type);
                });
            }

            Array.from(uniqueTypes).sort().forEach(type => {
                const opt = document.createElement('option');
                opt.value = type;
                opt.textContent = type;
                sectionTypeSelect.appendChild(opt);
            });
        }

        function populateSectionStandardSelect() {
            if (!sectionStandardSelect) return;
            sectionStandardSelect.innerHTML = '';
            standardsData.forEach(std => {
                if (!std.sectionFile) return;
                const opt = document.createElement('option');
                opt.value = std.id;
                opt.textContent = std.id;
                sectionStandardSelect.appendChild(opt);
            });
        }

        function populateSectionNameSelect() {
            if (!sectionNameSelect) return;
            sectionNameSelect.innerHTML = '';

            const selectedStandard = sectionStandardSelect.value;
            const selectedType = sectionTypeSelect.value;
            const sections = allSectionsData[selectedStandard] || [];

            const filtered = sections.filter(sec => (!selectedType || sec.type === selectedType));

            filtered.forEach(sec => {
                const opt = document.createElement('option');
                opt.value = sec.id;
                opt.textContent = sec.name;
                sectionNameSelect.appendChild(opt);
            });
        }

        async function initializeSectionSelectors() {
            await loadAllSections();
            populateSectionStandardSelect();
            populateSectionTypeSelect();
            populateSectionNameSelect();
        }
		

        function applyRestrictionToSelectedNode(dxValue, dyValue, drValue) {
            if (!selectedNode) return;

            let existingRestrictionIndex = restrictions.findIndex(res => res.node_id === selectedNode.node_id);

            const newRestriction = {
                node_id: selectedNode.node_id,
                dx: dxValue,
                dy: dyValue,
                dr: drValue
            };

            if (dxValue === 0 && dyValue === 0 && drValue === 0) {
                if (existingRestrictionIndex !== -1) {
                    restrictions.splice(existingRestrictionIndex, 1);
                }
            } else {
                if (existingRestrictionIndex !== -1) {
                    restrictions[existingRestrictionIndex] = newRestriction;
                } else {
                    restrictions.push(newRestriction);
                }
            }
            draw();
            updatePropertiesPanel(); 
        }

        // Tooltip
        function updateTooltip() { 
            const panelWidth = propertiesPanel.offsetWidth;

            if (hoveredElement && !isPanning && customContextMenu.classList.contains('hidden')) { 
                let content = '';
                if (hoveredElement.type === 'node') {
                    const node = hoveredElement.element;
                    const restriction = restrictions.find(res => res.node_id === node.node_id);
                    let restrictionInfo = '';
                    if (restriction) {
                        const typeKey = Object.keys(restrictionTypes).find(key => 
                            restrictionTypes[key].dx === restriction.dx &&
                            restrictionTypes[key].dy === restriction.dy &&
                            restrictionTypes[key].dr === restriction.dr
                        );
                        if (typeKey && restrictionTypes[typeKey].label) {
                            restrictionInfo = `\nЗакрепление: ${restrictionTypes[typeKey].label}`;
                        } else {
                             restrictionInfo = `\nЗакрепление: dx=${restriction.dx}, dy=${restriction.dy}, dr=${restriction.dr}`;
                        }
                    }

                    content = `Узел ${node.node_id}\nX: ${node.x.toFixed(3)} ${currentUnit}\nY: ${node.y.toFixed(3)} ${currentUnit}${restrictionInfo}`; 
                } else if (hoveredElement.type === 'line') {
                    const line = hoveredElement.element;
                    const n1 = nodes.find(n => n.node_id === line.nodeId1); 
                    const n2 = nodes.find(n => n.node_id === line.nodeId2); 
                    if (n1 && n2) { 
                        const dx = n2.x - n1.x; 
                        const dy = n2.y - n1.y; 
                        const length = Math.sqrt(dx**2 + dy**2); 
                        content = `Стержень ${line.elem_id}\nДлина: ${length.toFixed(3)} ${currentUnit}`; 
                    }
                }
                
                if (content) {
                    tooltip.innerHTML = content;
                    tooltip.classList.remove('hidden'); 
                    tooltip.style.left = `0px`; 
                    tooltip.style.top = `0px`; 
                    const tooltipRect = tooltip.getBoundingClientRect(); 
                    
                    const offsetX = 15; 
                    const offsetY = 15; 

                    let finalLeft = mouse.x + canvas.getBoundingClientRect().left + offsetX;
                    let finalTop = mouse.y + canvas.getBoundingClientRect().top + offsetY;

                    if (finalLeft + tooltipRect.width > window.innerWidth) {
                        finalLeft = mouse.x + canvas.getBoundingClientRect().left - offsetX - tooltipRect.width; 
                    }

                    if (finalTop + tooltipRect.height > window.innerHeight) {
                        finalTop = mouse.y + canvas.getBoundingClientRect().top - offsetY - tooltipRect.height;
                    }
                    
                    const panelWidth = propertiesPanel.offsetWidth;
                    if (finalLeft < panelWidth) {
                         if (mouse.x + canvas.getBoundingClientRect().left < panelWidth + tooltipRect.width + offsetX) { 
                             finalLeft = panelWidth + offsetX;
                         } else {
                             finalLeft = mouse.x + canvas.getBoundingClientRect().left - offsetX - tooltipRect.width;
                         }
                    }

                    tooltip.style.left = `${finalLeft}px`; 
                    tooltip.style.top = `${finalTop}px`;
                } else {
                    tooltip.classList.add('hidden');
                }
            } else {
                tooltip.classList.add('hidden');
            }
        }
		
		
		// Функция для показа/скрытия полей ввода пользовательского материала
        function toggleCustomMaterialFields(show) {
            const customMaterialFields = document.getElementById('customMaterialFields');
            if (customMaterialFields) {
                if (show) {
                    customMaterialFields.classList.remove('hidden');
                } else {
                    customMaterialFields.classList.add('hidden');
                }
            } else {
                console.warn("Custom material fields container not found.");
            }
        }

        // Функция для добавления нового пользовательского материала
        function addCustomMaterial(name, type, elasticModulus, density, poissonRatio) {
            if (!name || isNaN(elasticModulus) || isNaN(density) || isNaN(poissonRatio)) {
                alert("Пожалуйста, заполните все поля для пользовательского материала (Имя, Модуль упругости, Плотность, Коэффициент Пуассона).");
                return;
            }

            const newMaterial = {
                id: `user_material_${Date.now()}`, // Уникальный ID на основе метки времени
                name: name,
                type: type, // Тип материала (steel, concrete)
                standard: "USER", 
                properties: {
                    elasticModulus: { value: elasticModulus, unit: "MPa" }, // Убедитесь, что unit соответствует вашим ожиданиям
                    density: { value: density, unit: "kg/m^3" },
                    poissonRatio: { value: poissonRatio, unit: "none" },
                }
            };

            userMaterials.push(newMaterial); // Добавляем в глобальный массив пользовательских материалов
            allMaterialsData['USER'] = userMaterials; // Обновляем данные для USER стандарта в общем объекте
            saveUserMaterialsToLocalStorage(userMaterials); // Сохраняем в localStorage

            populateMaterialClassSelect(); // Обновляем выпадающий список "Класс/Марка"

            // Можно выбрать только что добавленный материал в списке
            // if (materialClassSelect) {
            //     materialClassSelect.value = newMaterial.id;
            // }
            alert(`Материал "${name}" успешно добавлен.`);
        }
		
		// Функция для отображения свойств выбранного материала
        function displaySelectedMaterialProperties() {
            const selectedMaterialId = materialClassSelect.value;
            const selectedStandardId = materialStandardSelect.value;

            let selectedMaterial = null;

            // Если оба селектора имеют выбранное значение
            if (selectedMaterialId && selectedStandardId) {
                const materialsForStandard = allMaterialsData[selectedStandardId];
                if (materialsForStandard) {
                    selectedMaterial = materialsForStandard.find(m => m.id === selectedMaterialId);
                }
            }

            // Обновляем UI с свойствами материала
            if (selectedMaterial) {
                propName.textContent = selectedMaterial.name || 'N/A';
                propType.textContent = (selectedMaterial.type === 'steel' ? 'Сталь' : selectedMaterial.type === 'concrete' ? 'Бетон' : selectedMaterial.type || 'N/A');
                
                const standardDisplayName = standardsData.find(s => s.id === selectedMaterial.standard)?.name || selectedMaterial.standard || 'N/A';
                propStandard.textContent = standardDisplayName;
                
                // Модуль упругости
                propElasticModulus.textContent = selectedMaterial.properties && selectedMaterial.properties.elasticModulus ? selectedMaterial.properties.elasticModulus.value.toLocaleString(undefined, { maximumFractionDigits: 2 }) : 'N/A';
                unitElasticModulus.textContent = selectedMaterial.properties && selectedMaterial.properties.elasticModulus ? getUnitText(selectedMaterial.properties.elasticModulus.unit) : ''; // ИСПОЛЬЗУЕМ getUnitText()

                // Плотность
                propDensity.textContent = selectedMaterial.properties && selectedMaterial.properties.density ? selectedMaterial.properties.density.value.toLocaleString(undefined, { maximumFractionDigits: 2 }) : 'N/A';
                unitDensity.textContent = selectedMaterial.properties && selectedMaterial.properties.density ? getUnitText(selectedMaterial.properties.density.unit) : ''; // ИСПОЛЬЗУЕМ getUnitText()

                // Коэффициент Пуассона
                propPoissonRatio.textContent = selectedMaterial.properties && selectedMaterial.properties.poissonRatio ? selectedMaterial.properties.poissonRatio.value.toFixed(3) : 'N/A';
                unitPoissonRatio.textContent = selectedMaterial.properties && selectedMaterial.properties.poissonRatio ? getUnitText(selectedMaterial.properties.poissonRatio.unit) : ''; // ИСПОЛЬЗУЕМ getUnitText()

                // Пример для коэффициента демпфирования (если он будет):
                // propDampingCoefficient.textContent = selectedMaterial.properties && selectedMaterial.properties.dampingCoefficient ? selectedMaterial.properties.dampingCoefficient.value.toFixed(3) : 'N/A';
                // unitDampingCoefficient.textContent = selectedMaterial.properties && selectedMaterial.properties.dampingCoefficient ? getUnitText(selectedMaterial.properties.dampingCoefficient.unit) : '';
            } else {
                // Если материал не выбран или не найден, очищаем поля
                propName.textContent = 'Не выбрано';
                propType.textContent = '';
                propStandard.textContent = '';
                propElasticModulus.textContent = '';
                unitElasticModulus.textContent = '';
                propDensity.textContent = '';
                unitDensity.textContent = '';
                propPoissonRatio.textContent = '';
                unitPoissonRatio.textContent = '';
            }
        }
		
		
let materialTypeSelect;
let materialStandardSelect;
let materialClassSelect;
let sectionTypeSelect;
let sectionStandardSelect;
let sectionNameSelect;
		
		document.addEventListener('DOMContentLoaded', async () => {
            console.log('DOMContentLoaded fired. Starting initialization...'); 
            // --- 1. Получаем ссылки на ВСЕ DOM-элементы здесь, когда они гарантированно существуют ---
            // ... (все ваши существующие document.getElementById(...) для propertiesPanel, canvas, и т.д.) ...

            // --- ДОБАВЬТЕ ЭТУ СТРОКУ, ЕСЛИ ЕЕ НЕТ ---
            // Если materialListContainer нужен глобально, объявите его с 'let' в глобальной области видимости
            // Если он нужен только здесь, то:
            const materialListContainer = document.getElementById('materialListContainer'); 
            console.log('materialListContainer:', materialListContainer); // DEBUG: Проверить, что элемент найден
			
            // Объявляем переменные для кнопок и модального окна ОДИН РАЗ с 'const'
            const openMaterialsModalBtn = document.getElementById('openMaterialsModalBtn'); // Кнопка в topBar
            console.log('openMaterialsModalBtn (topBar):', openMaterialsModalBtn); // DEBUG
            const openMaterialsModalBtnFromPanel = document.getElementById('openMaterialsModalBtnFromPanel'); // Кнопка в propertiesPanel
            console.log('openMaterialsModalBtnFromPanel (panel):', openMaterialsModalBtnFromPanel); // DEBUG
            
            const materialsModal = document.getElementById('materialsModal');
            const closeMaterialsModalBtn = document.getElementById('closeMaterialsModalBtn');
            const closeMaterialsModalBtnBottom = document.getElementById('closeMaterialsModalBtnBottom');

            const openSectionsModalBtn = document.getElementById('openSectionsModalBtn');
            const sectionsModal = document.getElementById('sectionsModal');
            const closeSectionsModalBtn = document.getElementById('closeSectionsModalBtn');

            const toggleNodeNumbersBtn = document.getElementById("toggleNodeNumbersBtn");
            const toggleLineNumbersBtn = document.getElementById("toggleLineNumbersBtn");
			
			// Получаем ссылки на новые DOM-элементы
            const addMaterialToModelBtn = document.getElementById('addMaterialToModelBtn');
            const modelMaterialList = document.getElementById('modelMaterialList'); // Получите ссылку здесь, если она не глобальная
			
            // Получаем ссылки на элементы селекторов материалов
            materialTypeSelect = document.getElementById('materialTypeSelect');
            materialStandardSelect = document.getElementById('materialStandardSelect');
            materialClassSelect = document.getElementById('materialClassSelect');
            sectionTypeSelect = document.getElementById('sectionTypeSelect');
            sectionStandardSelect = document.getElementById('sectionStandardSelect');
            sectionNameSelect = document.getElementById('sectionNameSelect');
			
			// НОВЫЕ: Получаем ссылки на элементы для пользовательского материала
            const customMaterialFields = document.getElementById('customMaterialFields');
            const customMaterialName = document.getElementById('customMaterialName');
            const customElasticModulus = document.getElementById('customElasticModulus');
            const customDensity = document.getElementById('customDensity');
            const customPoissonRatio = document.getElementById('customPoissonRatio');
			const saveCustomMaterialBtn = document.getElementById('saveCustomMaterialBtn'); // Кнопка "Сохранить"
			
			// НОВЫЕ: Получаем ссылки на элементы для отображения свойств материала
            // Обратите внимание: для propName, propType, propStandard мы берем span внутри p
            const propName = document.getElementById('propName');
            const propType = document.getElementById('propType');
            const propStandard = document.getElementById('propStandard');
            const propElasticModulus = document.getElementById('propElasticModulus');
            const unitElasticModulus = document.getElementById('unitElasticModulus');
            const propDensity = document.getElementById('propDensity');
            const unitDensity = document.getElementById('unitDensity');
            const propPoissonRatio = document.getElementById('propPoissonRatio');
            const unitPoissonRatio = document.getElementById('unitPoissonRatio');
            if (toggleNodeNumbersBtn) {
                toggleNodeNumbersBtn.addEventListener("click", () => {
                    showNodeIds = !showNodeIds;
                    toggleNodeNumbersBtn.classList.toggle("active", showNodeIds);
                    draw();
                });
            }
            if (toggleLineNumbersBtn) {
                toggleLineNumbersBtn.addEventListener("click", () => {
                    showElementIds = !showElementIds;
                    toggleLineNumbersBtn.classList.toggle("active", showElementIds);
                    draw();
                });
            }
            
            // Вам потребуется кнопка для сохранения нового материала. 
            // Предположим, у вас есть <button id="saveCustomMaterialBtn">Сохранить</button> в HTML
            //const saveCustomMaterialBtn = document.getElementById('saveCustomMaterialBtn');

            // ... (ваши существующие addEventListener для канваса, кнопок режимов, и т.д.) ...
			
            // Устанавливаем слушатели для модального окна материалов
            if (openMaterialsModalBtn) {
                openMaterialsModalBtn.addEventListener('click', toggleMaterialsModal);
                console.log('Listener added to topBar openMaterialsModalBtn'); // DEBUG
            }
            if (openMaterialsModalBtnFromPanel) {
                openMaterialsModalBtnFromPanel.addEventListener('click', toggleMaterialsModal);
                console.log('Listener added to panel openMaterialsModalBtnFromPanel'); // DEBUG
            }
            if (materialsModal) { // Добавьте проверку на существование модального окна
                if (closeMaterialsModalBtn) {
                    closeMaterialsModalBtn.addEventListener('click', toggleMaterialsModal);
                }
                if (closeMaterialsModalBtnBottom) {
                    closeMaterialsModalBtnBottom.addEventListener('click', toggleMaterialsModal);
                }
                materialsModal.addEventListener('click', (e) => {
                    if (e.target === materialsModal) { // Закрытие по клику вне модального окна
                        toggleMaterialsModal();
                    }
                });
            }

            function toggleSectionsModal() {
                sectionsModal.classList.toggle('hidden');
            }

            if (openSectionsModalBtn) {
                openSectionsModalBtn.addEventListener('click', toggleSectionsModal);
            }
            if (closeSectionsModalBtn) {
                closeSectionsModalBtn.addEventListener('click', toggleSectionsModal);
            }
            if (sectionsModal) {
                sectionsModal.addEventListener('click', (e) => {
                    if (e.target === sectionsModal) {
                        toggleSectionsModal();
                    }
                });
            }
			
            // Получаем ссылки на селекторы материалов и добавляем слушатели
			//const materialTypeSelect = document.getElementById('materialTypeSelect');
			//const materialStandardSelect = document.getElementById('materialStandardSelect');

			if (materialTypeSelect) {
				materialTypeSelect.addEventListener('change', () => {
					populateMaterialClassSelect(); // Сначала обновляем список класса/марки
					displaySelectedMaterialProperties(); // <-- НОВОЕ: Затем обновляем свойства
				});
			}
			if (materialStandardSelect) {
				materialStandardSelect.addEventListener('change', () => {
					populateMaterialClassSelect(); // Сначала обновляем список класса/марки
					toggleCustomMaterialFields(materialStandardSelect.value === 'USER'); // Показать/скрыть поля пользовательского материала
					displaySelectedMaterialProperties(); // <-- НОВОЕ: Затем обновляем свойства
				});
			}
			
            if (materialClassSelect) {
                materialClassSelect.addEventListener('change', displaySelectedMaterialProperties); // <-- Это строка, которая должна вызывать функцию
            }

            if (sectionTypeSelect) {
                sectionTypeSelect.addEventListener('change', populateSectionNameSelect);
            }
            if (sectionStandardSelect) {
                sectionStandardSelect.addEventListener('change', populateSectionNameSelect);
            }
			
			
			// НОВОЕ: Слушатель для кнопки сохранения пользовательского материала
            if (saveCustomMaterialBtn) {
                saveCustomMaterialBtn.addEventListener('click', () => {
                    // Вызываем функцию для добавления пользовательского материала
                    addCustomMaterial(
                        customMaterialName.value,
                        materialTypeSelect.value, // Берем тип из общего селектора типа материала
                        parseFloat(customElasticModulus.value),
                        parseFloat(customDensity.value),
                        parseFloat(customPoissonRatio.value)
                    );
                    // Очищаем поля формы после сохранения
                    customMaterialName.value = '';
                    customElasticModulus.value = '';
                    customDensity.value = '';
                    customPoissonRatio.value = '';
                });
            }
			
			// НОВОЕ: Слушатель для кнопки "Добавить в модель"
            if (addMaterialToModelBtn) {
                addMaterialToModelBtn.addEventListener('click', addSelectedMaterialToModel);
            }
            
			// --- Инициализируем селекторы материалов и загружаем данные ---\
            await initializeMaterialSelectors();
            await initializeSectionSelectors();
            
            // --- 3. Запускаем основную инициализацию приложения ---\
            init(); 
            console.log('Initialization complete.'); 
        });	
		
		
		

        // Start the application
        //init();
    </script>
</body>
</html>
