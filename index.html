<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Графический интерфейс для расчетных моделей</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            display: flex; /* Используем flexbox для основной компоновки */
            height: 100vh; /* Занимаем всю высоту viewport */
        }

        .properties-panel {
            width: 25vw; /* Занимает 1/4 ширины viewport - ВСЕГДА */
            min-width: 250px; /* Минимальная ширина, чтобы контент не сжимался слишком сильно */
            height: 100vh; /* Занимает всю высоту */
            background-color: #f0f2f5;
            border-right: 1px solid #d1d5db;
            padding: 15px;
            box-sizing: border-box; /* Учитываем padding в ширине */
            overflow-y: auto; /* Прокрутка, если содержимое не помещается */
            flex-shrink: 0; /* Не позволяет панели сжиматься */
            display: block; /* Панель всегда блочная, не скрываем */
        }

        .properties-panel h3 {
            font-size: 1.2em;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
        }
        .property-group {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background-color: #fff;
        }
        .property-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }
        .property-group input[type="number"] {
            width: calc(100% - 16px); /* Учитываем padding */
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1em;
            margin-bottom: 10px;
        }
        .property-group input[type="number"]:focus {
            border-color: #007bff;
            outline: none;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }
        .property-group .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .property-group .checkbox-group input[type="checkbox"] {
            margin-right: 8px;
            transform: scale(1.2);
        }

        .restriction-icon-btn {
            background-color: #e2e8f0;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            padding: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 50px; /* Фиксированный размер для кнопок */
            height: 50px;
            transition: all 0.2s ease-in-out;
            margin: 4px; /* Небольшой отступ между кнопками */
        }
        .restriction-icon-btn:hover {
            background-color: #d1d9e2;
            border-color: #a0aec0;
        }
        .restriction-icon-btn.active {
            background-color: #a7d9f7; /* Цвет активной кнопки */
            border-color: #3490dc;
            box-shadow: 0 0 0 3px rgba(52, 144, 220, 0.4);
        }
        .restriction-icon-btn img {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Убедиться, что SVG вписывается */
        }
        .restriction-icon-btn .no-restriction-text {
            font-size: 2em; /* Размер символа "Ø" */
            font-weight: bold;
            color: #666;
        }
		
		.load-input-group {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 8px; /* Добавляем отступ между элементами группы */
        }
        .load-input-group input[type="number"] {
            flex-grow: 1; /* Позволяет полю ввода занимать всё доступное пространство */
            margin-bottom: 0; /* Убираем нижний отступ, так как он уже есть в flexbox gap */
        }
        .load-input-group button {
            padding: 6px 12px;
            background-color: #4CAF50; /* Зеленая кнопка */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .load-input-group button:hover {
            background-color: #45a049;
        }
        .load-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid #eee;
        }
        .load-item:last-child {
            border-bottom: none; /* Убираем границу у последнего элемента */
        }
        .load-item button {
            background-color: #f44336; /* Красная кнопка удаления */
            padding: 4px 8px;
            font-size: 0.8em;
        }
        .load-item button:hover {
            background-color: #da190b;
        }


        .main-content {
            flex-grow: 1; /* Занимает все оставшееся пространство */
            display: flex;
            flex-direction: column; /* Элементы внутри будут располагаться вертикально */
            height: 100vh;
        }

        .canvas-container {
            width: 100%; /* Занимает 100% ширины main-content (которая 75vw) */
            height: calc(100vh - 60px); /* Занимает всю высоту main-content за вычетом controls */
            position: relative;
            overflow: hidden;
            border-top: 1px solid #ccc;
            background-color: #f8f9fa;
        }
        canvas { display: block; background-color: #fff; cursor: crosshair; }
		.controls {
            width: 100%; /* Занимает 100% ширины main-content */
            padding: 10px 15px;
            background-color: #f0f2f5;
            border-bottom: 1px solid #d1d5db;
            display: flex;
            flex-wrap: wrap; /* НОВОЕ: Позволяет элементам переноситься на следующую строку */
            align-items: flex-start; /* НОВОЕ: Выравниваем элементы по верху (полезно для нескольких строк) */
            justify-content: flex-start; /* НОВОЕ: Выравниваем элементы по левому краю */
            gap: 12px; /* Сохраняем отступы между элементами */
            min-height: 60px; /* Увеличиваем минимальную высоту, чтобы вместить два ряда */
            /* НОВОЕ: Можно добавить внутренние отступы для лучшего распределения по рядам,
                       если gap недостаточно или если вы хотите, чтобы элементы
                       занимали всю доступную ширину более равномерно */
            padding-bottom: 15px; /* Добавляем небольшой отступ снизу для второго ряда */
        }
        .controls label, .controls input, .controls select, .controls button {
            font-size: 14px;
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid #b0b0b0;
            margin-right: 5px;
        }
        .controls input[type="number"] { width: 60px; text-align: center;}
        .controls input[type="checkbox"] { margin-right: 3px; transform: scale(1.1); }
        .controls button { background-color: #007bff; color:white; cursor: pointer; border-color: #007bff;}
        .controls button:hover { background-color: #0056b3; border-color: #0056b3; }
        .controls #clearCanvasBtn { background-color: #dc3545; border-color: #dc3545;}
        .controls #clearCanvasBtn:hover { background-color: #c82333; border-color: #bd2130;}
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
            pointer-events: none;
            white-space: pre;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .context-menu {
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.15);
            padding: 5px 0;
            z-index: 1001;
            min-width: 160px;
        }
        .context-menu-item {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
        }
        .context-menu-item:hover {
            background-color: #f0f0f0;
        }
    </style>
</head>
<body class="bg-gray-100">

    <div id="propertiesPanel" class="properties-panel">
        <h3>Свойства элементов</h3>
        <div id="nodePropertiesContent">
            <p>Выберите элемент для просмотра его свойств.</p>
        </div>
    </div>

    <div class="main-content">
	<div class="controls">
				<label for="divisions">Делений на ед.:</label>
				<input type="number" id="divisions" value="4" min="1" max="20">

				<input type="checkbox" id="snapToGrid" class="ml-3 mr-1">
				<label for="snapToGrid">Магнит к сетке</label>

				<label for="forceUnits" class="ml-3">Ед. силы:</label>
				<select id="forceUnits">
					<option value="N">N</option>
					<option value="kN">kN</option>
					<option value="kg">кг</option>
					<option value="t">т</option>
					<option value="lbf">lbf</option>
					<option value="kips">kips</option>
				</select>
				
				<label for="units" class="ml-3">Единицы:</label>
				<select id="units">
					<option value="m">м</option>
					<option value="cm">см</option>
					<option value="mm">мм</option>
					<option value="ft">фут</option>
					<option value="in">дюйм</option>
				</select>				
				
				<label for="unitPairs" class="ml-3">Пары ед.:</label>
				<select id="unitPairs">
					<option value="none">Польз.</option>
					<option value="metric_t_m">т, м</option>
					<option value="metric_standard">кН, м</option>
					<option value="metric_mm_N">Н, мм</option>
					<option value="imperial_ft_lbf">lbf, фут</option>
					<option value="imperial_in_lbf">lbf, дюйм</option>
					<option value="imperial_in_kips">kips, дюйм</option>
				</select>
				
				<button id="saveModelBtn" class="ml-auto bg-blue-500 hover:bg-blue-600">Сохранить</button> <!-- НОВОЕ -->
				<!-- НОВОЕ: Кнопка "Загрузить" и скрытое поле для выбора файла -->
				<button id="loadModelBtn" class="bg-gray-500 hover:bg-gray-600 text-white">Загрузить</button>
				<input type="file" id="fileInput" accept=".json" class="hidden"> <!-- Скрытое поле ввода файла -->
				<button id="clearCanvasBtn" class="ml-auto">Очистить все</button>
			</div>

        <div class="canvas-container" id="canvasContainer">
            <canvas id="drawingCanvas"></canvas>
        </div>
    </div>

    <div id="customContextMenu" class="context-menu hidden">
        <div id="deleteNodeItem" class="context-menu-item">Удалить узел</div>
        <div id="deleteLineItem" class="context-menu-item">Удалить линию</div>
    </div>

    <div id="tooltip" class="tooltip hidden"></div>

    <script>
        // DOM Elements
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const canvasContainer = document.getElementById('canvasContainer');
        const divisionsInput = document.getElementById('divisions');
        const snapToGridCheckbox = document.getElementById('snapToGrid');
        const clearCanvasBtn = document.getElementById('clearCanvasBtn');
        const unitsSelect = document.getElementById('units');
        const tooltip = document.getElementById('tooltip');
        const customContextMenu = document.getElementById('customContextMenu');
        const deleteNodeItem = document.getElementById('deleteNodeItem');
        const deleteLineItem = document.getElementById('deleteLineItem');
        
        // Новые DOM элементы для панели свойств
        const propertiesPanel = document.getElementById('propertiesPanel');
        const nodePropertiesContent = document.getElementById('nodePropertiesContent');
        const forceUnitsSelect = document.getElementById('forceUnits'); // Добавляем глобальное объявление
		const unitPairsSelect = document.getElementById('unitPairs'); // НОВОЕ: DOM элемент для наборов единиц

        // Application State
        let nodes = []; // { node_id, x, y (ALWAYS in currentUnit, positive Y is UP) }
        let lines = []; // { elem_id, nodeId1, nodeId2 }
        let restrictions = []; // [{ node_id: 1, dx: 1, dy: 0, dr: 1 }, ...] - dr вместо r для ясности
        let nextNodeId = 1;
        let nextElemId = 1; 
		// ИЗМЕНЕНО: Добавлено lengthUnit для моментов
		let nodeLoads = []; // [{ load_id, type, target_id, component, value, unit, (lengthUnit для моментов) }] 
        let nextLoadId = 1;
		let elementLoads = []; // НОВОЕ: [{ load_id, target_elem_id, type, component, value, unit, lengthUnit }]
        let nextElementLoadId = 1; // НОВОЕ: Счетчик для ID распределенных нагрузок
		

        let scale = 50; 
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let lastPanX, lastPanY;

        let divisionsPerUnit = parseInt(divisionsInput.value);
        let snapToGrid = true; 
        let currentUnit = unitsSelect.value; // 'm', 'cm', 'mm', 'ft', 'in'
        let currentForceUnit = forceUnitsSelect.value; // Текущая единица силы (например, 'kN', 'N')
        let currentTemperatureUnit = 'F'; // НОВОЕ: Текущая единица температуры (по умолчанию Фаренгейт)
        let currentTimeUnit = 'sec'; // НОВОЕ: Текущая единица времени (по умолчанию секунды)

        // Коэффициенты конвертации единиц длины (базовая единица: миллиметры 'mm')
        // Значение = сколько миллиметров в ОДНОЙ единице
        const lengthUnitConversions = { 
            'mm': 1,    // 1 мм = 1 мм
            'cm': 10,   // 1 см = 10 мм
            'm': 1000,  // 1 м = 1000 мм
            'in': 25.4, // 1 дюйм = 25.4 мм
            'ft': 304.8 // 1 фут = 304.8 мм
        };

        // Коэффициенты конвертации единиц силы: сколько Ньютонов в ОДНОЙ единице (т.е., 1 'N' = 1 'N', 1 'kN' = 1000 'N' и т.д.)
        const forceUnitConversions = {
            'N':    1,
            'kN':   1000,
            'kg':   9.80665, // 1 кгс (килограмм-сила) = 9.80665 Ньютонов
            't':    9806.65, // 1 тс (тонна-сила) = 9806.65 Ньютонов
            'lbf':  4.44822,
            'kips': 4448.22
        };
		
		// НОВОЕ: Определения наборов единиц
        const unitPairConversions = {
            'metric_standard': { length: 'm', force: 'kN' },
            'metric_mm_N': { length: 'mm', force: 'N' },
            'imperial_ft_lbf': { length: 'ft', force: 'lbf' },
            'imperial_in_lbf': { length: 'in', force: 'lbf' },
			'imperial_in_kips': { length: 'in', force: 'kips' },
			'metric_t_m': { length: 'm', force: 't' } // НОВОЕ
        };
		
		
        let currentUnitPair = unitPairsSelect.value; // Инициализируем текущий набор единиц		
		
		// НОВОЕ: Вспомогательная функция для обновления поля "Пары ед."
        function updateUnitPairsSelect() {
            const currentLengthUnit = unitsSelect.value;
            const currentForceUnit = forceUnitsSelect.value;
            
            let foundMatch = false;
            for (const pairKey in unitPairConversions) {
                const pair = unitPairConversions[pairKey];
                if (pair.length === currentLengthUnit && pair.force === currentForceUnit) {
                    unitPairsSelect.value = pairKey;
                    foundMatch = true;
                    break;
                }
            }

            if (!foundMatch) {
                unitPairsSelect.value = 'none'; // Если не найдено соответствие, устанавливаем "Пользовательский"
            }
        }
        
        let firstNodeForLine = null; // Узел, с которого начинается построение линии
        let hoveredElement = null; // Элемент под курсором
        let contextMenuTarget = null; // Элемент, по которому вызвано контекстное меню
        let selectedNode = null; // Узел, выделенный для отображения свойств
		let selectedElement = null;

        let mouse = { x: 0, y: 0, worldX: 0, worldY: 0, snappedX: 0, snappedY: 0 }; 

        // Иконки закреплений и их свойства (dx, dy, dr)
        const restrictionTypes = {
            "none":      { dx: 0, dy: 0, dr: 0, icon: null, label: "Нет" },
            "pinned":    { dx: 1, dy: 1, dr: 0, icon: "icon_Pinned.svg", label: "Шарнирная (Pin)" },
            "rolled-x":  { dx: 0, dy: 1, dr: 0, icon: "icon_Rolled-X.svg", label: "Подвижная по X" },
            "rolled-y":  { dx: 1, dy: 0, dr: 0, icon: "icon_Rolled-Y.svg", label: "Подвижная по Y" },
            "fixed":     { dx: 1, dy: 1, dr: 1, icon: "icon_Fixed.svg", label: "Защемление (Fixed)" },
            "sleeve-x":  { dx: 0, dy: 1, dr: 1, icon: "icon_Sleeve-X.svg", label: "Обойма по X" },
            "sleeve-y":  { dx: 1, dy: 0, dr: 1, icon: "icon_Sleeve-Y.svg", label: "Обойма по Y" }
        };

        // Функция для сохранения модели в JSON
        function saveModel() {
            // Собираем все текущие данные модели
            const modelData = {
                nodes: nodes,
                lines: lines,
                restrictions: restrictions,
                nodeLoads: nodeLoads,
                elementLoads: elementLoads,
                // Добавляем текущие единицы измерения в модель
                units: {
                    length: currentUnit,        // Текущая единица длины (из global currentUnit)
                    force: currentForceUnit,    // Текущая единица силы (из global currentForceUnit)
                    temperature: currentTemperatureUnit, // Единица температуры (из global currentTemperatureUnit)
                    time: currentTimeUnit       // Единица времени (из global currentTimeUnit)
                }
            };
			
			console.log("Модель данных перед сохранением:", modelData); // НОВОЕ: Это покажет всю модель
            console.log("Единицы измерения в модели:", modelData.units); // НОВОЕ: Это покажет только блок units

            // Преобразуем объект в строку JSON с форматированием для читаемости
            const jsonString = JSON.stringify(modelData, null, 2); // null, 2 для красивого форматирования с отступами

            // Создаем Blob (двоичный объект данных) из JSON строки
            const blob = new Blob([jsonString], { type: 'application/json' });

            // Создаем временную ссылку для скачивания файла
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'model.json'; // Имя файла по умолчанию

            // Имитируем клик по ссылке для скачивания файла
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url); // Освобождаем ресурсы

            console.log("Модель сохранена в model.json");
        }

		async function loadModel(jsonFileContent) {
            try {
                const modelData = JSON.parse(jsonFileContent);

                // --- Загружаем данные модели ---
                // Важно: Эти данные будут в тех единицах, в которых они были сохранены в файле.
                // Конвертация произойдет ниже, при "установке" UI-селекторов.
                nodes = modelData.nodes || [];
                lines = modelData.lines || [];
                restrictions = modelData.restrictions || [];
                nodeLoads = modelData.nodeLoads || [];
                elementLoads = modelData.elementLoads || [];

                // --- Загрузка и применение единиц измерения из файла ---
                if (modelData.units) {
                    const loadedLengthUnit = modelData.units.length;
                    const loadedForceUnit = modelData.units.force;
                    const loadedTemperatureUnit = modelData.units.temperature || 'C'; // Дефолт 'C' на случай старых файлов
                    const loadedTimeUnit = modelData.units.time || 's'; // Дефолт 's' на случай старых файлов

                    // Обновляем глобальные переменные состояния для температуры и времени
                    currentTemperatureUnit = loadedTemperatureUnit;
                    currentTimeUnit = loadedTimeUnit;

                    // Обновляем селекторы единиц длины и силы в UI.
                    // Принудительно вызываем событие 'change', чтобы сработала вся логика конвертации
                    // уже загруженных данных (nodes, loads) из старых UI-единиц в новые загруженные единицы,
                    // а также обновились все тексты в UI (панель свойств, канвас).

                    // Сначала для длины
                    // Проверяем, изменится ли значение селектора unitsSelect
                    if (unitsSelect.value !== loadedLengthUnit) {
                        unitsSelect.value = loadedLengthUnit;
                        unitsSelect.dispatchEvent(new Event('change')); // Запускаем конвертацию данных
                    } else {
                        // Если значение в селекторе уже совпадает, событие 'change' не сработает.
                        // Нам нужно убедиться, что currentUnit обновлен и UI синхронизирован.
                        currentUnit = loadedLengthUnit; // Убеждаемся, что переменная состояния актуальна
                        updateUnitPairsSelect(); // Обновим пары единиц, если нужно
                        updateForceUnitDisplay(); // Обновим отображение единиц силы/момента
                    }

                    // Затем для силы
                    // Проверяем, изменится ли значение селектора forceUnitsSelect
                    if (forceUnitsSelect.value !== loadedForceUnit) {
                        forceUnitsSelect.value = loadedForceUnit;
                        forceUnitsSelect.dataset.previousValue = loadedForceUnit; // Обновляем data-атрибут
                        forceUnitsSelect.dispatchEvent(new Event('change')); // Запускаем конвертацию данных
                    } else {
                        // Если значение в селекторе уже совпадает.
                        currentForceUnit = loadedForceUnit; // Убеждаемся, что переменная состояния актуальна
                        updateUnitPairsSelect(); // Обновим пары единиц, если нужно
                        updateForceUnitDisplay(); // Обновим отображение единиц силы/момента
                    }

                } else {
                    // Если в старом JSON нет информации о единицах, устанавливаем дефолтные для температуры и времени
                    currentTemperatureUnit = 'C'; // Или 'F', как вы захотите для старых файлов
                    currentTimeUnit = 's';
                    // Единицы длины и силы остаются как в текущем UI, конвертаций не происходит.
                    // updatePropertiesPanel() и draw() будут вызваны позже, чтобы отобразить данные в текущих UI-единицах.
                }

                // Обновляем счетчики ID, чтобы избежать дублирования при добавлении новых элементов
                nextNodeId = nodes.length > 0 ? Math.max(...nodes.map(n => n.node_id)) + 1 : 1;
                nextElemId = lines.length > 0 ? Math.max(...lines.map(l => l.elem_id)) + 1 : 1;
                nextLoadId = nodeLoads.length > 0 ? Math.max(...nodeLoads.map(l => l.load_id)) + 1 : 1;
                nextElementLoadId = elementLoads.length > 0 ? Math.max(...elementLoads.map(l => l.load_id)) + 1 : 1;

                // Сбрасываем выделение, так как загруженная модель может не иметь выделенных элементов
                selectedNode = null;
                selectedElement = null;
                firstNodeForLine = null;

                // ВАЖНО: updatePropertiesPanel() и draw() уже вызываются внутри dispatchEvent('change') для
                // unitsSelect и forceUnitsSelect. Если эти события НЕ СРАБОТАЛИ (т.е. загруженные единицы
                // совпали с текущими UI), то нам все равно нужно обновить UI.
                // Поэтому явно вызываем их здесь, только если загруженные единицы совпали.
                if ((modelData.units && unitsSelect.value === modelData.units.length && forceUnitsSelect.value === modelData.units.force) || !modelData.units) {
                    updatePropertiesPanel();
                    draw();
                }

                console.log("Модель успешно загружена.");
            } catch (error) {
                console.error("Ошибка при загрузке модели:", error);
                console.error("Не удалось загрузить модель. Проверьте формат файла.");
            }
        }


        // Initialization	
		
        function init() {
            snapToGridCheckbox.checked = snapToGrid; 
            resizeCanvas();
            addEventListeners();
            
            // Устанавливаем значение по умолчанию для выпадающего списка Ед. силы на 'kN' (килоньютоны)
            forceUnitsSelect.value = 'kN'; 
            forceUnitsSelect.dataset.previousValue = 'kN'; // Инициализируем предыдущее значение единицы силы
            
            // НОВОЕ: Инициализируем currentUnit и currentForceUnit из DOM-элементов
            currentUnit = unitsSelect.value;
            currentForceUnit = forceUnitsSelect.value;
            
            // НОВОЕ: Вызываем updateUnitPairsSelect для начальной установки поля "Пары ед."
            // Эта функция просто сопоставит текущие unitsSelect и forceUnitsSelect с парами,
            // не вызывая лишних событий change.
            updateUnitPairsSelect(); 

            // Вызываем updateForceUnitDisplay для синхронизации текстовых спанов и запуска обновления панели/отрисовки
            // Эта функция также вызывает updatePropertiesPanel() и draw()
            updateForceUnitDisplay(); 
        }

        function resizeCanvas() {
            // Размеры canvas должны соответствовать его родительскому контейнеру
            canvas.width = canvasContainer.clientWidth;
            canvas.height = canvasContainer.clientHeight;
            // Центрируем panX/panY относительно нового размера canvas
            panX = canvas.width / 2;
            panY = canvas.height / 2; 
            draw();
        }

        // Coordinate Transformations (world coords are in currentUnit, positive Y is UP)
        function screenToWorld(screenX, screenY) {
            return {
                x: (screenX - panX) / scale,
                y: -(screenY - panY) / scale 
            };
        }

        function worldToScreen(worldX, worldY) { 
            return {
                x: worldX * scale + panX,
                y: worldY * (-scale) + panY 
            };
        }
        
        // Snapping Logic (snaps to sub-grid of currentUnit)
        function getSnappedCoordinates(worldX_currentUnit, worldY_currentUnit) { 
            if (!snapToGrid) return { x: worldX_currentUnit, y: worldY_currentUnit };
            const gridSize_currentUnit = 1 / divisionsPerUnit;
            return {
                x: Math.round(worldX_currentUnit / gridSize_currentUnit) * gridSize_currentUnit,
                y: Math.round(worldY_currentUnit / gridSize_currentUnit) * gridSize_currentUnit
            };
        }
        
        // Unit Conversion Helper (для длины)
        function convertUnits(value, fromUnit, toUnit) {
            if (fromUnit === toUnit) return value;
            if (!lengthUnitConversions[fromUnit] || !lengthUnitConversions[toUnit]) {
                console.warn(`Неизвестные единицы длины: ${fromUnit} или ${toUnit}`);
                return value;
            }
            // Сначала конвертируем в метры (базовая единица для длины)
            const valueInMeters = value * lengthUnitConversions[fromUnit];
            // Затем конвертируем из метров в целевую единицу
            return valueInMeters / lengthUnitConversions[toUnit];
        }

        // Новая универсальная функция конвертации силы
        // Конвертирует 'value' из 'fromUnit' в 'toUnit'
        function convertForce(value, fromUnit, toUnit) {
            // Если единицы совпадают, или одна из них не определена, возвращаем исходное значение
            if (fromUnit === toUnit || !forceUnitConversions[fromUnit] || !forceUnitConversions[toUnit]) {
                return value;
            }
            // Шаг 1: Сначала конвертируем исходное значение из 'fromUnit' в Ньютоны (базовую единицу для коэффициентов)
            const valueInNewtons = value * forceUnitConversions[fromUnit];
            // Шаг 2: Затем конвертируем из Ньютонов в целевую единицу 'toUnit'
            return valueInNewtons / forceUnitConversions[toUnit];
        }

        // НОВАЯ ФУНКЦИЯ: Универсальная функция конвертации моментов
        // Конвертирует 'value' из 'fromForceUnit'*'fromLengthUnit' в 'toForceUnit'*'toLengthUnit'
        function convertMoment(value, fromForceUnit, fromLengthUnit, toForceUnit, toLengthUnit) {
            // Если единицы силы или длины не определены, или совпадают, возвращаем исходное значение
            if (!forceUnitConversions[fromForceUnit] || !forceUnitConversions[toForceUnit] ||
                !lengthUnitConversions[fromLengthUnit] || !lengthUnitConversions[toLengthUnit]) {
                console.warn("Неизвестные единицы для конвертации момента.");
                return value;
            }

            // Шаг 1: Конвертируем исходный момент в Ньютон-метры (базовые единицы для момента)
            // Идея: (value в fromForceUnit*fromLengthUnit) * (Ньютоны в fromForceUnit) * (Метры в fromLengthUnit)
            const momentInNewtonMeters = value * forceUnitConversions[fromForceUnit] * lengthUnitConversions[fromLengthUnit];

            // Шаг 2: Конвертируем из Ньютон-метров в целевые единицы
            // Делим на (Ньютоны в toForceUnit) и (Метры в toLengthUnit)
            const convertedValue = momentInNewtonMeters / (forceUnitConversions[toForceUnit] * lengthUnitConversions[toLengthUnit]);
            
            return convertedValue;
        }
		
		// НОВАЯ ФУНКЦИЯ: Универсальная функция конвертации распределенных нагрузок (F/L)
        // Конвертирует 'value' из 'fromForceUnit'/'fromLengthUnit' в 'toForceUnit'/'toLengthUnit'
        function convertDistributedForce(value, fromForceUnit, fromLengthUnit, toForceUnit, toLengthUnit) {
            console.log(`convertDistributedForce: value=${value}, from=${fromForceUnit}/${fromLengthUnit}, to=${toForceUnit}/${toLengthUnit}`);
			// Проверка на существование всех единиц
            if (!forceUnitConversions[fromForceUnit] || !forceUnitConversions[toForceUnit] ||
                !lengthUnitConversions[fromLengthUnit] || !lengthUnitConversions[toLengthUnit]) {
                console.warn(`Неизвестные единицы для конвертации распределенной нагрузки: ${fromForceUnit}/${fromLengthUnit} -> ${toForceUnit}/${toLengthUnit}`);
                return value; // Возвращаем исходное значение, если единицы не найдены
            }

            // Шаг 1: Конвертируем исходное значение в Ньютон/миллиметр (базовые единицы для распределенной нагрузки)
            // (value в fromForceUnit/fromLengthUnit) * (Ньютоны в fromForceUnit) / (Миллиметры в fromLengthUnit)
            const valueInNewtonsPerMillimeter = (value * forceUnitConversions[fromForceUnit]) / lengthUnitConversions[fromLengthUnit];

            // Шаг 2: Конвертируем из Ньютон/миллиметр в целевые единицы
            // Делим на (Ньютоны в toForceUnit) и умножаем на (Миллиметры в toLengthUnit)
            const convertedValue = valueInNewtonsPerMillimeter / (forceUnitConversions[toForceUnit] / lengthUnitConversions[toLengthUnit]);
            
            return convertedValue;
        }


        // Обновляет текстовые спаны с единицами измерения на панели свойств
        // и вызывает перерисовку для актуализации значений нагрузок.
        function updateForceUnitDisplay() {
            // currentForceUnit теперь не существует как глобальная переменная,
            // мы берем текущую единицу прямо из значения выпадающего списка.
            const selectedUnit = forceUnitsSelect.value; 
            // ИЗМЕНЕНО: momentUnit теперь будет использовать текущую единицу длины
            const selectedMomentUnit = selectedUnit + '*' + unitsSelect.value; // Используем unitsSelect.value для текущей единицы длины

            const displayFx = document.getElementById('currentForceUnitDisplay_Fx');
            const displayFy = document.getElementById('currentForceUnitDisplay_Fy');
            const displayM = document.getElementById('currentForceUnitDisplay_M');

            if (displayFx) displayFx.textContent = selectedUnit;
            if (displayFy) displayFy.textContent = selectedUnit;
            if (displayM) displayM.textContent = selectedMomentUnit;
            
            // После обновления единиц в UI, нужно перерисовать панель свойств и Canvas,
            // чтобы уже добавленные нагрузки обновили свои значения.
            updatePropertiesPanel(); 
            draw();
        }

		// Drawing Functions
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(panX, panY);
            ctx.scale(scale, -scale); // Важно: Y-ось инвертирована здесь!

            drawGrid();
            drawAxes();
            drawLines();
            drawRestrictions(); // Рисуем закрепления
            drawNodes();        // Рисуем узлы

            // НОВОЕ: Рисуем узловые нагрузки (использует уже трансформированный контекст)
            drawNodeLoads();
			drawDistributedLoads(); // НОВОЕ: Вызываем отрисовку распределенных нагрузок			
            
            ctx.restore(); // Восстанавливаем исходную матрицу трансформации
            drawCursorCircle();
            updateTooltip();
        }
		
		// ====================================================================
		
		// --- Вспомогательные функции для рисования символов нагрузок ---

		// Функция для рисования стрелки (для сил)
		// fromX, fromY: начальная точка хвоста стрелки (в модельных координатах)
		// toX, toY: конечная точка (наконечник стрелки, в модельных координатах)
		// color: цвет стрелки
		function drawArrow(fromX, fromY, toX, toY, color, arrowheadLength = 10) {
			ctx.strokeStyle = color;
			ctx.fillStyle = color; // Для заполнения наконечника
			ctx.lineWidth = 1 / scale; // Масштабируем толщину линии

			// Нарисуем линию стрелки
			ctx.beginPath();
			ctx.moveTo(fromX, fromY);
			ctx.lineTo(toX, toY);
			ctx.stroke();

			// Нарисуем наконечник стрелки (замкнутый и острый)
			const angle = Math.atan2(toY - fromY, toX - fromX); // Угол линии
			const headLen = arrowheadLength / scale; // Масштабированная длина наконечника
			const headAngle = Math.PI / 10; // Угол для остроты (меньше, чем PI/8, для еще более острой стрелки)

			ctx.beginPath();
			ctx.moveTo(toX, toY);
			ctx.lineTo(toX - headLen * Math.cos(angle - headAngle), toY - headLen * Math.sin(angle - headAngle));
			ctx.lineTo(toX - headLen * Math.cos(angle + headAngle), toY - headLen * Math.sin(angle + headAngle));
			ctx.closePath(); // Замыкаем путь для заполнения
			ctx.fill(); // Заполняем наконечник цветом
			// ctx.stroke(); // Можно убрать, если не нужны контуры наконечника
		}

		// Функция для рисования дуговой стрелки (для моментов)
		// centerX, centerY: центр дуги (координаты узла, в модельных координатах)
		// radius: радиус дуги (в модельных единицах)
		// startAngle, endAngle: начальный и конечный угол дуги (в радианах)
		// counterClockwise: true для против часовой стрелки, false для по часовой стрелке
		function drawArcArrow(centerX, centerY, radius, startAngle, endAngle, counterClockwise, color, arrowheadLength = 10) {
			ctx.strokeStyle = color;
			ctx.fillStyle = color; // Для заполнения наконечника
			ctx.lineWidth = 1 / scale; // Масштабируем толщину линии

			// Нарисуем саму дугу
			ctx.beginPath();
			ctx.arc(centerX, centerY, radius, startAngle, endAngle, counterClockwise);
			ctx.stroke();

			// Нарисуем наконечник стрелки на конце дуги (замкнутый и острый)
			const arrowAngle = endAngle; // Наконечник всегда в конце дуги
			const headLen = arrowheadLength / scale; // Масштабированная длина наконечника
			const headAngle = Math.PI / 10; // Угол для остроты

			// Корректируем угол для правильного направления наконечника
			let headTangentAngle = arrowAngle;
			if (counterClockwise) {
				headTangentAngle -= Math.PI / 2; // Для CCW момента, наконечник смотрит "назад" по дуге (по касательной)
			} else {
				headTangentAngle += Math.PI / 2; // Для CW момента, наконечник смотрит "вперед" по дуге (по касательной)
			}

			const arrowPointX = centerX + radius * Math.cos(arrowAngle);
			const arrowPointY = centerY + radius * Math.sin(arrowAngle);

			ctx.beginPath();
			ctx.moveTo(arrowPointX, arrowPointY);
			ctx.lineTo(arrowPointX - headLen * Math.cos(headTangentAngle - headAngle), arrowPointY - headLen * Math.sin(headTangentAngle - headAngle));
			ctx.lineTo(arrowPointX - headLen * Math.cos(headTangentAngle + headAngle), arrowPointY - headLen * Math.sin(headTangentAngle + headAngle));
			ctx.closePath(); // Замыкаем путь для заполнения
			ctx.fill(); // Заполняем наконечник
			// ctx.stroke(); // Можно убрать
		}

		function drawGrid() {
            // Определяем базовую единицу для сетки
            let gridBaseUnit = 'm';
            if (currentUnit === 'ft' || currentUnit === 'in') {
                gridBaseUnit = 'ft';
            }

            // Вычисляем шаг сетки в текущих модельных единицах
            // Сначала шаг в базовых единицах (1 метр или 1 фут), затем конвертируем в currentUnit
            const baseGridStep = 1; // 1 метр или 1 фут
            const gridStep_currentUnit = convertUnits(baseGridStep, gridBaseUnit, currentUnit);

            const subGridStep_currentUnit = gridStep_currentUnit / divisionsPerUnit;

            const worldView = {
                minX: screenToWorld(0, 0).x,
                maxX: screenToWorld(canvas.width, 0).x,
                minY: screenToWorld(0, canvas.height).y, 
                maxY: screenToWorld(0, 0).y             
            };
            
            ctx.beginPath();
            ctx.strokeStyle = '#e0e0e0'; 
            ctx.lineWidth = 1 / scale; 

            const startX_currentUnit = Math.floor(worldView.minX / subGridStep_currentUnit) * subGridStep_currentUnit;
            const endX_currentUnit = Math.ceil(worldView.maxX / subGridStep_currentUnit) * subGridStep_currentUnit;
            for (let x = startX_currentUnit; x <= endX_currentUnit; x += subGridStep_currentUnit) {
                ctx.moveTo(x, Math.min(worldView.minY, worldView.maxY));
                ctx.lineTo(x, Math.max(worldView.minY, worldView.maxY));
            }

            const startY_currentUnit = Math.floor(Math.min(worldView.minY, worldView.maxY) / subGridStep_currentUnit) * subGridStep_currentUnit;
            const endY_currentUnit = Math.ceil(Math.max(worldView.minY, worldView.maxY) / subGridStep_currentUnit) * subGridStep_currentUnit;
            for (let y = startY_currentUnit; y <= endY_currentUnit; y += subGridStep_currentUnit) {
                ctx.moveTo(worldView.minX, y);
                ctx.lineTo(worldView.maxX, y);
            }
            ctx.stroke();
        }

		function drawAxes() {
            ctx.strokeStyle = '#888';
            ctx.lineWidth = 2 / scale;
            ctx.fillStyle = '#555';
            const fontSizeWorld = 12 / scale; 
            ctx.font = `${fontSizeWorld}px Arial`;

            const visMinX = screenToWorld(0,0).x; 
            const visMaxX = screenToWorld(canvas.width,0).x; 
            const visMinY_world = screenToWorld(0,canvas.height).y; 
            const visMaxY_world = screenToWorld(0,0).y;         

            ctx.beginPath(); 
            ctx.moveTo(visMinX, 0); 
            ctx.lineTo(visMaxX, 0);
            ctx.stroke();

            ctx.beginPath(); 
            ctx.moveTo(0, visMinY_world); 
            ctx.lineTo(0, visMaxY_world);
            ctx.stroke();

            // Определяем базовую единицу для подписей осей
            let axisLabelBaseUnit = 'm';
            if (currentUnit === 'ft' || currentUnit === 'in') {
                axisLabelBaseUnit = 'ft';
            }

            const unitLabelIncrement = 1; // Метки будут через 1 базовую единицу
            const xLabelYOffsetWorld = fontSizeWorld * 0.5; 

            // X-axis labels
            const xLabelMinNum = Math.floor(convertUnits(visMinX, currentUnit, axisLabelBaseUnit) / unitLabelIncrement);
            const xLabelMaxNum = Math.ceil(convertUnits(visMaxX, currentUnit, axisLabelBaseUnit) / unitLabelIncrement);
            for (let num = xLabelMinNum; num <= xLabelMaxNum; num += unitLabelIncrement) {
                // Преобразуем метку обратно в текущие модельные единицы для отрисовки
                const worldX_currentUnit = convertUnits(num * unitLabelIncrement, axisLabelBaseUnit, currentUnit);
                const labelText = num.toFixed(0);
                
                ctx.save();
                ctx.translate(worldX_currentUnit, xLabelYOffsetWorld); 
                ctx.scale(1, -1); 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom'; 
                ctx.fillText(labelText, 0, 0);
                ctx.restore();
            }
            
            // Y-axis labels
            const yLabelXOffsetWorld = -fontSizeWorld * 0.5; 
            const yLabelMinNum = Math.floor(convertUnits(Math.min(visMinY_world, visMaxY_world), currentUnit, axisLabelBaseUnit) / unitLabelIncrement);
            const yLabelMaxNum = Math.ceil(convertUnits(Math.max(visMinY_world, visMaxY_world), currentUnit, axisLabelBaseUnit) / unitLabelIncrement);
            for (let num = yLabelMinNum; num <= yLabelMaxNum; num += unitLabelIncrement) {
                if (Math.abs(num) < 1e-9 / scale && Math.abs(0 - xLabelYOffsetWorld) < 1e-9 / scale ) continue; 
                if (num === 0) continue; 
                // Преобразуем метку обратно в текущие модельные единицы для отрисовки
                const worldY_currentUnit = convertUnits(num * unitLabelIncrement, axisLabelBaseUnit, currentUnit);
                const labelText = num.toFixed(0);

                ctx.save();
                ctx.translate(yLabelXOffsetWorld, worldY_currentUnit); 
                ctx.scale(1, -1); 
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                ctx.fillText(labelText, 0, 0);
                ctx.restore();
            }
        }

        function drawNodes() { 
            const nodeRadiusWorld = 4 / scale;
            const nodeIdFontSizeWorld = 12 / scale;
            const nodeIdOffsetYWorld = nodeRadiusWorld + nodeIdFontSizeWorld * 0.3; 

            nodes.forEach(node => { 
                ctx.beginPath();
                ctx.arc(node.x, node.y, nodeRadiusWorld, 0, 2 * Math.PI);
                
                // Измененная логика цвета узла
                if (selectedNode && selectedNode.node_id === node.node_id) {
                    ctx.fillStyle = '#FF6D2D'; //Ярко оранжевый //Был Бирюзовый для выделенного узла 17a2b8
                } else if (hoveredElement && hoveredElement.type === 'node' && hoveredElement.element.node_id === node.node_id) {
                    ctx.fillStyle = '#dc3545'; // Красный для наведения
                } else {
                    ctx.fillStyle = '#007bff'; // Синий по умолчанию #007bff
                }

                ctx.fill();
                ctx.strokeStyle = '#343a40';
                ctx.lineWidth = 1.5 / scale;
                ctx.stroke();

                // Draw node ID
                ctx.save();
                ctx.translate(node.x, node.y);
                ctx.scale(1, -1); 
                ctx.translate(nodeIdOffsetYWorld+5/scale, nodeIdOffsetYWorld-5/scale); 
                
                ctx.fillStyle = ctx.fillStyle; 
                ctx.font = `${nodeIdFontSizeWorld}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom'; 
                ctx.fillText(node.node_id, 0, 0); 
                ctx.restore();
            });
        }

        // ===============================================
        // Функция для рисования ВСЕХ иконок закреплений на Canvas
        // ===============================================
        function drawRestrictions() {
            restrictions.forEach(restriction => {
                const node = nodes.find(n => n.node_id === restriction.node_id);
                if (node) {
                    // Определяем, какую иконку рисовать на основе dx, dy, dr
                    let iconToDraw = null;
                    for (const typeKey in restrictionTypes) {
                        const type = restrictionTypes[typeKey];
                        if (type.icon && type.dx === restriction.dx && type.dy === restriction.dy && type.dr === restriction.dr) {
                            iconToDraw = typeKey;
                            break;
                        }
                    }

                    if (iconToDraw) {
                        drawRestrictionIcon(ctx, node.x, node.y, scale, iconToDraw);
                    }
                }
            });
        }
		
		// --- Обновленная функция для отрисовки узловых нагрузок ---
		function drawNodeLoads() {
			const LOAD_COLOR = 'black'; 

			// Константы, определяющие ЖЕЛАЕМЫЙ РАЗМЕР СИМВОЛА В ПИКСЕЛЯХ НА ЭКРАНЕ
			const FIXED_ARROW_LENGTH_PX = 70; // Желаемая длина стрелки силы в пикселях
			const FIXED_MOMENT_RADIUS_PX = 35; // Желаемый радиус дуги момента в пикселях
			const FIXED_TEXT_OFFSET_PX = 10; // Желаемый отступ текста от символа в пикселях

			nodeLoads.forEach(load => {
				const node = nodes.find(n => n.node_id === load.target_id);
				if (!node) return;

                const currentForceDisplayUnit = forceUnitsSelect.value; // Текущая выбранная единица силы
                const currentLengthDisplayUnit = unitsSelect.value; // Текущая выбранная единица длины

                let displayedValue;
                let displayedUnitString;

                if (load.type === 'point_force') {
                    // Конвертируем значение силы из его сохраненной единицы (load.unit)
                    // В текущую выбранную единицу отображения силы (currentForceDisplayUnit)
                    displayedValue = convertForce(load.value, load.unit, currentForceDisplayUnit).toFixed(2);
                    displayedUnitString = currentForceDisplayUnit;
                } else if (load.type === 'moment') {
                    // Конвертируем значение момента из его сохраненных единиц (load.unit, load.lengthUnit)
                    // В текущие выбранные единицы отображения (currentForceDisplayUnit, currentLengthDisplayUnit)
                    displayedValue = convertMoment(load.value, load.unit, load.lengthUnit, currentForceDisplayUnit, currentLengthDisplayUnit).toFixed(2);
                    displayedUnitString = `${currentForceDisplayUnit}*${currentLengthDisplayUnit}`; // ИЗМЕНЕНО
                }

				const drawX = node.x;
				const drawY = node.y;

				// Вычисление текущих размеров в МОДЕЛЬНЫХ ЕДИНИЦАХ (делим на scale)
				// Это обеспечивает, что символы будут иметь постоянный визуальный размер на экране
				const currentArrowLength = FIXED_ARROW_LENGTH_PX / scale;
				const currentMomentRadius = FIXED_MOMENT_RADIUS_PX / scale;
				const currentTextOffset = FIXED_TEXT_OFFSET_PX / scale;

				ctx.font = `${12 / scale}px Arial`; 
				ctx.fillStyle = LOAD_COLOR;
				ctx.textBaseline = 'middle'; 

				if (load.type === 'point_force') {
					let fromX, fromY, toX, toY;
					let textX, textY;

					toX = drawX; // Наконечник стрелки входит в узел
					toY = drawY;

					if (load.component === 'x') {
						fromX = drawX - (load.value > 0 ? currentArrowLength : -currentArrowLength);
						fromY = drawY;
						
						textX = fromX + (load.value > 0 ? -currentTextOffset : currentTextOffset) * 0; // Смещение текста от стрелки
						textY = fromY + currentTextOffset * 0.5; 
						ctx.textAlign = load.value > 0 ? 'left': 'right'; // Выравнивание текста относительно стрелки
						ctx.textBaseline = 'bottom'; // Центрируем текст по вертикали
					} else if (load.component === 'y') {
						fromX = drawX;
						fromY = drawY - (load.value > 0 ? currentArrowLength : -currentArrowLength);
						
						textX = fromX + currentTextOffset;
						textY = fromY + (load.value > 0 ? -currentTextOffset : currentTextOffset) * 0; // Смещение текста от стрелки
						ctx.textBaseline = load.value > 0 ? 'bottom' : 'top'; // Выравнивание текста относительно стрелки
						ctx.textAlign = 'left'; // Центрируем текст по горизонтали
					}

					drawArrow(fromX, fromY, toX, toY, LOAD_COLOR);
					
					ctx.save();
					ctx.scale(1, -1); // Инвертируем Y-ось только для текста
					ctx.fillText(`${displayedValue} ${displayedUnitString}`, textX, -textY); 
					ctx.restore();

				} else if (load.type === 'moment') {
					let startAngle, endAngle, counterClockwise;
					const arcLength = Math.PI * (90 / 180);

					if (load.value > 0) {
						startAngle = Math.PI / 4;
						endAngle = startAngle - arcLength;
						counterClockwise = false;
					} else {
						startAngle = Math.PI / 1.33333;
						endAngle = startAngle + arcLength;
						counterClockwise = true;
					}

					drawArcArrow(drawX, drawY, currentMomentRadius, startAngle, endAngle, counterClockwise, LOAD_COLOR); 

					const textArcAngle = endAngle; 
					const textPosX = drawX + (currentMomentRadius + currentTextOffset) * Math.cos(textArcAngle);
					const textPosY = drawY + (currentMomentRadius + currentTextOffset) * Math.sin(textArcAngle);
					
					ctx.save();
					ctx.scale(1, -1); // Инвертируем Y-ось только для текста
					ctx.textAlign = load.value > 0 ? 'left' : 'right';
					ctx.fillText(`${displayedValue} ${displayedUnitString}`, textPosX, -textPosY); 
					ctx.restore();
				}
			});
		}
		
		// НОВАЯ ФУНКЦИЯ: Отрисовка распределенных нагрузок
        function drawDistributedLoads() {
            const LOAD_COLOR = 'green'; // Цвет для распределенных нагрузок
            const DIST_LOAD_ARROW_LENGTH_PX = 15; // Желаемая длина индивидуальных стрелок в пикселях
            const DIST_LOAD_OFFSET_PX = 0; // Желаемый отступ от линии элемента в пикселях
            const DIST_LOAD_RECT_WIDTH_PX = 15; // Желаемая ширина прямоугольника нагрузки в пикселях
            const DIST_LOAD_TEXT_OFFSET_PX = 15; // Желаемый отступ текста от символа в пикселях
            const ARROW_HEAD_LENGTH_PX = 8; // Желаемая длина наконечника стрелки в пикселях

            elementLoads.forEach(load => {
                const line = lines.find(l => l.elem_id === load.target_elem_id);
                if (!line) return;

                const node1 = nodes.find(n => n.node_id === line.nodeId1);
                const node2 = nodes.find(n => n.node_id === line.nodeId2);
                if (!node1 || !node2) return;

                // Получаем текущие единицы для отображения
                const currentForceDisplayUnit = forceUnitsSelect.value;
                const currentLengthDisplayUnit = unitsSelect.value;
                const currentDistributedForceUnit = `${currentForceDisplayUnit}/${currentLengthDisplayUnit}`;

                // Конвертируем значение нагрузки для отображения
                const storedForceUnit = load.unit.split('/')[0]; // Например, 'kN' из 'kN/m'
                const storedLengthUnit = load.unit.split('/')[1]; // Например, 'm' из 'kN/m'


				const displayedValue = parseFloat(convertDistributedForce(load.startValue, storedForceUnit, storedLengthUnit, currentForceDisplayUnit, currentLengthDisplayUnit).toFixed(2)); // ИЗМЕНЕНО: Используем convertDistributedForce
                const displayedUnitString = currentDistributedForceUnit;

                const dx_line = node2.x - node1.x;
                const dy_line = node2.y - node1.y;
                const lineLength = Math.sqrt(dx_line * dx_line + dy_line * dy_line);

                if (lineLength === 0) return; // Избегаем деления на ноль для нулевых линий

                // Вычисляем угол линии
                const lineAngle = Math.atan2(dy_line, dx_line);

                // Конвертируем пиксельные константы в мировые координаты (делим на scale)
                const arrowLengthWorld = DIST_LOAD_ARROW_LENGTH_PX / scale;
                const offsetWorld = DIST_LOAD_OFFSET_PX / scale;
                const rectWidthWorld = DIST_LOAD_RECT_WIDTH_PX / scale;
                const textOffsetWorld = DIST_LOAD_TEXT_OFFSET_PX / scale;
                const arrowHeadLengthWorld = ARROW_HEAD_LENGTH_PX / scale;

                ctx.save();
                ctx.strokeStyle = LOAD_COLOR;
                ctx.fillStyle = LOAD_COLOR;
                ctx.lineWidth = 1 / scale; // Масштабируем толщину линии
                ctx.font = `${12 / scale}px Arial`; // Масштабируем размер шрифта
                ctx.textBaseline = 'middle';

                // Определяем перпендикулярный вектор для смещения нагрузки от элемента
                let perpDx, perpDy;
                if (load.component === 'x') { // Нагрузка параллельна оси X
                    perpDx = 0;
                    // Стрелки указывают вверх для положительной нагрузки, вниз для отрицательной
                    perpDy = (load.startValue > 0) ? 1 : -1; 
                } else { // Нагрузка параллельна оси Y
                    // Стрелки указывают вправо для положительной нагрузки, влево для отрицательной
                    perpDx = (load.startValue > 0) ? -1 : 1; 
                    perpDy = 0;
                }

                // Нормализуем перпендикулярный вектор и масштабируем его по смещению
                const perpVectorLength = Math.sqrt(perpDx * perpDx + perpDy * perpDy);
                if (perpVectorLength > 0) {
                    perpDx = (perpDx / perpVectorLength) * offsetWorld;
                    perpDy = (perpDy / perpVectorLength) * offsetWorld;
                }

                // Отрисовка прямоугольника, представляющего распределенную нагрузку
                ctx.beginPath();
                const rectStartX = node1.x + perpDx;
                const rectStartY = node1.y + perpDy;
                const rectEndX = node2.x + perpDx;
                const rectEndY = node2.y + perpDy;

                // Угол, перпендикулярный линии элемента

                const normalAngle = lineAngle + ((node1.y > node2.y || node2.x > node1.x) ? Math.PI * 1.5 : Math.PI / 2); 
                // Направление "ширины" прямоугольника (в зависимости от знака нагрузки)
                const rectOffset = (load.startValue > 0) ? rectWidthWorld : -rectWidthWorld; 

                // Координаты углов прямоугольника
                const p1x = rectStartX;
                const p1y = rectStartY;
                const p2x = rectEndX;
                const p2y = rectEndY;
                const p3x = rectEndX + rectOffset * Math.cos(normalAngle);
                const p3y = rectEndY + rectOffset * Math.sin(normalAngle);
                const p4x = rectStartX + rectOffset * Math.cos(normalAngle);
                const p4y = rectStartY + rectOffset * Math.sin(normalAngle);

                ctx.moveTo(p1x, p1y);
                ctx.lineTo(p2x, p2y);
                ctx.lineTo(p3x, p3y);
                ctx.lineTo(p4x, p4y);
                ctx.closePath();
                ctx.globalAlpha = 0.2; // Делаем полупрозрачным
                ctx.fill();
                ctx.globalAlpha = 1.0; // Сбрасываем прозрачность
                ctx.stroke();

                // Отрисовка индивидуальных стрелок вдоль прямоугольника нагрузки
                // Минимум 2 стрелки, или больше, в зависимости от длины элемента
                const numArrows = Math.max(2, Math.floor(lineLength / (arrowLengthWorld * 2))); 
                for (let i = 0; i <= numArrows; i++) {
                    const t = i / numArrows; // Параметр от 0 до 1 вдоль линии
                    const currentPointX = node1.x + dx_line * t;
                    const currentPointY = node1.y + dy_line * t;

                    let arrowFromX, arrowFromY, arrowToX, arrowToY;

                    if (load.component === 'x') {
                        /*arrowFromX = currentPointX + perpDx;
                        arrowFromY = currentPointY + perpDy;
                        arrowToX = arrowFromX + (load.startValue > 0 ? arrowLengthWorld : -arrowLengthWorld);
                        arrowToY = arrowFromY;*/
                        arrowToX = currentPointX + perpDx;
                        arrowToY = currentPointY + perpDy;
                        arrowFromX = arrowToX - (load.startValue > 0 ? arrowLengthWorld : -arrowLengthWorld);
                        arrowFromY = arrowToY;						
                    } else { // 'y' компонент
                        /*arrowFromX = currentPointX + perpDx;
                        arrowFromY = currentPointY + perpDy;
                        arrowToX = arrowFromX;
                        arrowToY = arrowFromY - (load.startValue > 0 ? arrowLengthWorld : -arrowLengthWorld);*/
						arrowToX = currentPointX + perpDx;
                        arrowToY = currentPointY + perpDy;
                        arrowFromX = arrowToX;
                        arrowFromY = arrowToY - (load.startValue > 0 ? arrowLengthWorld : -arrowLengthWorld);
                    }
                    
                    // Передаем длину наконечника в пикселях, чтобы drawArrow масштабировала ее сама
                    drawArrow(arrowFromX, arrowFromY, arrowToX, arrowToY, LOAD_COLOR, arrowHeadLengthWorld * scale); 
                }

                // Отрисовка текстовой метки нагрузки
                const midPointX = node1.x + dx_line / 2;
                const midPointY = node1.y + dy_line / 2;

                let textX, textY;
                if (load.component === 'x') {
                    textX = midPointX - perpDx - (load.startValue > 0 ? arrowLengthWorld + textOffsetWorld : -(arrowLengthWorld + textOffsetWorld));
                    textY = midPointY + perpDy;
                    ctx.textAlign = load.startValue > 0 ? 'right' : 'left';
                    ctx.textBaseline = 'middle';
                } else { // 'y' компонент
                    textX = midPointX + perpDx;
                    textY = midPointY - perpDy - (load.startValue > 0 ? arrowLengthWorld + textOffsetWorld : -(arrowLengthWorld + textOffsetWorld));
                    ctx.textAlign = 'center';
                    ctx.textBaseline = load.startValue > 0 ? 'bottom' : 'top';
                }
                
                ctx.save();
                ctx.scale(1, -1); // Инвертируем Y для правильного отображения текста
                ctx.fillText(`${displayedValue} ${displayedUnitString}`, textX, -textY);
                ctx.restore();

                ctx.restore(); // Восстанавливаем контекст для следующей нагрузки
            });
        }

        // ===============================================
        // Функции для рисования КОНКРЕТНОЙ иконки закрепления на Canvas
        // Эти функции берут SVG-данные и рисуют их с помощью методов Canvas
        // ===============================================
        const restrictionIconSizeWorld = 15; // Базовый размер иконки в мировых координатах (без учета масштаба)
        const restrictionIconOffsetWorld = 2; // Отступ иконки от центра узла

        function drawRestrictionIcon(ctx, nodeX, nodeY, currentScale, iconType) {
            ctx.save();
            ctx.translate(nodeX, nodeY);
            ctx.scale(1, 1); // Инвертируем Y для правильного рисования иконок

            // Все иконки будут рисоваться относительно центра узла
            // и смещаться вниз (отрицательный Y)
            const iconRenderSize = restrictionIconSizeWorld / currentScale;
            const iconRenderOffset = restrictionIconOffsetWorld / currentScale;

            ctx.strokeStyle = '#343a40'; // Цвет обводки
            ctx.lineWidth = 1.1 / currentScale; // Толщина линии
            ctx.fillStyle = '#6c757d'; // Цвет заливки

            // Выбираем, какую иконку рисовать
            switch (iconType) {
                case "pinned":
                    // Треугольник
                    ctx.beginPath();
                    ctx.moveTo(0, -iconRenderOffset);
                    ctx.lineTo(-iconRenderSize / 1.5, -(iconRenderOffset + iconRenderSize));
                    ctx.lineTo(iconRenderSize / 1.5, -(iconRenderOffset + iconRenderSize));
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Линии "земли"
                    ctx.beginPath();
                    ctx.moveTo(-iconRenderSize * 0.8, -(iconRenderOffset + iconRenderSize + 0 / currentScale));
                    ctx.lineTo(iconRenderSize * 0.8, -(iconRenderOffset + iconRenderSize + 0 / currentScale));
					ctx.lineWidth = 1.5 / currentScale;
                    ctx.stroke();
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(iconRenderSize * (0.2 - i * 0.5), (iconRenderOffset - iconRenderSize - 12/ currentScale));
                        ctx.lineTo(iconRenderSize * (0.6 - i * 0.5), (iconRenderOffset - iconRenderSize - 5/ currentScale));
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 1 / currentScale;
                        ctx.stroke();
                    }
                    break;
                case "rolled-x":
                    // Треугольник
                    ctx.beginPath();
                    ctx.moveTo(0, -iconRenderOffset*0.5);
                    ctx.lineTo(-iconRenderSize / 1.8, -(iconRenderOffset + iconRenderSize-4/ currentScale));
                    ctx.lineTo(iconRenderSize / 1.8, -(iconRenderOffset + iconRenderSize-4/ currentScale));
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    /*// Круги под треугольником (ролики)
                    const rollerRadius = iconRenderSize * 0.15;
                    const rollerOffsetY = iconRenderOffset + iconRenderSize + rollerRadius + 1 / currentScale;
                    ctx.beginPath();
                    ctx.arc(-iconRenderSize * 0.25, -rollerOffsetY, rollerRadius, 0, Math.PI * 2);
                    ctx.arc(iconRenderSize * 0.25, -rollerOffsetY, rollerRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();*/

                    // Линии "земли"
                    ctx.beginPath();
                    ctx.moveTo(-iconRenderSize * 0.8, -(iconRenderOffset + iconRenderSize + 0 / currentScale));
                    ctx.lineTo(iconRenderSize * 0.8, -(iconRenderOffset + iconRenderSize + 0 / currentScale));
					ctx.lineWidth = 1.5 / currentScale;
                    ctx.stroke();
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(iconRenderSize * (0.2 - i * 0.5), (iconRenderOffset - iconRenderSize - 12/ currentScale));
                        ctx.lineTo(iconRenderSize * (0.6 - i * 0.5), (iconRenderOffset - iconRenderSize - 5/ currentScale));
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 1 / currentScale;
                        ctx.stroke();
                    }
                    break;
                case "rolled-y":
                    // Ролики по Y - повернутая версия rolled-x
                    ctx.rotate(Math.PI / 1); // Поворачиваем на 90 градусов
                    // Смещаем, чтобы центр был в правильном месте после поворота.
                    // После поворота (0,0) остается центром, но оси x и y поменялись.
                    // Иконка, которая обычно рисуется "вниз", теперь рисуется "вправо".
                    // Нужно сместить ее на X. Оффсет и размер теперь по X.
                    ctx.translate(iconRenderOffset, -iconRenderSize * 0); 

                    // Треугольник (теперь он на "боку")
                    ctx.beginPath();
                    ctx.moveTo(0, 0); // Вершина треугольника
                    ctx.lineTo(-(iconRenderSize)*0.9, -iconRenderSize / 1.6); // Левая нижняя
                    ctx.lineTo(-(iconRenderSize)*0.9, iconRenderSize / 1.6); // Правая нижняя
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Круги под треугольником (ролики)
                    const rollerRadius_y = iconRenderSize * 0.15;
                    const rollerOffsetX_y = iconRenderSize + rollerRadius_y + 1 / currentScale; // Смещение по X
                    /*ctx.beginPath();
                    ctx.arc(-rollerOffsetX_y, -iconRenderSize * 0.25, rollerRadius_y, 0, Math.PI * 2);
                    ctx.arc(-rollerOffsetX_y, iconRenderSize * 0.25, rollerRadius_y, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();*/

                    // Линия "земли"
                    ctx.beginPath();
                    ctx.moveTo(-(rollerOffsetX_y + rollerRadius_y - 2 / currentScale), -iconRenderSize * 0.8);
                    ctx.lineTo(-(rollerOffsetX_y + rollerRadius_y - 2 / currentScale), iconRenderSize * 0.8);			
                    ctx.stroke();
                     for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo((iconRenderOffset - iconRenderSize - 12/ currentScale), iconRenderSize * (0.6 - i * 0.5));
                        ctx.lineTo((iconRenderOffset - iconRenderSize - 5/ currentScale), iconRenderSize * (0.2 - i * 0.5));						
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 1 / currentScale;
                        ctx.stroke();
                    }
                    break;
                case "fixed":
                    const fixedHeight = iconRenderSize * 1.5;

                    // Линии "земли"
                    ctx.beginPath();
                    ctx.moveTo(-iconRenderSize * 0.8, 0);
                    ctx.lineTo(iconRenderSize * 0.8, 0);
					ctx.lineWidth = 1.5 / currentScale;
                    ctx.stroke();
					
                    ctx.moveTo(0, -20/ currentScale);
                    ctx.lineTo(0, 0/ currentScale);
					//ctx.lineWidth = 3 / currentScale;
                    ctx.stroke();
					
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(iconRenderSize * (0.2 - i * 0.5), -8/ currentScale);
                        ctx.lineTo(iconRenderSize * (0.6 - i * 0.5), 0/ currentScale);
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 1 / currentScale;
                        ctx.stroke();
                    }
                    break;
                case "sleeve-x":

                    const sleeveWidth = iconRenderSize * 0.8;
                    const sleeveHeight = iconRenderSize * 1.2;
                    // Линии "земли"
					// Горизонт нижняя
                    ctx.beginPath();
                    ctx.moveTo(-iconRenderSize * 0.8, (iconRenderOffset - iconRenderSize + 5 / currentScale));
                    ctx.lineTo(iconRenderSize * 0.8, (iconRenderOffset - iconRenderSize + 5 / currentScale));
					ctx.lineWidth = 1.5 / currentScale;
                    ctx.stroke();
					// Горизонт верхняя
                    ctx.beginPath();
                    ctx.moveTo(-iconRenderSize * 0.8, -(iconRenderOffset - iconRenderSize + 5 / currentScale));
                    ctx.lineTo(iconRenderSize * 0.8, -(iconRenderOffset - iconRenderSize + 5 / currentScale));
					ctx.lineWidth = 1.5 / currentScale;
                    ctx.stroke();
					// Штриховка нижняя
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(iconRenderSize * (0.2 - i * 0.5), (iconRenderOffset - iconRenderSize - 2/ currentScale));
                        ctx.lineTo(iconRenderSize * (0.6 - i * 0.5), (iconRenderOffset - iconRenderSize + 5/ currentScale));
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 1 / currentScale;
                        ctx.stroke();
                    }
					// Штриховка верхняя
					for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(iconRenderSize * (0.6 - i * 0.5), -(iconRenderOffset - iconRenderSize - 2/ currentScale));
                        ctx.lineTo(iconRenderSize * (0.2 - i * 0.5), -(iconRenderOffset - iconRenderSize + 5/ currentScale));
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 1 / currentScale;
                        ctx.stroke();
                    }
                    break;
                case "sleeve-y":
                    // Обойма по Y - повернутая версия sleeve-x
                    ctx.rotate(Math.PI / 2); // Поворачиваем на 90 градусов
                    // Смещаем, чтобы центр был в правильном месте.
                    // Аналогично rolled-y, смещение будет по X
                    //ctx.translate(iconRenderOffset, -iconRenderSize * 0.5); 

                    const sleeveWidth_y = iconRenderSize * 0.8;
                    const sleeveHeight_y = iconRenderSize * 1.2;
                    // Линии "земли"
					// Горизонт нижняя
                    ctx.beginPath();
                    ctx.moveTo(-iconRenderSize * 0.8, (iconRenderOffset - iconRenderSize + 5 / currentScale));
                    ctx.lineTo(iconRenderSize * 0.8, (iconRenderOffset - iconRenderSize + 5 / currentScale));
					ctx.lineWidth = 1.5 / currentScale;
                    ctx.stroke();
					// Горизонт верхняя
                    ctx.beginPath();
                    ctx.moveTo(-iconRenderSize * 0.8, -(iconRenderOffset - iconRenderSize + 5 / currentScale));
                    ctx.lineTo(iconRenderSize * 0.8, -(iconRenderOffset - iconRenderSize + 5 / currentScale));
					ctx.lineWidth = 1.5 / currentScale;
                    ctx.stroke();
					
					// Штриховка нижняя
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(iconRenderSize * (0.2 - i * 0.5), (iconRenderOffset - iconRenderSize - 2/ currentScale));
                        ctx.lineTo(iconRenderSize * (0.6 - i * 0.5), (iconRenderOffset - iconRenderSize + 5/ currentScale));
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 1 / currentScale;
                        ctx.stroke();
                    }
					
					// Штриховка верхняя
					for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(iconRenderSize * (0.6 - i * 0.5), -(iconRenderOffset - iconRenderSize - 2/ currentScale));
                        ctx.lineTo(iconRenderSize * (0.2 - i * 0.5), -(iconRenderOffset - iconRenderSize + 5/ currentScale));
                        ctx.strokeStyle = 'black';
                        ctx.lineWidth = 1 / currentScale;
                        ctx.stroke();
                    }
                    break;
            }

            ctx.restore();
        }

        function drawLines() { 
            const lineIdFontSizeWorld = 12 / scale;
            const lineIdOffsetWorld = 7 / scale;

            lines.forEach(line => {
                const node1 = nodes.find(n => n.node_id === line.nodeId1); 
                const node2 = nodes.find(n => n.node_id === line.nodeId2); 
                if (node1 && node2) { 
                    ctx.beginPath();
                    ctx.moveTo(node1.x, node1.y);
                    ctx.lineTo(node2.x, node2.y);

					// НОВОЕ: Если линия выделена, используем оранжевый цвет; если только наведена, используем красный; иначе - стандартный.
                    if (selectedElement && selectedElement.elem_id === line.elem_id) {
                        ctx.strokeStyle = '#FF6D2D'; // Ярко-оранжевый, как для выделенного узла
                    } else if (hoveredElement && hoveredElement.type === 'line' && hoveredElement.element.elem_id === line.elem_id) {
                        ctx.strokeStyle = '#dc3545'; // Красный для наведения
                    } else {
                        ctx.strokeStyle = '#343a40'; // Серый по умолчанию
                    }

 
                    ctx.lineWidth = 1.5 / scale;
                    ctx.stroke();

                    const midX = (node1.x + node2.x) / 2;
                    const midY = (node1.y + node2.y) / 2;

                    ctx.save();
                    ctx.translate(midX, midY); 
                    ctx.scale(1, -1); 

                    const angle = -Math.atan2(node2.y - node1.y, node2.x - node1.x); 
                    
                    if (angle > Math.PI / 2 || angle < -Math.PI / 2) {
                        ctx.rotate(angle + Math.PI); 
                    } else {
                        ctx.rotate(angle);
                    }

                    ctx.fillStyle = ctx.strokeStyle; 
                    ctx.font = `${lineIdFontSizeWorld}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle'; 

                    ctx.fillText(line.elem_id, 0, -lineIdOffsetWorld); 
                    
                    ctx.restore();
                }
            });
        }

        function drawCursorCircle() { 
            let drawAtX_screen, drawAtY_screen;
            if (snapToGrid) {
                const screenSnappedPos = worldToScreen(mouse.snappedX, mouse.snappedY);
                drawAtX_screen = screenSnappedPos.x;
                drawAtY_screen = screenSnappedPos.y;
            } else {
                drawAtX_screen = mouse.x; 
                drawAtY_screen = mouse.y;
            }
            ctx.beginPath();
            ctx.arc(drawAtX_screen, drawAtY_screen, 5, 0, 2 * Math.PI);
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.9)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
        }
        
        // Event Handlers
        function addEventListeners() {
            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleWheelZoom, { passive: false });
            canvas.addEventListener('contextmenu', handleContextMenu);
            document.addEventListener('click', handleClickOutsideContextMenu);

            divisionsInput.addEventListener('change', () => {
                divisionsPerUnit = parseInt(divisionsInput.value) || 1;
                if (divisionsPerUnit < 1) divisionsPerUnit = 1;
                if (divisionsPerUnit > 20) divisionsPerUnit = 20;
                divisionsInput.value = divisionsPerUnit;
                draw();
            });
            snapToGridCheckbox.addEventListener('change', () => {
                snapToGrid = snapToGridCheckbox.checked;
                const worldCoords = screenToWorld(mouse.x, mouse.y); 
                const snapped = getSnappedCoordinates(worldCoords.x, worldCoords.y); 
                mouse.snappedX = snapped.x;
                mouse.snappedY = snapped.y; 
                draw();
            });
            clearCanvasBtn.addEventListener('click', clearAll);
			
			// НОВОЕ: Обработчик для кнопки сохранения модели
            const saveModelBtn = document.getElementById('saveModelBtn');
            saveModelBtn.addEventListener('click', saveModel);
			
			            // НОВОЕ: DOM элементы для загрузки модели
            const loadModelBtn = document.getElementById('loadModelBtn');
            const fileInput = document.getElementById('fileInput');

            // Обработчик для кнопки "Загрузить"
            loadModelBtn.addEventListener('click', () => {
                fileInput.click(); // Программно кликаем по скрытому полю ввода файла
            });

            // Обработчик для изменения (выбора) файла в поле ввода
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0]; // Получаем выбранный файл
                if (!file) {
                    console.log("Файл не выбран.");
                    return;
                }

                const reader = new FileReader();

                // Что делать, когда файл будет успешно прочитан
                reader.onload = async (event) => {
                    const fileContent = event.target.result; // Содержимое файла (строка JSON)
                    await loadModel(fileContent); // Передаем содержимое в нашу функцию loadModel
                    // Сбросить значение input, чтобы можно было загрузить тот же файл снова
                    fileInput.value = ''; 
                };

                // Что делать, если произошла ошибка при чтении файла
                reader.onerror = (error) => {
                    console.error("Ошибка чтения файла:", error);
                    // Заменяем alert на console.error для Canvas/Immersive Document
                    console.error("Не удалось прочитать файл.");
                };

                // Читаем файл как текстовую строку
                reader.readAsText(file);
            });
            
            unitsSelect.addEventListener('change', (e) => {
                const oldUnit = currentUnit; // Старая единица длины
                const newUnit = e.target.value; // Новая единица длины
                if (oldUnit === newUnit) return;

				// Конвертируем координаты узлов и округляем до 5 знаков после запятой
                nodes.forEach(node => { 
                    node.x = convertUnits(node.x, oldUnit, newUnit); // НОВОЕ: Сохраняем полную точность
                    node.y = convertUnits(node.y, oldUnit, newUnit); // НОВОЕ: Сохраняем полную точность
                });

                // НОВОЕ: Конвертируем ЗНАЧЕНИЯ МОМЕНТОВ при смене единиц длины
				nodeLoads.forEach(load => {
                    if (load.type === 'moment') {
                        load.value = convertMoment(load.value, load.unit, oldUnit, load.unit, newUnit); // НОВОЕ: Сохраняем полную точность
                        load.lengthUnit = newUnit; 
                    }
                });
				
                elementLoads.forEach(load => {
                    const storedForceUnit = load.unit.split('/')[0];
                    const storedLengthUnit = load.unit.split('/')[1];

                    load.startValue = convertDistributedForce(load.startValue, storedForceUnit, storedLengthUnit, storedForceUnit, newUnit); // НОВОЕ: Сохраняем полную точность
                    load.endValue = convertDistributedForce(load.endValue, storedForceUnit, storedLengthUnit, storedForceUnit, newUnit);   // НОВОЕ: Сохраняем полную точность
                    
                    load.unit = `${storedForceUnit}/${newUnit}`;
                });

                // Масштабируем
                // ИЗМЕНЕНО: Универсальное масштабирование
                scale = scale * (lengthUnitConversions[newUnit] / lengthUnitConversions[oldUnit]);
                currentUnit = newUnit; // Обновляем текущую единицу длины
				
				// НОВОЕ: Автоматическая отмена "магнита к сетке" для мелких единиц
                if (newUnit === 'mm' || newUnit === 'cm' || newUnit === 'in') {
                    snapToGrid = false;
                    snapToGridCheckbox.checked = false; // Обновляем состояние чекбокса в UI
                } else {
                    // НОВОЕ: Если переключились на 'м' или 'фут', автоматически включаем "магнит к сетке"
                    snapToGrid = true;
                    snapToGridCheckbox.checked = true; // Обновляем состояние чекбокса в UI
                }
                
                const worldCoordsNow = screenToWorld(mouse.x, mouse.y); 
                const snappedNow = getSnappedCoordinates(worldCoordsNow.x, worldCoordsNow.y);
                mouse.worldX = worldCoordsNow.x;
                mouse.worldY = worldCoordsNow.y; 
                mouse.snappedX = snappedNow.x;
                mouse.snappedY = snappedNow.y; 

                updatePropertiesPanel();
                draw();
				
				updateForceUnitDisplay(); // Эта функция вызывает updatePropertiesPanel() и draw()
                updateUnitPairsSelect(); // НОВОЕ: Обновляем выпадающий список пар единиц
            });

			// НОВОЕ: Слушатель событий для изменения единиц силы
            forceUnitsSelect.addEventListener('change', (e) => {
                const newForceUnit = e.target.value;
                const oldForceUnit = forceUnitsSelect.dataset.previousValue; // Получаем предыдущую единицу силы

                // Обновляем предыдущее значение для следующего изменения
                forceUnitsSelect.dataset.previousValue = newForceUnit;

				nodeLoads.forEach(load => {
                    if (load.type === 'point_force') {
                        load.value = convertForce(load.value, load.unit, newForceUnit); // НОВОЕ: Сохраняем полную точность
                        load.unit = newForceUnit; 
                    } else if (load.type === 'moment') {
                        load.value = convertMoment(load.value, load.unit, load.lengthUnit, newForceUnit, load.lengthUnit); // НОВОЕ: Сохраняем полную точность
                        load.unit = newForceUnit; 
                    }
                });
				
                elementLoads.forEach(load => {
                    const storedForceUnit = load.unit.split('/')[0];
                    const storedLengthUnit = load.unit.split('/')[1];

                    load.startValue = convertDistributedForce(load.startValue, storedForceUnit, storedLengthUnit, newForceUnit, storedLengthUnit); // НОВОЕ: Сохраняем полную точность
                    load.endValue = convertDistributedForce(load.endValue, storedForceUnit, storedLengthUnit, newForceUnit, storedLengthUnit);   // НОВОЕ: Сохраняем полную точность
                    
                    load.unit = `${newForceUnit}/${storedLengthUnit}`;
                });

                // Обновляем UI и перерисовываем
                updateForceUnitDisplay(); 
				
				updateForceUnitDisplay(); // Эта функция вызывает updatePropertiesPanel() и draw()
                updateUnitPairsSelect(); // НОВОЕ: Обновляем выпадающий список пар единиц
            });

			// НОВОЕ: Слушатель событий для изменения наборов единиц
            unitPairsSelect.addEventListener('change', (e) => {
                const selectedPairKey = e.target.value;
                currentUnitPair = selectedPairKey; // Обновляем текущий набор

                if (selectedPairKey !== 'none') {
                    const targetUnits = unitPairConversions[selectedPairKey];
                    
                    // Устанавливаем единицы длины
                    unitsSelect.value = targetUnits.length;
                    // Принудительно вызываем событие change для unitsSelect
                    unitsSelect.dispatchEvent(new Event('change')); 

                    // Устанавливаем единицы силы
                    forceUnitsSelect.value = targetUnits.force;
                    // Обновляем previousValue для forceUnitsSelect перед вызовом события
                    forceUnitsSelect.dataset.previousValue = targetUnits.force; 
                    // Принудительно вызываем событие change для forceUnitsSelect
                    forceUnitsSelect.dispatchEvent(new Event('change')); 
                }
                // Если выбран "Пользовательский", ничего не делаем,
                // предполагается, что пользователь будет вручную настраивать другие списки.
            });

            deleteNodeItem.addEventListener('click', handleDeleteNode);
            deleteLineItem.addEventListener('click', handleDeleteLine);
        }

		function handleMouseDown(e) {
            e.preventDefault();
            hideContextMenu(); // Скрываем контекстное меню при любом клике
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top; // Это корректно, rect.top

            const worldCoords = screenToWorld(mouse.x, mouse.y); 
            mouse.worldX = worldCoords.x;
            mouse.worldY = worldCoords.y; 
            const snapped = getSnappedCoordinates(mouse.worldX, mouse.worldY); 
            mouse.snappedX = snapped.x;
            mouse.snappedY = snapped.y; 

            // Находим элемент, на который произошел клик
            const clickedNode = findNodeAt(mouse.worldX, mouse.worldY); 
            const clickedLine = findLineAt(mouse.worldX, mouse.worldY); 

            if (e.button === 0) { // Левый клик

                // --- СЦЕНАРИЙ: Активен режим построения стержней (firstNodeForLine не null) ---
                if (firstNodeForLine) {
                    if (clickedNode && firstNodeForLine.node_id !== clickedNode.node_id) {
                        // Кликнули на ДРУГОЙ узел: строим новый стержень
                        const exists = lines.some(line =>
                            (line.nodeId1 === firstNodeForLine.node_id && line.nodeId2 === clickedNode.node_id) || 
                            (line.nodeId1 === clickedNode.node_id && line.nodeId2 === firstNodeForLine.node_id)    
                        );

                        if (!exists) {
                            lines.push({ elem_id: nextElemId++, nodeId1: firstNodeForLine.node_id, nodeId2: clickedNode.node_id, structural_type: 'beam' }); 
                            console.log(`Линия ${lines[lines.length - 1].elem_id} построена между узлами ${firstNodeForLine.node_id} и ${clickedNode.node_id}.`);
                        } else {
                            console.log(`Линия между узлами ${firstNodeForLine.node_id} и ${clickedNode.node_id} уже существует.`); 
                        }
                        firstNodeForLine = clickedNode; // Этот узел становится началом для следующего стержня
                        selectedNode = clickedNode;     // Выделяем этот узел, чтобы показать продолжение построения
                        selectedElement = null; 
                    } else {
                        // Кликнули на ТОТ ЖЕ узел, на ЛИНИЮ, или в ПУСТОЕ МЕСТО: завершаем режим построения стержней
                        firstNodeForLine = null;
                        selectedNode = null; // Снимаем любое выделение узла
                        selectedElement = null; // Снимаем любое выделение линии
                    }
                } 
                // --- СЦЕНАРИЙ: Режим построения стержней НЕ активен (firstNodeForLine null) ---
                else { 
                    if (clickedNode) {
                        // Кликнули на УЗЕЛ: СРАЗУ инициируем режим построения стержней с него
                        firstNodeForLine = clickedNode; 
                        selectedNode = clickedNode;     // Выделяем этот узел
                        selectedElement = null;         // Снимаем выделение линии, если была
                    } else if (clickedLine) {
                        // Кликнули на ЛИНИЮ: выделяем ее для редактирования
                        selectedElement = clickedLine;
                        selectedNode = null; // Снимаем выделение узла, если было
                        firstNodeForLine = null; // Убеждаемся, что режим построения стержней не активен
                    } else {
                        // Кликнули в ПУСТОЕ МЕСТО:
                        // Снимаем все выделения и отменяем режим построения стержней, если что-то было активно.
                        if (selectedNode || selectedElement || firstNodeForLine) { 
                            selectedNode = null;
                            selectedElement = null;
                            firstNodeForLine = null; 
                        } else {
                            // Если ничего не было активно, создаем новый узел
                            const placeX = snapToGrid ? mouse.snappedX : mouse.worldX; 
                            const placeY = snapToGrid ? mouse.snappedY : mouse.worldY;
                            const newNode = { node_id: nextNodeId++, x: placeX, y: placeY }; 
                            nodes.push(newNode); 
                            console.log(`Узел ${newNode.node_id} создан по координатам (${newNode.x.toFixed(3)}, ${newNode.y.toFixed(3)}).`);
                            selectedNode = null; 
                            selectedElement = null;
                            firstNodeForLine = null; 
                        }
                    }
                }
            } else if (e.button === 1) { // Средний клик для панорамирования
                isPanning = true;
                lastPanX = e.clientX;
                lastPanY = e.clientY;
                canvas.style.cursor = 'grabbing';
            }
            // Обновляем панель свойств и перерисовываем канвас в конце обработчика
            updatePropertiesPanel(); 
            draw();
        }





        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            // mouse.x теперь нужно корректировать с учетом левой границы canvas относительно viewport
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
            
            const worldCoords = screenToWorld(mouse.x, mouse.y); 
            mouse.worldX = worldCoords.x;
            mouse.worldY = worldCoords.y; 
            const snapped = getSnappedCoordinates(worldCoords.x, worldCoords.y);
            mouse.snappedX = snapped.x;
            mouse.snappedY = snapped.y; 

            if (isPanning) {
                const dx = e.clientX - lastPanX;
                const dy = e.clientY - lastPanY;
                panX += dx;
                panY += dy; 
                lastPanX = e.clientX;
                lastPanY = e.clientY;
            } else {
                hoveredElement = findElementAt(mouse.worldX, mouse.worldY); 
            }
            draw();
        }

        function handleMouseUp(e) {
            if (e.button === 1 && isPanning) { 
                isPanning = false;
                canvas.style.cursor = 'crosshair';
            }
        }

        function handleWheelZoom(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            // mouseX_screen корректируется относительно левого края canvas
            const mouseX_screen = e.clientX - rect.left;
            const mouseY_screen = e.clientY - rect.top;

            const worldBeforeZoom = screenToWorld(mouseX_screen, mouseY_screen); 

            const zoomFactor = 1.1;
            let newScale = scale;
            if (e.deltaY < 0) newScale *= zoomFactor; 
            else newScale /= zoomFactor; 
            
            const minScaleFactor = 0.001; 
            const maxScaleFactor = 300000; 
            scale = Math.max(minScaleFactor, Math.min(maxScaleFactor, newScale));
            
            const worldAfterZoom_if_pan_did_not_change = {
                x: (mouseX_screen - panX) / scale, 
                y: -(mouseY_screen - panY) / scale  
            };

            panX += (worldAfterZoom_if_pan_did_not_change.x - worldBeforeZoom.x) * scale;
            panY += (worldAfterZoom_if_pan_did_not_change.y - worldBeforeZoom.y) * (-scale); 

            draw();
        }


        function handleContextMenu(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            // e.clientX - rect.left уже дает координату относительно canvas
            const worldCoords = screenToWorld(e.clientX - rect.left, e.clientY - rect.top); 
            contextMenuTarget = findElementAt(worldCoords.x, worldCoords.y); 

            if (contextMenuTarget) {
                deleteNodeItem.style.display = contextMenuTarget.type === 'node' ? 'block' : 'none';
                deleteLineItem.style.display = contextMenuTarget.type === 'line' ? 'block' : 'none';
                // Позиционирование контекстного меню относительно всего документа
                customContextMenu.style.left = `${e.clientX}px`;
                customContextMenu.style.top = `${e.clientY}px`;
                customContextMenu.classList.remove('hidden');
            } else {
                hideContextMenu();
            }
        }
        
        function handleClickOutsideContextMenu(e) {
            if (!customContextMenu.contains(e.target)) {
                hideContextMenu();
            }
        }

        function hideContextMenu() {
            customContextMenu.classList.add('hidden');
            contextMenuTarget = null;
        }

        // Element Interaction & Deletion
        function findNodeAt(worldX_currentUnit, worldY_currentUnit) {
            const clickRadiusWorld = 12 / scale; 
            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i]; 
                const dist = Math.sqrt((node.x - worldX_currentUnit)**2 + (node.y - worldY_currentUnit)**2);
                if (dist < clickRadiusWorld) return node;
            }
            return null;
        }

        function findLineAt(worldX_currentUnit, worldY_currentUnit) {
            const clickRadiusWorld = 6 / scale; 
            for (let i = lines.length - 1; i >= 0; i--) {
                const line = lines[i];
                const n1 = nodes.find(n => n.node_id === line.nodeId1); 
                const n2 = nodes.find(n => n.node_id === line.nodeId2); 
                if (n1 && n2) { 
                    const lenSq = (n1.x - n2.x)**2 + (n1.y - n2.y)**2; 
                    if (lenSq === 0) continue; 
                    let t = ((worldX_currentUnit - n1.x) * (n2.x - n1.x) + (worldY_currentUnit - n1.y) * (n2.y - n1.y)) / lenSq;
                    t = Math.max(0, Math.min(1, t));
                    const projX = n1.x + t * (n2.x - n1.x); 
                    const projY = n1.y + t * (n2.y - n1.y); 
                    const dist = Math.sqrt((worldX_currentUnit - projX)**2 + (worldY_currentUnit - projY)**2); 
                    if (dist < clickRadiusWorld) return line;
                }
            }
            return null;
        }

        function findElementAt(worldX_currentUnit, worldY_currentUnit) {
            const node = findNodeAt(worldX_currentUnit, worldY_currentUnit);
            if (node) return { type: 'node', element: node };
            const line = findLineAt(worldX_currentUnit, worldY_currentUnit);
            if (line) return { type: 'line', element: line };
            return null;
        }

        function handleDeleteNode() {
            if (contextMenuTarget && contextMenuTarget.type === 'node') {
                const nodeIdToDelete = contextMenuTarget.element.node_id; 
                nodes = nodes.filter(node => node.node_id !== nodeIdToDelete); 
                lines = lines.filter(line => line.nodeId1 !== nodeIdToDelete && line.nodeId2 !== nodeIdToDelete);
                // Удаляем закрепление, если оно было
                restrictions = restrictions.filter(res => res.node_id !== nodeIdToDelete);
				nodeLoads = nodeLoads.filter(load => load.target_id !== nodeIdToDelete);

                if (firstNodeForLine && firstNodeForLine.node_id === nodeIdToDelete) firstNodeForLine = null; 
                if (selectedNode && selectedNode.node_id === nodeIdToDelete) selectedNode = null; 
                hideContextMenu();
                updatePropertiesPanel(); 
                draw();
            }
        }

        function handleDeleteLine() {
             if (contextMenuTarget && contextMenuTarget.type === 'line') {
                lines = lines.filter(line => line.elem_id !== contextMenuTarget.element.elem_id); 
                hideContextMenu();
                draw();
            }
        }

		function clearAll() {
            nodes = [];
            lines = [];
            restrictions = [];
            nodeLoads = []; // Очищаем нагрузки
			elementLoads = []; // НОВОЕ: Очищаем распределенные нагрузки
            nextNodeId = 1;
            nextElemId = 1;
            nextLoadId = 1; // Сбрасываем счетчик ID нагрузок
			nextElementLoadId = 1; // НОВОЕ: Сбрасываем счетчик ID распределенных нагрузок
            selectedNode = null;
            firstNodeForLine = null;
			// НОВОЕ: Сбрасываем также selectedElement
            selectedElement = null;
            updatePropertiesPanel();
            draw();
        }

        // Node Properties Panel Logic
        function updatePropertiesPanel() {
            const propertiesPanel = document.getElementById('propertiesPanel');
            const nodePropertiesContent = document.getElementById('nodePropertiesContent');

            if (selectedNode) {
                propertiesPanel.style.display = 'block';

                // Получаем текущую выбранную единицу отображения силы и длины
                const currentForceDisplayUnit = forceUnitsSelect.value; 
                const currentLengthDisplayUnit = unitsSelect.value;
                const currentMomentDisplayUnit = currentForceDisplayUnit + '*' + currentLengthDisplayUnit;

                let loadsHtml = '';
                const nodeSpecificLoads = nodeLoads.filter(load => load.target_id === selectedNode.node_id);
                if (nodeSpecificLoads.length === 0) {
                    loadsHtml += '<p class="text-gray-500 text-sm">Нагрузок нет</p>';
                } else {
                    loadsHtml += '<div class="mb-2">';
                    nodeSpecificLoads.forEach(load => {
                        let displayedValue;
                        let displayedUnitString;

                        if (load.type === 'point_force') {
                            displayedValue = convertForce(load.value, load.unit, currentForceDisplayUnit).toFixed(2);
                            displayedUnitString = currentForceDisplayUnit;
                        } else if (load.type === 'moment') {
                            // Конвертируем значение момента
                            displayedValue = convertMoment(load.value, load.unit, load.lengthUnit, currentForceDisplayUnit, currentLengthDisplayUnit).toFixed(2);
                            displayedUnitString = currentMomentDisplayUnit;
                        }
                        
                        loadsHtml += `
                            <div class="load-item">
                                <span>${load.type === 'point_force' ? 'F' : 'M'}${load.component !== 'moment' ? load.component.toUpperCase() : ''}: ${displayedValue} ${displayedUnitString}</span>
                                <button data-load-id="${load.load_id}">Удалить</button>
                            </div>
                        `;
                    });
                    loadsHtml += '</div>';
                }

                // Получаем текущие закрепления для выбранного узла
                let currentRestriction = restrictions.find(r => r.node_id === selectedNode.node_id);
                // Если закреплений нет, создаем "пустой" объект для удобства
                if (!currentRestriction) {
                    currentRestriction = { dx: 0, dy: 0, dr: 0, type: "none" };
                }

                // HTML-разметка для свойств узла
                nodePropertiesContent.innerHTML = `
                    <h4 class="font-bold text-gray-700 mb-2">Свойства узла ${selectedNode.node_id}</h4>
                    <div class="property-group">
                        <label for="nodeX">X:</label>
                        <input type="number" id="nodeX" value="${selectedNode.x.toFixed(2)}">
                        <label for="nodeY">Y:</label>
                        <input type="number" id="nodeY" value="${selectedNode.y.toFixed(2)}">
                    </div>
                    <div class="property-group">
                        <h4 class="font-bold text-gray-700 mb-2">Закрепления</h4>
                        <div id="restrictionIconsContainer" class="flex flex-wrap gap-2 mb-4">
                            </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="restrictX" class="mr-2" ${currentRestriction.dx === 1 ? 'checked' : ''}>
                            <label for="restrictX">dx</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="restrictY" class="mr-2" ${currentRestriction.dy === 1 ? 'checked' : ''}>
                            <label for="restrictY">dy</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="restrictR" class="mr-2" ${currentRestriction.dr === 1 ? 'checked' : ''}>
                            <label for="restrictR">dr</label>
                        </div>
                    </div>
                    <div class="property-group">
                        <h4 class="font-bold text-gray-700 mb-2">Нагрузки</h4>
                        <div id="nodeLoadsList" class="mb-4">
                            ${loadsHtml} </div>
                        <div class="load-input-group">
                            <label for="addForceX" class="sr-only">Сила X</label>
                            <input type="number" id="addForceX" placeholder="Fx">
                            <span id="currentForceUnitDisplay_Fx" class="ml-2 font-semibold text-gray-700"></span> 
                            <button id="addForceXBtn">Добавить Fx</button>
                        </div>
                        <div class="load-input-group">
                            <label for="addForceY" class="sr-only">Сила Y</label>
                            <input type="number" id="addForceY" placeholder="Fy">
                            <span id="currentForceUnitDisplay_Fy" class="ml-2 font-semibold text-gray-700"></span>
                            <button id="addForceYBtn">Добавить Fy</button>
                        </div>
                        <div class="load-input-group">
                            <label for="addMoment" class="sr-only">Момент</label>
                            <input type="number" id="addMoment" placeholder="M">
                            <span id="currentForceUnitDisplay_M" class="ml-2 font-semibold text-gray-700"></span>
                            <button id="addMomentBtn">Добавить M</button>
                        </div>
                    </div>
                `;

                // =========================================================================
                // ПЕРЕМЕЩЕННЫЕ DOM ЭЛЕМЕНТЫ и их ОБРАБОТЧИКИ СОБЫТИЙ:
                // Эти элементы теперь существуют в DOM, можно их получить и работать с ними.
                // =========================================================================

                // DOM элементы для узлов
                const nodeXInput = document.getElementById('nodeX');
                const nodeYInput = document.getElementById('nodeY');

                // DOM элементы для закреплений
                const restrictXCheckbox = document.getElementById('restrictX');
                const restrictYCheckbox = document.getElementById('restrictY');
                const restrictRCheckbox = document.getElementById('restrictR');
                const restrictionIconsContainer = document.getElementById('restrictionIconsContainer');

                // DOM элементы для нагрузок
                const nodeLoadsList = document.getElementById('nodeLoadsList');
                const addForceXInput = document.getElementById('addForceX');
                const addForceXBtn = document.getElementById('addForceXBtn');
                const addForceYInput = document.getElementById('addForceY');
                const addForceYBtn = document.getElementById('addForceYBtn');
                const addMomentInput = document.getElementById('addMoment');
                const addMomentBtn = document.getElementById('addMomentBtn');

                // Обновляем значения полей X и Y для выбранного узла
                nodeXInput.value = selectedNode.x.toFixed(3);
                nodeYInput.value = selectedNode.y.toFixed(3);

                // Обработчики ввода координат узла
                nodeXInput.addEventListener('change', (e) => {
                    const newValue = parseFloat(e.target.value);
                    if (!isNaN(newValue)) {
                        selectedNode.x = newValue;
                        draw();
                    }
                });

                nodeYInput.addEventListener('change', (e) => {
                    const newValue = parseFloat(e.target.value);
                    if (!isNaN(newValue)) {
                        selectedNode.y = newValue;
                        draw();
                    }
                });

                // =========================================================================
                // ЛОГИКА ДЛЯ ЗАКРЕПЛЕНИЙ (ОСТАВЛЕНО БЕЗ ИЗМЕНЕНИЙ)
                // =========================================================================
                // Получаем текущие закрепления для выбранного узла (перенесено выше, но здесь используется)
                // let currentRestriction = restrictions.find(r => r.node_id === selectedNode.node_id);
                // if (!currentRestriction) { currentRestriction = { dx: 0, dy: 0, dr: 0, type: "none" }; }


                // Вспомогательная функция для обновления закрепления
                const updateRestriction = () => {
                    let updated = false;
                    restrictions = restrictions.filter(r => {
                        if (r.node_id === selectedNode.node_id) {
                            r.dx = restrictXCheckbox.checked ? 1 : 0;
                            r.dy = restrictYCheckbox.checked ? 1 : 0;
                            r.dr = restrictRCheckbox.checked ? 1 : 0;
                            updated = true;
                            // Если все ограничения сняты, удаляем закрепление
                            if (r.dx === 0 && r.dy === 0 && r.dr === 0) {
                                return false; // Удаляем элемент из массива
                            }
                        }
                        return true; // Сохраняем элемент
                    });

                    // Если закрепления не было, и сейчас есть хотя бы одно, добавляем его
                    if (!updated && (restrictXCheckbox.checked || restrictYCheckbox.checked || restrictRCheckbox.checked)) {
                        restrictions.push({
                            node_id: selectedNode.node_id,
                            dx: restrictXCheckbox.checked ? 1 : 0,
                            dy: restrictYCheckbox.checked ? 1 : 0,
                            dr: restrictRCheckbox.checked ? 1 : 0
                        });
                    }
                    draw(); // Перерисовать, чтобы показать изменения закреплений
                    renderRestrictionIcons(); // Обновляем иконки закреплений
                };

                // Обработчики чекбоксов
                restrictXCheckbox.addEventListener('change', updateRestriction);
                restrictYCheckbox.addEventListener('change', updateRestriction);
                restrictRCheckbox.addEventListener('change', updateRestriction);


                // Логика для кнопок закреплений
                const renderRestrictionIcons = () => {
                    restrictionIconsContainer.innerHTML = ''; // Очищаем контейнер

                    // Обновляем currentRestriction здесь, чтобы он был актуален для иконок
                    currentRestriction = restrictions.find(r => r.node_id === selectedNode.node_id);
                    if (!currentRestriction) {
                        currentRestriction = { dx: 0, dy: 0, dr: 0, type: "none" };
                    }

                    // Добавляем иконку "Нет закрепления"
                    const noRestrictionBtn = document.createElement('button');
                    noRestrictionBtn.className = `restriction-icon-btn ${currentRestriction.dx === 0 && currentRestriction.dy === 0 && currentRestriction.dr === 0 ? 'active' : ''}`;
                    noRestrictionBtn.innerHTML = '<span class="no-restriction-text">Ø</span>';
                    noRestrictionBtn.title = 'Нет закрепления';
                    noRestrictionBtn.addEventListener('click', () => {
                        restrictions = restrictions.filter(r => r.node_id !== selectedNode.node_id);
                        restrictXCheckbox.checked = false;
                        restrictYCheckbox.checked = false;
                        restrictRCheckbox.checked = false;
                        updateRestriction(); // Чтобы обновить состояние иконок
                    });
                    restrictionIconsContainer.appendChild(noRestrictionBtn);

                    for (const typeKey in restrictionTypes) {
                        const type = restrictionTypes[typeKey];
                        if (type.icon) {
                            const btn = document.createElement('button');
                            btn.className = `restriction-icon-btn ${currentRestriction.dx === type.dx && currentRestriction.dy === type.dy && currentRestriction.dr === type.dr ? 'active' : ''}`;
                            btn.innerHTML = `<img src="icons/${type.icon}" alt="${type.label}" title="${type.label}">`;
                            btn.title = type.label;
                            btn.addEventListener('click', () => {
                                restrictions = restrictions.filter(r => r.node_id !== selectedNode.node_id); // Удаляем старое
                                restrictions.push({
                                    node_id: selectedNode.node_id,
                                    dx: type.dx,
                                    dy: type.dy,
                                    dr: type.dr
                                });
                                restrictXCheckbox.checked = type.dx === 1;
                                restrictYCheckbox.checked = type.dy === 1;
                                restrictRCheckbox.checked = type.dr === 1;
                                updateRestriction(); // Обновляем иконки и перерисовываем
                            });
                            restrictionIconsContainer.appendChild(btn);
                        }
                    }
                };

                renderRestrictionIcons(); // Вызываем для первой отрисовки иконок

                // =========================================================================
                // ЛОГИКА ДЛЯ НАГРУЗОК (ВАЖНЫЕ ИЗМЕНЕНИЯ СЮДА)
                // =========================================================================
                // Функция для отображения текущих нагрузок на узле
                const renderNodeLoads = () => {
                    nodeLoadsList.innerHTML = ''; // Очищаем список
                    const loadsForSelectedNode = nodeLoads.filter(load => load.target_id === selectedNode.node_id);

                    if (loadsForSelectedNode.length === 0) {
                        nodeLoadsList.innerHTML = '<p class="text-gray-500 text-sm">Нагрузок нет</p>';
                    } else {
                        // Получаем текущую выбранную единицу отображения силы и длины
                        const currentForceDisplayUnit = forceUnitsSelect.value; 
                        const currentLengthDisplayUnit = unitsSelect.value;
                        const currentMomentDisplayUnit = currentForceDisplayUnit + '*' + currentLengthDisplayUnit;

                        nodeLoadsList.innerHTML = ''; // Очищаем список перед добавлением элементов
                        nodeSpecificLoads.forEach(load => { 
                            let displayedValue;
                            let displayedUnitString;

                            if (load.type === 'point_force') {
                                displayedValue = convertForce(load.value, load.unit, currentForceDisplayUnit).toFixed(2);
                                displayedUnitString = currentForceDisplayUnit;
                            } else if (load.type === 'moment') {
                                // Конвертируем значение момента
                                displayedValue = convertMoment(load.value, load.unit, load.lengthUnit, currentForceDisplayUnit, currentLengthDisplayUnit).toFixed(2);
                                displayedUnitString = currentMomentDisplayUnit;
                            }
                            
                            let loadLabel = '';
                            switch (load.type) {
                                case 'point_force':
                                    loadLabel = `F${load.component.toUpperCase()}: ${displayedValue} ${displayedUnitString}`; 
                                    break;
                                case 'moment':
                                    loadLabel = `M: ${displayedValue} ${displayedUnitString}`; 
                                    break;
                            }

                            const loadItemDiv = document.createElement('div');
                            loadItemDiv.className = 'load-item';
                            loadItemDiv.innerHTML = `
                                <span>${loadLabel}</span>
                                <button data-load-id="${load.load_id}">Удалить</button>
                            `;
                            nodeLoadsList.appendChild(loadItemDiv);
                        });

                        // Добавляем обработчики для кнопок удаления нагрузок
                        nodeLoadsList.querySelectorAll('.load-item button').forEach(button => {
                            button.addEventListener('click', (e) => {
                                const loadIdToDelete = parseInt(e.target.dataset.loadId);
                                nodeLoads = nodeLoads.filter(load => load.load_id !== loadIdToDelete);
                                renderNodeLoads(); // Обновляем только список нагрузок
                                draw(); // Перерисовываем канвас
                            });
                        });
                    }
                };

                // Вызываем при первой загрузке панели для узла
                renderNodeLoads();

                // Обработчики добавления нагрузок
                // При добавлении нагрузки, сохраняем ее значение и ТЕКУЩУЮ ЕДИНИЦУ
                addForceXBtn.addEventListener('click', () => {
                    const value = parseFloat(addForceXInput.value);
                    if (!isNaN(value)) {
                        nodeLoads.push({
                            load_id: nextLoadId++,
                            type: 'point_force',
                            target_id: selectedNode.node_id,
                            component: 'x',
                            value: value,
                            unit: forceUnitsSelect.value // <-- СОХРАНЯЕМ ЕДИНИЦУ СИЛЫ ВВОДА
                        });
                        addForceXInput.value = ''; // Очищаем поле
                        renderNodeLoads(); // Обновляем только список нагрузок
                        draw(); // Перерисовываем канвас
                    }
                });

                addForceYBtn.addEventListener('click', () => {
                    const value = parseFloat(addForceYInput.value);
                    if (!isNaN(value)) {
                        nodeLoads.push({
                            load_id: nextLoadId++,
                            type: 'point_force',
                            target_id: selectedNode.node_id,
                            component: 'y',
                            value: value,
                            unit: forceUnitsSelect.value // <-- СОХРАНЯЕМ ЕДИНИЦУ СИЛЫ ВВОДА
                        });
                        addForceYInput.value = ''; // Очищаем поле
                        renderNodeLoads();
                        draw();
                    }
                });

                addMomentBtn.addEventListener('click', () => {
                    const value = parseFloat(addMomentInput.value);
                    if (!isNaN(value)) {
                        nodeLoads.push({
                            load_id: nextLoadId++,
                            type: 'moment',
                            target_id: selectedNode.node_id,
                            component: 'r', // 'r' для момента (rotation)
                            value: value,
                            unit: forceUnitsSelect.value, // <-- СОХРАНЯЕМ ЕДИНИЦУ СИЛЫ ВВОДА
                            lengthUnit: unitsSelect.value // <-- НОВОЕ: СОХРАНЯЕМ ЕДИНИЦУ ДЛИНЫ ВВОДА
                        });
                        addMomentInput.value = ''; // Очищаем поле
                        renderNodeLoads();
                        draw();
                    }
                });

			} else if (selectedElement) { // НОВОЕ: Если выбрана линия
                propertiesPanel.style.display = 'block';

                const currentForceDisplayUnit = forceUnitsSelect.value;
                const currentLengthDisplayUnit = unitsSelect.value;
                const currentMomentDisplayUnit = `${currentForceDisplayUnit}*${currentLengthDisplayUnit}`;
                const currentDistributedForceUnit = `${currentForceDisplayUnit}/${currentLengthDisplayUnit}`; // НОВОЕ: Единица для распределенной нагрузки

                let loadsHtml = '';
                const elementSpecificLoads = elementLoads.filter(load => load.target_elem_id === selectedElement.elem_id);
                if (elementSpecificLoads.length === 0) {
                    loadsHtml += '<p class="text-gray-500 text-sm">Нагрузок нет</p>';
                } else {
                    loadsHtml += '<div class="mb-2">';
                    elementSpecificLoads.forEach(load => {
                        let displayedValue;
                        let displayedUnitString;
						
						// НОВОЕ: Отладочные сообщения перед конвертацией
						console.log("Processing elementLoad:", load);
                        console.log("Load unit string:", load.unit); // Посмотрим, что хранится в load.unit

                        // Для распределенных нагрузок, unit - это уже N/m, kN/m и т.д.
                        // Нам нужно конвертировать только числовое значение
                        // из сохраненной единицы (load.unit) в текущую отображаемую (currentDistributedForceUnit)
                        // Это потребует новой функции convertDistributedForce, которую мы добавим позже.
                        // Пока что будем отображать как есть, или упростим.
                        // Для простоты, пока что, будем считать, что load.unit уже в kN/m или N/mm и т.д.
                        // и конвертировать только числовую часть.
                        // TODO: Реализовать convertDistributedForce
                        
                        // Временно, для отображения, будем использовать convertForce,
                        // но нужно будет уточнить логику, так как это N/m, а не N
                        // Для отображения, можем просто взять load.value и load.unit
                        // и добавить логику конвертации, когда будут все коэффициенты.
                        // Сейчас load.unit будет строкой типа "kN/m", поэтому просто отображаем ее.
                        
                        // Для корректной конвертации распределенных нагрузок:
                        // Нужно конвертировать (value * force_conversion_factor) / (length_conversion_factor)
                        const storedForceUnit = load.unit.split('/')[0]; // Например, 'kN' из 'kN/m'
                        const storedLengthUnit = load.unit.split('/')[1]; // Например, 'm' из 'kN/m'
						
						console.log("Parsed stored units: Force=", storedForceUnit, "Length=", storedLengthUnit);

                        const targetForceUnit = currentDistributedForceUnit.split('/')[0];
                        const targetLengthUnit = currentDistributedForceUnit.split('/')[1];
						
						console.log("Target display units: Force=", targetForceUnit, "Length=", targetLengthUnit);
						
						// Убедимся, что load.startValue - это число
                        if (isNaN(load.startValue)) {
                            console.error("load.startValue is NaN:", load.startValue);
                            displayedValue = "NaN";
                        } else {
                            displayedValue = convertDistributedForce(load.startValue, storedForceUnit, storedLengthUnit, targetForceUnit, targetLengthUnit).toFixed(5);
                            // НОВОЕ: Отладочное сообщение после конвертации
                            console.log("Displayed value after conversion:", displayedValue);
                        }
                        displayedUnitString = currentDistributedForceUnit;

						displayedValue = convertDistributedForce(load.startvalue, storedForceUnit, storedLengthUnit, targetForceUnit, targetLengthUnit).toFixed(5); // ИЗМЕНЕНО: Используем convertDistributedForce
                        displayedUnitString = currentDistributedForceUnit;


                        loadsHtml += `
                            <div class="load-item">
                                <span>q${load.component.toUpperCase()}: ${displayedValue} ${displayedUnitString}</span>
                                <button data-load-id="${load.load_id}" data-load-type="distributed">Удалить</button>
                            </div>
                        `;
                    });
                    loadsHtml += '</div>';
                }

                nodePropertiesContent.innerHTML = `
                    <h4 class="font-bold text-gray-700 mb-2">Свойства элемента ${selectedElement.elem_id}</h4>
                    <div class="property-group">
                        <p>Начальный узел: ${selectedElement.nodeId1}</p>
                        <p>Конечный узел: ${selectedElement.nodeId2}</p>
                    </div>
                    <div class="property-group">
                        <h4 class="font-bold text-gray-700 mb-2">Распределенные нагрузки</h4>
                        <div id="elementLoadsList" class="mb-4">
                            ${loadsHtml}
                        </div>
                        <div class="load-input-group">
                            <label for="addDistributedForceX" class="sr-only">Равномерная нагрузка X</label>
                            <input type="number" id="addDistributedForceX" placeholder="qX">
                            <span id="currentDistributedForceUnitDisplay_qX" class="ml-2 font-semibold text-gray-700">${currentDistributedForceUnit}</span>
                            <button id="addDistributedForceXBtn">Добавить qX</button>
                        </div>
                        <div class="load-input-group">
                            <label for="addDistributedForceY" class="sr-only">Равномерная нагрузка Y</label>
                            <input type="number" id="addDistributedForceY" placeholder="qY">
                            <span id="currentDistributedForceUnitDisplay_qY" class="ml-2 font-semibold text-gray-700">${currentDistributedForceUnit}</span>
                            <button id="addDistributedForceYBtn">Добавить qY</button>
                        </div>
						<!-- НОВОЕ: Раздел для разбиения элемента -->
						<div class="property-group">
							<h4 class="font-bold text-gray-700 mb-2">Разбить стержень</h4>
							<div class="flex items-center space-x-2 mb-2">
								<input type="number" id="splitSegmentsInput" value="2" min="2" class="flex-grow form-input block w-full pl-3 pr-3 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md">
								<button id="splitElementBtn" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">Разбить</button>
							</div>
						</div>
                    </div>
                `;

                // НОВОЕ: Получаем DOM элементы для распределенных нагрузок
                const elementLoadsList = document.getElementById('elementLoadsList');
                const addDistributedForceXInput = document.getElementById('addDistributedForceX');
                const addDistributedForceXBtn = document.getElementById('addDistributedForceXBtn');
                const addDistributedForceYInput = document.getElementById('addDistributedForceY');
                const addDistributedForceYBtn = document.getElementById('addDistributedForceYBtn');

                // НОВОЕ: Функция для отображения текущих распределенных нагрузок на элементе
                const renderElementLoads = () => {
                    elementLoadsList.innerHTML = '';
                    const loadsForSelectedElement = elementLoads.filter(load => load.target_elem_id === selectedElement.elem_id);

                    if (loadsForSelectedElement.length === 0) {
                        elementLoadsList.innerHTML = '<p class="text-gray-500 text-sm">Нагрузок нет</p>';
                    } else {
                        const currentForceDisplayUnit = forceUnitsSelect.value;
                        const currentLengthDisplayUnit = unitsSelect.value;
                        const currentDistributedForceUnit = `${currentForceDisplayUnit}/${currentLengthDisplayUnit}`;

                        loadsForSelectedElement.forEach(load => {
                            const storedForceUnit = load.unit.split('/')[0];
                            const storedLengthUnit = load.unit.split('/')[1];
                            const targetForceUnit = currentDistributedForceUnit.split('/')[0];
                            const targetLengthUnit = currentDistributedForceUnit.split('/')[1];

                            const displayedValue = parseFloat(convertDistributedForce(load.startValue, storedForceUnit, storedLengthUnit, targetForceUnit, targetLengthUnit).toFixed(3)); // ИЗМЕНЕНО: Используем convertDistributedForce
                            const displayedUnitString = currentDistributedForceUnit;
                            
                            const loadItemDiv = document.createElement('div');
                            loadItemDiv.className = 'load-item';
                            loadItemDiv.innerHTML = `
                                <span>q${load.component.toUpperCase()}: ${displayedValue} ${displayedUnitString}</span>
                                <button data-load-id="${load.load_id}" data-load-type="distributed">Удалить</button>
                            `;
                            elementLoadsList.appendChild(loadItemDiv);
                        });

                        elementLoadsList.querySelectorAll('.load-item button').forEach(button => {
                            button.addEventListener('click', (e) => {
                                const loadIdToDelete = parseInt(e.target.dataset.loadId);
                                elementLoads = elementLoads.filter(load => load.load_id !== loadIdToDelete);
                                renderElementLoads();
                                draw();
                            });
                        });
                    }
                };

                renderElementLoads(); // Вызываем при первой загрузке панели для элемента

                // НОВОЕ: Обработчики добавления распределенных нагрузок
                addDistributedForceXBtn.addEventListener('click', () => {
                    const value = parseFloat(addDistributedForceXInput.value);
                    if (!isNaN(value)) {
                        elementLoads.push({
                            load_id: nextElementLoadId++,
                            target_elem_id: selectedElement.elem_id,
                            type: 'uniform', 
                            component: 'x',
                            startValue: value, // НОВОЕ: Сохраняем полную точность
                            endValue: value,   // НОВОЕ: Сохраняем полную точность
                            unit: `${forceUnitsSelect.value}/${unitsSelect.value}`, // Сохраняем текущую единицу
                            startPosition: 0, 
                            endPosition: 1 
                        });
                        addDistributedForceXInput.value = '';
                        renderElementLoads(); // Обновляем список нагрузок на панели
                        draw(); // Перерисовываем канвас
                    }
                });

                addDistributedForceYBtn.addEventListener('click', () => {
                    const value = parseFloat(addDistributedForceYInput.value);
                    if (!isNaN(value)) {
                        elementLoads.push({
                            load_id: nextElementLoadId++,
                            target_elem_id: selectedElement.elem_id,
                            type: 'uniform',
                            component: 'y',
                            startValue: value, // НОВОЕ: Сохраняем полную точность
                            endValue: value,   // НОВОЕ: Сохраняем полную точность
                            unit: `${forceUnitsSelect.value}/${unitsSelect.value}`,
                            startPosition: 0, 
                            endPosition: 1 
                        });
                        addDistributedForceYInput.value = '';
                        renderElementLoads();
                        draw();
                    }
                });
				
				// НОВОЕ: Логика для разбиения элемента
                const splitSegmentsInput = document.getElementById('splitSegmentsInput');
                const splitElementBtn = document.getElementById('splitElementBtn');

                splitElementBtn.addEventListener('click', () => {
                    if (!selectedElement) return; // Убедимся, что элемент выбран

                    const numSegments = parseInt(splitSegmentsInput.value, 10);
                    if (isNaN(numSegments) || numSegments < 2) {
                        console.error("Некорректное количество участков для разбиения. Должно быть не менее 2.");
                        return;
                    }

                    const originalLine = selectedElement;
                    const node1 = nodes.find(n => n.node_id === originalLine.nodeId1);
                    const node2 = nodes.find(n => n.node_id === originalLine.nodeId2);

                    if (!node1 || !node2) {
                        console.error("Не найдены узлы для выбранного элемента.");
                        return;
                    }

                    // 1. Удаляем текущий стержень
                    lines = lines.filter(line => line.elem_id !== originalLine.elem_id);
                    console.log(`Удален стержень с ID: ${originalLine.elem_id}`);

                    // 2. Удаляем равномерно-распределенные нагрузки, связанные с удаленным стержнем
                    elementLoads = elementLoads.filter(load => load.target_elem_id === originalLine.elem_id);
                    console.log(`Удалены равномерно-распределенные нагрузки для стержня ${originalLine.elem_id}`);

                    const newNodes = [];
                    const newLines = [];
                    
                    // Вычисляем вектор элемента
                    const dx = node2.x - node1.x;
                    const dy = node2.y - node1.y;

                    // Создаем промежуточные узлы
                    for (let i = 1; i < numSegments; i++) {
                        const ratio = i / numSegments;
                        const newNodeX = node1.x + dx * ratio;
                        const newNodeY = node1.y + dy * ratio;

                        // Координаты новых узлов хранятся с полной точностью
                        const newNode = { 
                            node_id: nextNodeId++, 
                            x: newNodeX, 
                            y: newNodeY 
                        };
                        newNodes.push(newNode);
                        console.log(`Добавлен новый узел ${newNode.node_id} по координатам (${newNode.x.toFixed(3)}, ${newNode.y.toFixed(3)})`);
                    }

                    // Соединяем узлы, формируя новые стержни
                    // Все узлы в правильном порядке: начальный, новые промежуточные, конечный
                    const allSegmentNodes = [node1, ...newNodes, node2]; 

                    for (let i = 0; i < allSegmentNodes.length - 1; i++) {
                        const startNode = allSegmentNodes[i];
                        const endNode = allSegmentNodes[i + 1];

                        const newLine = { 
                            elem_id: nextElemId++, 
                            nodeId1: startNode.node_id, 
                            nodeId2: endNode.node_id, 
                            // Наследуем structural_type от оригинального элемента. 
                            // Если его нет (старые данные), по умолчанию 'beam'.
                            structural_type: originalLine.structural_type || 'beam' 
                        };
                        newLines.push(newLine);
                        console.log(`Добавлен новый стержень ${newLine.elem_id} между узлами ${startNode.node_id} и ${endNode.node_id}`);
                    }

                    // Добавляем новые узлы и стержни в глобальные массивы
                    nodes.push(...newNodes);
                    lines.push(...newLines);

                    // Сбрасываем выделение после операции разбиения
                    selectedElement = null;
                    selectedNode = null;
                    firstNodeForLine = null;

                    // Обновляем UI
                    updatePropertiesPanel(); // Перерисует панель без выделенного элемента
                    draw(); // Перерисует канвас с новыми элементами
                });

            } else { // НОВОЕ: Если ничего не выбрано
                propertiesPanel.style.display = 'block'; 
                nodePropertiesContent.innerHTML = '<p>Выберите узел или элемент для просмотра его свойств.</p>'; // Обновленный текст
            }
        }

        function applyRestrictionToSelectedNode(dxValue, dyValue, drValue) { // Corrected to drValue
            if (!selectedNode) return;

            let existingRestrictionIndex = restrictions.findIndex(res => res.node_id === selectedNode.node_id);

            // Создаем объект закрепления на основе значений dx, dy, dr
            const newRestriction = {
                node_id: selectedNode.node_id,
                dx: dxValue,
                dy: dyValue,
                dr: drValue // Corrected to drValue
            };

            // Если все флаги равны 0 (т.е. "нет закрепления"), удаляем запись
            if (dxValue === 0 && dyValue === 0 && drValue === 0) { // Corrected to drValue
                if (existingRestrictionIndex !== -1) {
                    restrictions.splice(existingRestrictionIndex, 1); // Удаляем запись
                }
            } else {
                if (existingRestrictionIndex !== -1) {
                    // Обновляем существующую запись
                    restrictions[existingRestrictionIndex] = newRestriction;
                } else {
                    // Добавляем новую запись
                    restrictions.push(newRestriction);
                }
            }
            draw(); // Перерисовываем холст, чтобы отобразить изменения
            // После применения, обновляем панель, чтобы состояние кнопок обновилось
            updatePropertiesPanel(); 
        }


        // Tooltip
        function updateTooltip() { 
            // Получаем ширину панели свойств (она всегда видима)
            const panelWidth = propertiesPanel.offsetWidth;

            if (hoveredElement && !isPanning && customContextMenu.classList.contains('hidden')) { 
                let content = '';
                if (hoveredElement.type === 'node') {
                    const node = hoveredElement.element;
                    const restriction = restrictions.find(res => res.node_id === node.node_id);
                    let restrictionInfo = '';
                    if (restriction) {
                        const typeKey = Object.keys(restrictionTypes).find(key => 
                            restrictionTypes[key].dx === restriction.dx &&
                            restrictionTypes[key].dy === restriction.dy &&
                            restrictionTypes[key].dr === restriction.dr // Corrected to dr
                        );
                        if (typeKey && restrictionTypes[typeKey].label) {
                            restrictionInfo = `\nЗакрепление: ${restrictionTypes[typeKey].label}`;
                        } else {
                             restrictionInfo = `\nЗакрепление: dx=${restriction.dx}, dy=${restriction.dy}, dr=${restriction.dr}`; // Corrected to dr
                        }
                    }

                    content = `Узел ${node.node_id}\nX: ${node.x.toFixed(3)} ${currentUnit}\nY: ${node.y.toFixed(3)} ${currentUnit}${restrictionInfo}`; 
                } else if (hoveredElement.type === 'line') {
                    const line = hoveredElement.element;
                    const n1 = nodes.find(n => n.node_id === line.nodeId1); 
                    const n2 = nodes.find(n => n.node_id === line.nodeId2); 
                    if (n1 && n2) { 
                        const dx = n2.x - n1.x; 
                        const dy = n2.y - n1.y; 
                        const length = Math.sqrt(dx**2 + dy**2); 
                        content = `Стержень ${line.elem_id}\nДлина: ${length.toFixed(3)} ${currentUnit}`; 
                    }
                }
                
                if (content) {
                    tooltip.innerHTML = content;
                    tooltip.classList.remove('hidden'); 
                    tooltip.style.left = `0px`; 
                    tooltip.style.top = `0px`; 
                    const tooltipRect = tooltip.getBoundingClientRect(); 
                    
                    const offsetX = 15; 
                    const offsetY = 15; 

                    let finalLeft = mouse.x + canvas.getBoundingClientRect().left + offsetX;
                    let finalTop = mouse.y + canvas.getBoundingClientRect().top + offsetY;

                    if (finalLeft + tooltipRect.width > window.innerWidth) {
                        finalLeft = mouse.x + canvas.getBoundingClientRect().left - offsetX - tooltipRect.width; 
                    }

                    if (finalTop + tooltipRect.height > window.innerHeight) {
                        finalTop = mouse.y + canvas.getBoundingClientRect().top - offsetY - tooltipRect.height;
                    }
                    
                    const panelWidth = propertiesPanel.offsetWidth; // Получаем ширину панели здесь
                    if (finalLeft < panelWidth) {
                         // Если тултип слишком близко к левой панели, но курсор правее, попробуем разместить справа от курсора
                         if (mouse.x + canvas.getBoundingClientRect().left < panelWidth + tooltipRect.width + offsetX) { 
                             finalLeft = panelWidth + offsetX; // Размещаем справа от панели
                         } else {
                             finalLeft = mouse.x + canvas.getBoundingClientRect().left - offsetX - tooltipRect.width; // Размещаем слева от курсора
                         }
                    }

                    tooltip.style.left = `${finalLeft}px`; 
                    tooltip.style.top = `${finalTop}px`;
                } else {
                    tooltip.classList.add('hidden');
                }
            } else {
                tooltip.classList.add('hidden');
            }
        }

        // Start the application
        init();
    </script>
</body>
</html>
